const fs = require('fs');
const path = require('path');

const SOURCE_PATH = path.resolve(__dirname, '../src/config/generation-stage-metadata.json');
const ENGINE_OUTPUT_PATH = path.resolve(__dirname, '../src/engine/generated-generation-stages.ts');
const CLIENT_OUTPUT_PATH = path.resolve(__dirname, '../public/js/src/00-stage-metadata.js');

function assert(condition, message) {
  if (!condition) {
    throw new Error(message);
  }
}

function toSingleQuotedString(value) {
  return `'${value.replace(/\\/g, '\\\\').replace(/'/g, "\\'")}'`;
}

function validateMetadata(metadata) {
  assert(metadata && typeof metadata === 'object', 'Metadata must be an object');
  assert(Array.isArray(metadata.stages), 'Metadata must contain a stages array');

  const seenIds = new Set();
  for (const stage of metadata.stages) {
    assert(stage && typeof stage === 'object', 'Each stage entry must be an object');
    assert(typeof stage.id === 'string' && stage.id.length > 0, 'Each stage must have a non-empty id');
    assert(
      /^[A-Z_]+$/.test(stage.id),
      `Stage id "${stage.id}" must use uppercase snake case format`
    );
    assert(!seenIds.has(stage.id), `Duplicate stage id "${stage.id}"`);
    seenIds.add(stage.id);
    assert(
      typeof stage.displayName === 'string' && stage.displayName.length > 0,
      `Stage "${stage.id}" must have a non-empty displayName`
    );
    assert(Array.isArray(stage.phrases), `Stage "${stage.id}" must have a phrases array`);
    assert(stage.phrases.length > 0, `Stage "${stage.id}" must have at least one phrase`);
    stage.phrases.forEach((phrase, index) => {
      assert(
        typeof phrase === 'string' && phrase.length > 0,
        `Stage "${stage.id}" phrase at index ${index} must be a non-empty string`
      );
    });
  }
}

function renderEngineStagesFile(metadata) {
  const lines = [
    '// This file is auto-generated by scripts/sync-stage-metadata.js.',
    '// Do not edit manually; update src/config/generation-stage-metadata.json instead.',
    '',
    'export const GENERATION_STAGES = [',
    ...metadata.stages.map((stage) => `  ${toSingleQuotedString(stage.id)},`),
    '] as const;',
    '',
  ];

  return `${lines.join('\n')}`;
}

function renderClientStagesFile(metadata) {
  const lines = [
    '// This file is auto-generated by scripts/sync-stage-metadata.js.',
    '// Do not edit manually; update src/config/generation-stage-metadata.json instead.',
    '',
    'const STAGE_PHRASE_POOLS = {',
  ];

  for (const stage of metadata.stages) {
    lines.push(`  ${stage.id}: [`);
    for (const phrase of stage.phrases) {
      lines.push(`    ${toSingleQuotedString(phrase)},`);
    }
    lines.push('  ],');
  }
  lines.push('};');
  lines.push('');
  lines.push('const STAGE_DISPLAY_NAMES = {');
  for (const stage of metadata.stages) {
    lines.push(`  ${stage.id}: ${toSingleQuotedString(stage.displayName)},`);
  }
  lines.push('};');
  lines.push('');

  return `${lines.join('\n')}`;
}

function syncStageMetadata() {
  const metadataRaw = fs.readFileSync(SOURCE_PATH, 'utf8');
  const metadata = JSON.parse(metadataRaw);

  validateMetadata(metadata);

  fs.writeFileSync(ENGINE_OUTPUT_PATH, renderEngineStagesFile(metadata), 'utf8');
  fs.writeFileSync(CLIENT_OUTPUT_PATH, renderClientStagesFile(metadata), 'utf8');
}

syncStageMetadata();
