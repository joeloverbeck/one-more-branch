# ACTSTAARC-002: Define ActiveState and ActiveStateChanges Types

**Status**: âœ… COMPLETED
**Priority**: HIGH (blocking other tickets)
**Depends On**: ACTSTAARC-001 (TaggedStateEntry types)
**Estimated Scope**: Small

---

## Summary

Define the core data structures for the new Active State system: `ActiveState` (the accumulated state at any point) and `ActiveStateChanges` (the delta generated by each page).

## Assumption Reassessment

1. ACTSTAARC-001 is already completed and archived; `TaggedStateEntry` and tagged-prefix helpers are already implemented in `src/models/state/tagged-entry.ts`.
2. State unit tests in this repository are centralized in `test/unit/models/state.test.ts` rather than split into `test/unit/models/state/*.test.ts`.
3. Model-level state types are consumed through both `src/models/state/index.ts` and `src/models/index.ts`, so this ticket should export new active-state symbols through both barrels.

---

## Files to Touch

### Create
- `src/models/state/active-state.ts` - New file with ActiveState types

### Modify
- `src/models/state/index.ts` - Export new types
- `src/models/index.ts` - Re-export new state types/functions from top-level models barrel
- `test/unit/models/state.test.ts` - Add ActiveState and ActiveStateChanges unit coverage

---

## Out of Scope (DO NOT CHANGE)

- `src/models/state/general-state.ts` - Old types, deprecated separately
- `src/models/state/tagged-entry.ts` - Created in ACTSTAARC-001
- `src/models/page.ts` - Modified in ACTSTAARC-003
- Any prompt files
- Any engine files
- Any persistence files

---

## Implementation Details

### ActiveState Interface

Represents the "truths that are true right now" at any point in the story.

```typescript
import { TaggedStateEntry } from './tagged-entry.js';

export interface ActiveState {
  readonly currentLocation: string;
  readonly activeThreats: readonly TaggedStateEntry[];
  readonly activeConstraints: readonly TaggedStateEntry[];
  readonly openThreads: readonly TaggedStateEntry[];
}
```

### ActiveStateChanges Interface

Represents the changes generated by a single page.

```typescript
export interface ActiveStateChanges {
  readonly newLocation: string | null;  // null = location unchanged
  readonly threatsAdded: readonly string[];    // Raw strings to parse
  readonly threatsRemoved: readonly string[];  // Prefix-only strings
  readonly constraintsAdded: readonly string[];
  readonly constraintsRemoved: readonly string[];
  readonly threadsAdded: readonly string[];
  readonly threadsResolved: readonly string[];
}
```

### Factory Functions

```typescript
export function createEmptyActiveState(): ActiveState {
  return {
    currentLocation: '',
    activeThreats: [],
    activeConstraints: [],
    openThreads: [],
  };
}

export function createEmptyActiveStateChanges(): ActiveStateChanges {
  return {
    newLocation: null,
    threatsAdded: [],
    threatsRemoved: [],
    constraintsAdded: [],
    constraintsRemoved: [],
    threadsAdded: [],
    threadsResolved: [],
  };
}
```

### Type Guards

```typescript
export function isActiveState(value: unknown): value is ActiveState;
export function isActiveStateChanges(value: unknown): value is ActiveStateChanges;
```

---

## Acceptance Criteria

### Tests That Must Pass

Add coverage to `test/unit/models/state.test.ts`:

```typescript
describe('createEmptyActiveState', () => {
  it('returns state with empty location', () => {
    const state = createEmptyActiveState();
    expect(state.currentLocation).toBe('');
  });

  it('returns state with empty threat array', () => {
    const state = createEmptyActiveState();
    expect(state.activeThreats).toEqual([]);
  });

  it('returns state with empty constraints array', () => {
    const state = createEmptyActiveState();
    expect(state.activeConstraints).toEqual([]);
  });

  it('returns state with empty threads array', () => {
    const state = createEmptyActiveState();
    expect(state.openThreads).toEqual([]);
  });
});

describe('createEmptyActiveStateChanges', () => {
  it('returns changes with null location', () => {
    const changes = createEmptyActiveStateChanges();
    expect(changes.newLocation).toBeNull();
  });

  it('returns changes with empty arrays', () => {
    const changes = createEmptyActiveStateChanges();
    expect(changes.threatsAdded).toEqual([]);
    expect(changes.threatsRemoved).toEqual([]);
    expect(changes.constraintsAdded).toEqual([]);
    expect(changes.constraintsRemoved).toEqual([]);
    expect(changes.threadsAdded).toEqual([]);
    expect(changes.threadsResolved).toEqual([]);
  });
});

describe('isActiveState', () => {
  it('returns true for valid ActiveState', () => {
    const state: ActiveState = {
      currentLocation: 'Room',
      activeThreats: [],
      activeConstraints: [],
      openThreads: [],
    };
    expect(isActiveState(state)).toBe(true);
  });

  it('returns false for null', () => {
    expect(isActiveState(null)).toBe(false);
  });

  it('returns false for missing currentLocation', () => {
    expect(isActiveState({ activeThreats: [], activeConstraints: [], openThreads: [] })).toBe(false);
  });

  it('returns true for state with entries', () => {
    const state: ActiveState = {
      currentLocation: 'Cave',
      activeThreats: [{ prefix: 'THREAT_X', description: 'X', raw: 'THREAT_X: X' }],
      activeConstraints: [],
      openThreads: [],
    };
    expect(isActiveState(state)).toBe(true);
  });
});

describe('isActiveStateChanges', () => {
  it('returns true for valid changes object', () => {
    const changes: ActiveStateChanges = {
      newLocation: null,
      threatsAdded: [],
      threatsRemoved: [],
      constraintsAdded: [],
      constraintsRemoved: [],
      threadsAdded: [],
      threadsResolved: [],
    };
    expect(isActiveStateChanges(changes)).toBe(true);
  });

  it('returns true when newLocation is string', () => {
    const changes: ActiveStateChanges = {
      newLocation: 'New Place',
      threatsAdded: [],
      threatsRemoved: [],
      constraintsAdded: [],
      constraintsRemoved: [],
      threadsAdded: [],
      threadsResolved: [],
    };
    expect(isActiveStateChanges(changes)).toBe(true);
  });

  it('returns false for missing fields', () => {
    expect(isActiveStateChanges({ newLocation: null })).toBe(false);
  });
});
```

### Invariants That Must Remain True

1. **Immutability**: All properties are `readonly`
2. **Type Safety**: No `any` types in interfaces
3. **Backward Compatibility**: No modifications to existing types
4. **Consistent Naming**: Field names match spec exactly
5. **Location Semantics**: `newLocation: null` means "unchanged", `newLocation: ''` means "explicitly empty"

---

## Definition of Done

- [x] `src/models/state/active-state.ts` created with all types
- [x] `src/models/state/index.ts` exports new module
- [x] `src/models/index.ts` re-exports ActiveState symbols
- [x] Active-state tests added to `test/unit/models/state.test.ts`
- [x] All unit tests pass
- [x] `npm run typecheck` passes
- [x] `npm run lint` passes

---

## Outcome

- **Completed**: 2026-02-08
- **What changed**:
  - Added `ActiveState` and `ActiveStateChanges` definitions in `src/models/state/active-state.ts`, including `createEmptyActiveState`, `createEmptyActiveStateChanges`, `isActiveState`, and `isActiveStateChanges`.
  - Exported active-state symbols from `src/models/state/index.ts` and re-exported them from `src/models/index.ts`.
  - Added active-state factory and type-guard tests to `test/unit/models/state.test.ts`.
- **Deviation from original plan**:
  - Tests were added to existing `test/unit/models/state.test.ts` instead of creating `test/unit/models/state/active-state-types.test.ts`, matching the current repository test layout.
  - Added one extra guard-focused test for a non-string removal entry to cover a likely malformed LLM payload edge case.
- **Verification**:
  - `npm run test:unit -- --testPathPattern=test/unit/models/state.test.ts`
  - `npm run typecheck`
  - `npm run lint`
