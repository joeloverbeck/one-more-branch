/**
 * One More Branch - Client-side JavaScript
 * Generated by scripts/concat-client-js.js — do not edit directly.
 */

(function() {
  'use strict';

// ── Configuration ──────────────────────────────────────────────────

const API_KEY_STORAGE_KEY = 'omb_api_key';
const PROGRESS_POLL_INTERVAL_MS = 1200;
const PHRASE_ROTATION_MIN_MS = 3500;
const PHRASE_ROTATION_MAX_MS = 4500;
const OPEN_THREADS_PANEL_LIMIT = 6;
const KEYED_ENTRY_PANEL_LIMIT = 6;
const LEFT_PANEL_LIMIT = 10;

const STAGE_PHRASE_POOLS = {
  GENERATING_CONCEPTS: [
    'Gathering raw sparks from the edge of imagination...',
    'Mixing genre pressure with emotional voltage...',
    'Sketching concept engines instead of plot summaries...',
    'Trying three strange ideas and one responsible one...',
    'Distilling themes into playable tension...',
    'Stressing each premise for decision-making potential...',
    'Checking if this hook creates immediate curiosity...',
    'Refining role, flaw, and pressure into a clean loop...',
    'Turning vibes into usable dramatic machinery...',
    'Interviewing chaos for better concept candidates...',
    'Searching for concepts that branch without collapsing...',
    'Balancing novelty against clarity and control...',
    'Locating the sharpest contradiction in the premise...',
    'Converting fragments into load-bearing narrative cores...',
    'Drafting hooks that survive first contact with play...',
    'Separating atmospheric ideas from playable ideas...',
    'Pairing constraints with consequences that actually bite...',
    'Tuning each concept for agency and conflict density...',
    'Assembling foundations sturdy enough for branching stories...',
    'Selecting concepts that create pressure, not just lore...',
  ],
  EVALUATING_CONCEPTS: [
    'Scoring concept hooks for clarity and pull...',
    'Measuring conflict engines against repeatable pressure...',
    'Checking agency breadth across strategy space...',
    'Auditing novelty for usefulness, not noise...',
    'Estimating branching fitness under real play...',
    'Reviewing feasibility against LLM drift risk...',
    'Comparing tradeoffs instead of chasing perfection...',
    'Ranking candidates by long-term narrative leverage...',
    'Testing whether the constraints actually constrain...',
    'Verifying the premise survives player unpredictability...',
    'Checking if the protagonist role drives meaningful decisions...',
    'Inspecting deadlines for real urgency...',
    'Cross-checking stakes against systems-level consequences...',
    'Filtering out concepts that look good but play flat...',
    'Selecting high-upside concepts with manageable complexity...',
    'Penalizing brittle premises before they break production...',
    'Scoring world kernels for enforceability...',
    'Calibrating the shortlist for creative durability...',
    'Comparing concept spread for strategic diversity...',
    'Finalizing ranked concepts for user selection...',
  ],
  STRESS_TESTING_CONCEPT: [
    'Pushing the concept through adversarial player behavior...',
    'Probing weak seams in the dramatic engine...',
    'Looking for exploitable loopholes in constraints...',
    'Testing if pressure loops still hold under edge cases...',
    'Hardening vague rules into enforceable boundaries...',
    'Simulating worst-case branching paths...',
    'Checking whether urgency survives detours...',
    'Breaking assumptions before players do it first...',
    'Reinforcing world axioms against narrative drift...',
    'Tracing how this premise fails at scale...',
    'Converting soft spots into explicit guardrails...',
    'Running sabotage drills on core conflict loops...',
    'Examining tradeoffs under sustained player pressure...',
    'Stress-testing stakes for durability over long runs...',
    'Tightening weak constraints with actionable language...',
    'Rebuilding brittle edges for production safety...',
    'Evaluating failure modes across divergent branches...',
    'Locking in mitigations for the highest-risk gaps...',
    'Hardening concept structure for noisy real play...',
    'Completing adversarial pass before final handoff...',
  ],
  GENERATING_SPINE: [
    'Searching for the beating heart of the story...',
    'Asking the hard question nobody wants answered...',
    'Discovering what the protagonist really needs...',
    'Weighing impossible choices against each other...',
    'Finding the lie the hero believes...',
    'Unearthing the buried dramatic question...',
    'Consulting the oracle of narrative structure...',
    'Measuring the gap between want and need...',
    'Summoning the antagonistic forces of destiny...',
    'Sketching the skeleton of dramatic truth...',
    'Interrogating the protagonist\'s deepest fears...',
    'Calibrating the moral compass of the universe...',
    'Testing which pressures crack and which temper...',
    'Exploring the space between desire and necessity...',
    'Drafting the contract between hero and fate...',
    'Surveying the battlefield of inner conflict...',
    'Tracing the fault lines of character and world...',
    'Mapping the territory of impossible promises...',
    'Auditing the protagonist\'s emotional debts...',
    'Weighing the cost of every possible truth...',
    'Consulting the universe about its preferred antagonist...',
    'Asking the protagonist what they would never admit...',
    'Calculating the exact tensile strength of a moral dilemma...',
    'Interviewing the darkness about its motivations...',
    'Folding the map of desire into an origami crane of need...',
    'Whispering the central question into a well and listening...',
    'Measuring the distance between who they are and who they must become...',
    'Shaking the snow globe of dramatic tension...',
    'Planting seeds of conflict in the garden of inevitability...',
    'Tuning the frequency of existential dread...',
    'Asking fate if it takes constructive criticism...',
    'Polishing the mirror the hero refuses to look into...',
    'Weighing the protagonist\'s soul on a very small scale...',
    'Consulting ancient scrolls about narrative pressure points...',
    'Threading the needle between tragedy and transformation...',
    'Checking if the antagonistic force has a valid permit...',
    'Distilling the essence of inner turmoil into a thimble...',
    'Negotiating terms between free will and dramatic necessity...',
    'Cataloguing the things the hero will lose on purpose...',
    'Winding the clock of inevitable confrontation...',
    'Asking the void what kind of story it wants to tell...',
    'Placing the fulcrum beneath the lever of change...',
    'Eavesdropping on the argument between want and need...',
    'Filing the antagonist\'s application for dramatic relevance...',
    'Composing the thesis statement of suffering...',
    'Locating the precise moment everything could go wrong...',
    'Balancing the equation of sacrifice and revelation...',
    'Interviewing pressure mechanisms for the position of catalyst...',
    'Measuring how much truth one story can hold...',
    'Convincing the protagonist\'s flaw to hold still for a portrait...',
    'Drafting a restraining order between the hero and happiness...',
    'Surveying the architecture of a beautiful lie...',
    'Auditing the structural integrity of denial...',
    'Asking the dramatic question to please speak up...',
    'Loading the dice of consequence...',
    'Calibrating the barometer of impending reckoning...',
    'Cross-referencing desire with the encyclopedia of regret...',
    'Tightening the screws on the protagonist\'s comfortable life...',
    'Brewing the tea of uncomfortable self-awareness...',
    'Charting the orbit of an unavoidable collision...',
    'Consulting the ledger of debts the hero doesn\'t know they owe...',
    'Locating the hairline fracture in the hero\'s worldview...',
    'Setting the thermostat of dramatic irony...',
    'Enrolling the antagonist in a masterclass on persistence...',
    'Bottling the specific flavor of this story\'s suffering...',
    'Sketching blueprints for the prison of the hero\'s own making...',
    'Priming the pump of existential revelation...',
    'Determining the load-bearing walls of the protagonist\'s psyche...',
    'Feeding coins into the machine of narrative consequence...',
    'Measuring the half-life of a comfortable illusion...',
    'Querying the database of things heroes refuse to see...',
    'Fitting the key of truth into the lock of avoidance...',
    'Adjusting the gravitational pull of the central conflict...',
    'Selecting the exact poison for this particular antidote...',
    'Reverse-engineering the hero\'s worst possible Tuesday...',
    'Scheduling the appointment the protagonist keeps cancelling...',
    'Assembling the jury of circumstances beyond anyone\'s control...',
    'Tuning the strings of a very dramatic cello...',
    'Placing the mirror at the angle the hero least expects...',
    'Reviewing the antagonist\'s curriculum vitae of inevitability...',
    'Computing the trajectory of an unstoppable realization...',
    'Drafting the blueprint of a transformation nobody asked for...',
    'Sampling the acoustics of an approaching moral crisis...',
    'Indexing the protagonist\'s collection of convenient excuses...',
    'Polishing the lens through which everything looks different...',
    'Warming up the engine of irrevocable choice...',
    'Asking the story what hill it\'s willing to die on...',
    'Mapping the minefield between self-image and reality...',
    'Dialing the exact frequency of dramatic resonance...',
    'Reviewing the fine print on the contract with destiny...',
    'Inventorying the things that cannot stay the same...',
    'Calculating the terminal velocity of a falling belief system...',
    'Soliciting bids from competing sources of pressure...',
    'Forging the chain that links choice to consequence...',
    'Excavating the fossil record of the hero\'s original wound...',
    'Consulting the weather forecast for approaching storms of change...',
    'Appraising the market value of a shattered assumption...',
    'Setting the fuse length on a slow-burning revelation...',
    'Asking the cosmos to define its terms...',
    'Calibrating the exact amount of pressure that produces diamonds...',
  ],
  PLANNING_PAGE: [
    'Consulting the crystal flowchart...',
    'Drawing arrows between dramatic possibilities...',
    'Balancing destiny on a clipboard...',
    'Whispering to the page planner gremlins...',
    'Calling a meeting of the tiny committee in the wall...',
    'Spinning the wheel of plausible chaos...',
    'Asking the couch cushions for strategic advice...',
    'Filing a permit for emotional turbulence...',
    'Color-coding fate with suspicious confidence...',
    'Unfolding the emergency roadmap of maybes...',
    'Negotiating with the timeline using snacks...',
    'Pinning red string to absolutely everything...',
    'Rolling percentile dice for narrative nonsense...',
    'Drafting plans in invisible ink and optimism...',
    'Testing three plans and a backup plan for the backup...',
    'Summoning a brainstorming thundercloud...',
    'Aligning plot magnets to true north drama...',
    'Cross-referencing vibes with hard evidence...',
    'Sharpening pencils to a tactical point...',
    'Budgeting exactly seven units of suspense...',
    'Interviewing three raccoons about long-term strategy...',
    'Mapping alternate futures on a napkin atlas...',
    'Counting plot beats with abacus-level confidence...',
    'Assembling a task force of overqualified pigeons...',
    'Translating chaos into bullet points and coffee rings...',
    'Scheduling destiny in 15-minute calendar blocks...',
    'Running a tabletop exercise for worst-case melodrama...',
    'Tuning the risk radar to "politely catastrophic"...',
    'Checking if the backup prophecy has a backup...',
    'Building a tiny model of the plot out of cereal...',
    'Holding auditions for the next big complication...',
    'Labeling each possibility with a caution sticker...',
    'Comparing timelines for structural squeaks...',
    'Drafting contingency plans on the back of moonlight...',
    'Assigning cliffhangers to their proper jurisdictions...',
    'Sending reconnaissance balloons into chapter two...',
    'Running cost estimates on emotional collateral...',
    'Verifying assumptions with a dramatic checklist...',
    'Plotting escape routes from predictable outcomes...',
    'Stress-testing Plan A against the laws of irony...',
    'Calculating odds with a haunted spreadsheet...',
    'Summoning a consultant possum for tactical input...',
    'Folding contingency plans into paper airplanes...',
    'Checking whether destiny signed the waiver...',
    'Setting up cones around high-risk plot zones...',
    'Feeding strategy grapes to the idea committee...',
    'Using divining rods to locate hidden opportunities...',
    'Building a decision tree out of toothpicks...',
    'Forecasting drama with a barometer and vibes...',
    'Asking the office fern to rank our options...',
    'Air-dropping priorities into a sandbox of chaos...',
    'Measuring uncertainty in teaspoons and sighs...',
    'Consulting the emergency binder labeled "yikes"...',
    'Running a war game with tiny cardboard villains...',
    'Assigning probability hats to every wild guess...',
    'Negotiating timeline treaties at the snack table...',
    'Drafting scenario maps with glitter pens only...',
    'Shuffling strategic options like tarot cards...',
    'Placing caution tape around suspiciously easy plans...',
    'Checking if fate left comments on the whiteboard...',
    'Teaching a rubber duck to run the strategy meeting...',
    'Drafting a five-year plan in crayon and regret...',
    'Recalculating destiny after it failed a unit test...',
    'Arguing with the probability gremlin about rounding...',
    'Asking the magic 8-ball for actionable deliverables...',
    'Pretending the Gantt chart can feel shame...',
    'Herding stray plot ideas back into their pens...',
    'Replacing bold assumptions with slightly braver ones...',
    'Installing guardrails on a plan made of vibes...',
    'Checking the emergency exit route from Act Two...',
    'Bribing the risk assessment with a cinnamon roll...',
    'Running the "what if everything goes wrong" rehearsal...',
    'Pinning "do not trust this plan" on the plan...',
    'Assembling a strategy out of spare dramatic parts...',
    'Drafting the agenda, then losing it to a breeze...',
    'Testing our plan against a mischievous universe...',
    'Negotiating with inevitability for a smaller bite...',
    'Making a pros-and-cons list and eating the paper...',
    'Ordering chaos to please stay within business hours...',
    'Scheduling surprise revelations with suspicious precision...',
    'Poking the plot to see where it squeaks...',
    'Translating panic into a calm-looking flowchart...',
    'Selecting a route that avoids obvious foreshadowing...',
    'Practicing confident nods over a terrible idea...',
    'Calibrating optimism to "probably survivable"...',
    'Spinning the decision compass until it stops screaming...',
    'Checking if the plot has any allergies to logic...',
    'Issuing hard hats to all future consequences...',
    'Drafting a plan, then adding a plan for the plan...',
    'Consulting the backup backup backup plan\'s manager...',
    'Creating a "no melodrama" policy and ignoring it...',
    'Measuring ambition in centimeters and hubris...',
    'Folding the strategy into a paper swan of doom...',
    'Asking a suspicious crow to forecast outcomes...',
    'Running long-term projections on short-term chaos...',
    'Asking the strategy hamster to spin the planning wheel...',
    'Laminating the chaos into a respectable-looking agenda...',
    'Assigning blame preemptively to future complications...',
    'Checking whether this plan needs a plan of its own...',
    'Distributing worry tokens across all possible outcomes...',
  ],
  ACCOUNTING_STATE: [
    'Opening the ledger of consequences...',
    'Filing state changes in triplicate...',
    'Auditing active threats against current reality...',
    'Reconciling inventory with narrative receipts...',
    'Balancing the books of cause and effect...',
    'Stamping forms with the seal of inevitability...',
    'Checking thread IDs against the registry...',
    'Reviewing constraints for compliance...',
    'Verifying canon entries with the records office...',
    'Processing character-state updates through HR...',
    'Issuing a formal notice of escalation...',
    'Logging health updates in the permanent file...',
    'Cross-referencing urgency with actual danger...',
    'Reviewing removals for proper justification...',
    'Archiving resolved loops in the closed-cases drawer...',
    'Stamping this transition APPROVED...',
    'Running the final consistency audit...',
    'Reconciling ambition with available resources...',
    'Validating IDs with stern bureaucratic focus...',
    'Closing the books on this scene...',
    'Assigning serial numbers to existential threats...',
    'Notarizing the protagonist\'s emotional damages...',
    'Filing a change-of-address form for the current location...',
    'Requesting three forms of ID from new inventory items...',
    'Placing a hold on contradictory canon facts...',
    'Sending duplicate threads to the shredder...',
    'Applying corrective ink to the state ledger...',
    'Forwarding character grievances to the appeals department...',
    'Rubber-stamping health deductions with a heavy sigh...',
    'Alphabetizing the chaos into neat little folders...',
    'Flagging unresolved mysteries for follow-up review...',
    'Issuing parking permits for newly spawned NPCs...',
    'Recalculating danger levels after adjusting for inflation...',
    'Submitting constraint waivers to upper management...',
    'Microfilming the protagonist\'s questionable decisions...',
    'Dispatching a courier to verify location continuity...',
    'Stapling addendum C to the threat assessment report...',
    'Consulting the index of acceptable plot contradictions...',
    'Running a background check on incoming state mutations...',
    'Collating removal requests in order of dramatic importance...',
    'Penciling in doom on the official calendar...',
    'Applying late fees to overdue narrative threads...',
    'Requesting supervisor approval for emotional intensity levels...',
    'Double-checking the math on accumulated consequences...',
    'Laminating the updated threat registry...',
    'Routing inventory changes through the supply chain...',
    'Sending a sternly worded memo to unresolved plot holes...',
    'Hole-punching the latest canon amendments for binder storage...',
    'Cross-filing character motivations under multiple categories...',
    'Redacting spoilers from the official state record...',
    'Affixing a RECEIVED stamp to each new world fact...',
    'Placing thread urgency ratings under peer review...',
    'Itemizing narrative debts on the balance sheet...',
    'Issuing tax forms to characters with new inventory...',
    'Circulating the updated org chart of active threats...',
    'Tabulating protagonist injuries against the deductible...',
    'Verifying that all removals have a proper death certificate...',
    'Convening the board to review thread deduplication results...',
    'Highlighting discrepancies with a disapproving yellow marker...',
    'Placing a lien on abandoned story threads...',
    'Scheduling a compliance review for next quarter\'s canon...',
    'Generating a receipt for each surrendered constraint...',
    'Updating the master spreadsheet of fictional consequences...',
    'Checking if the protagonist filed their emotional taxes...',
    'Sorting new entries into the URGENT and VERY URGENT bins...',
    'Enrolling freshly minted threats in the tracking system...',
    'Archiving spent plot devices in the warehouse...',
    'Confirming that all state changes have been initialed...',
    'Clipping together related forms with a bureaucratic flourish...',
    'Drafting a formal objection to impossible inventory claims...',
    'Calculating depreciation on aging story threads...',
    'Issuing badge numbers to newly registered canon facts...',
    'Feeding contradictions into the reconciliation machine...',
    'Pulling the protagonist\'s permanent record from the cabinet...',
    'Escorting unauthorized state mutations off the premises...',
    'Certifying character emotions as within acceptable parameters...',
    'Requisitioning additional filing cabinets for this timeline...',
    'Performing a spot audit on the threat containment ledger...',
    'Stamping DENIED on implausible health regeneration claims...',
    'Indexing newly discovered world facts by relevance and absurdity...',
    'Transferring resolved constraints to the inactive roster...',
    'Compiling the quarterly report on narrative entropy...',
    'Assigning case numbers to freshly opened mysteries...',
    'Verifying chain of custody for transferred inventory items...',
    'Reviewing the protagonist\'s expense report for this scene...',
    'Escalating unresolved contradictions to the ombudsman...',
    'Logging all emotional damages in the incident report...',
    'Confirming that new threads have filled out their intake forms...',
    'Tallying moral compromises on the running total...',
    'Distributing updated procedural memos to all active NPCs...',
    'Placing narrative inconsistencies on administrative probation...',
    'Faxing the updated state snapshot to the records annex...',
    'Decommissioning expired threats with full paperwork...',
    'Running a compliance check on the protagonist\'s life choices...',
    'Filing an environmental impact statement for location changes...',
    'Adjusting the risk assessment after that last decision...',
    'Putting the finishing touches on form 27-B stroke six...',
    'Registering new canon facts with the hall of records...',
    'Billing the protagonist for accumulated narrative overhead...',
    'Sealing the amended ledger with a wax stamp of finality...',
  ],
  CURATING_CONTEXT: [
    'Consulting the ancient tomes...',
    'Cross-referencing character grudges...',
    'Alphabetizing plot threads by urgency...',
    'Dusting off the relevant lore scrolls...',
    'Cataloging who knows what and why...',
    'Filing canon facts by scene relevance...',
    'Sifting through backstory for gold...',
    'Indexing every grudge, oath, and rumor...',
    'Sorting character baggage by weight...',
    'Highlighting the bits that actually matter...',
    'Trimming the lore hedge into shape...',
    'Cross-checking alibis with established canon...',
    'Retrieving the right dossiers from the vault...',
    'Marking worldbuilding passages for inclusion...',
    'Shelving irrelevant details with a polite nod...',
    'Assembling the scene-specific cheat sheet...',
    'Pulling character files from the archive...',
    'Condensing three volumes into one sticky note...',
    'Verifying which NPCs are in the room...',
    'Building a relationship map out of red string...',
    'Checking speech patterns against dialogue records...',
    'Curating only the juiciest canon facts...',
    'Reviewing who said what to whom and when...',
    'Extracting verbal tics from prior conversations...',
    'Filtering worldbuilding through the scene lens...',
    'Packaging emotional baggage for scene delivery...',
    'Compiling a dossier of relevant tensions...',
    'Tagging characters by scene importance...',
    'Archiving the stuff nobody needs right now...',
    'Preparing the scene-focused briefing packet...',
    'Auditing character relationships for freshness...',
    'Sorting history into chronological cause-and-effect...',
    'Stamping canon facts with relevance ratings...',
    'Rolling up lore into a portable scroll...',
    'Pruning the context garden of decorative weeds...',
    'Assembling the cast list for this scene...',
    'Verifying continuity seals are unbroken...',
    'Checking which promises are due this chapter...',
    'Building the scene bible with archival precision...',
    'Extracting only the load-bearing lore...',
    'Selecting the right emotional ammunition...',
    'Summarizing three acts of history in two paragraphs...',
    'Folding context into an origami cheat sheet...',
    'Organizing character dynamics by voltage level...',
    'Labeling each fact by expiration scene...',
    'Pulling relevant memories from the narrative vault...',
    'Scanning the timeline for causality chains...',
    'Compressing epic backstory into scene-sized packets...',
    'Cross-referencing motives with opportunity...',
    'Sorting the important from the merely interesting...',
    'Weighing each detail on the relevance scale...',
    'Assembling a greatest-hits of narrative context...',
    'Checking which character arcs are load-bearing...',
    'Preparing a briefcase of curated consequences...',
    'Filing emotional receipts by character name...',
    'Distilling worldbuilding into scene-grade concentrate...',
    'Reviewing the interpersonal tension inventory...',
    'Selecting speech samples for voice consistency...',
    'Packaging the past into a useful present...',
    'Shaking lore crumbs out of the narrative sofa...',
    'Politely escorting irrelevant trivia into the void...',
    'Asking the canon to please stop moving when observed...',
    'Vacuuming up stray backstory glitter...',
    'Holding a tiny trial for disputed continuity facts...',
    'Labeling every rumor with "handle with care"...',
    'Making a neat pile of truths and a bigger pile of lies...',
    'Checking receipts for who promised what, exactly...',
    'Summoning the archivist spirit and offering snacks...',
    'Stitching together timelines that refuse to align...',
    'Extracting character voice samples like rare spices...',
    'Sorting grudges into "fresh", "fermented", and "apocalyptic"...',
    'Taping sticky notes onto the universe for later...',
    'Assembling a lore smoothie (no chunks, please)...',
    'Cross-referencing dramatic irony with actual knowledge...',
    'Confirming which NPCs exist in this reality...',
    'Auditing the backstory for unauthorized drama...',
    'Translating ancient lore into modern panic...',
    'Highlighting the one detail that will ruin everything...',
    'Putting context in a lunchbox for the scene...',
    'Checking the world bible for hidden footnotes...',
    'Digitizing a memory by squinting at it intensely...',
    'Sorting secrets by "should explode soon"...',
    'Dusting off the relationship web and sneezing...',
    'Reducing ten chapters of history to one meaningful glare...',
    'Asking the lore librarian where the "good stuff" is...',
    'Re-stacking canon until it stops wobbling...',
    'Filing emotional baggage under "carry-on only"...',
    'Finding the one fact everyone will misinterpret...',
    'Making sure the lore doesn\'t outshine the scene...',
    'Compressing exposition until it becomes a gemstone...',
    'Checking continuity with a tiny flashlight and dread...',
    'Scanning the past for unpaid consequences...',
    'Wrapping key facts in bubble wrap and tension...',
    'Marking irrelevant lore as "decorative but illegal here"...',
    'Alphabetizing trauma by character and chronology...',
    'Issuing security clearances to relevant backstory...',
    'Quarantining spoilers that arrived too early...',
    'Defogging the lens of narrative relevance...',
    'Escorting VIP facts to the front of the briefing...',
    'Shelving entire centuries to focus on this one moment...',
  ],
  WRITING_OPENING_PAGE: [
    'Rolling out the opening scene carpet...',
    'Polishing first impressions with glitter...',
    'Cueing the cinematic entrance music...',
    'Placing the camera at maximum drama angle...',
    'Turning on the fog machine for ambience...',
    'Teaching the narrator to make eye contact...',
    'Warming up the dialogue with tongue twisters...',
    'Deploying tasteful thunder in the distance...',
    'Adjusting the spotlight to "mysterious but friendly"...',
    'Setting out fresh metaphors in a neat row...',
    'Tuning the opening line to perfect pitch...',
    'Adding one dramatic pause for seasoning...',
    'Sweeping confetti off the exposition runway...',
    'Calibrating the first sentence launch sequence...',
    'Installing mood lighting in paragraph one...',
    'Bribing the hook to land cleanly...',
    'Giving the protagonist a very determined eyebrow...',
    'Pressing record on the cinematic narrator voice...',
    'Rehearsing the first reveal with jazz hands...',
    'Opening the curtain on controlled narrative chaos...',
    'Unboxing the very first sentence with white gloves...',
    'Loading the intro cannon with premium intrigue...',
    'Hanging a neon sign that says "pay attention"...',
    'Deploying a carefully trained opening gasp...',
    'Teaching paragraph one how to strut confidently...',
    'Spritzing the scene with fresh-pressed atmosphere...',
    'Dialing the narrative camera to impossible close-up...',
    'Placing a breadcrumb trail of irresistible questions...',
    'Testing the hook on a focus group of daydreamers...',
    'Repainting the sky in chapter-one colors...',
    'Priming the conflict engine for immediate ignition...',
    'Adding velvet ropes around the first big reveal...',
    'Handing the narrator a megaphone and a secret...',
    'Sculpting the opening beat with dramatic chisels...',
    'Letting the first line do one theatrical bow...',
    'Tightening the intro knots with narrative pliers...',
    'Positioning the stakes where everyone can trip on them...',
    'Charging the prologue batteries to 100 percent...',
    'Inviting curiosity to kick down the front door...',
    'Setting the tone dial to "you are now invested"...',
    'Sending the opening shot through a glamour filter...',
    'Preheating the first page to cinematic temperature...',
    'Waxing the runway for a dramatic character entrance...',
    'Packing the intro with legally approved goosebumps...',
    'Cueing a choir of suspiciously relevant violins...',
    'Teaching the first paragraph to wink at the reader...',
    'Unleashing a tiny stampede of immediate questions...',
    'Giving the hook a cape and excellent timing...',
    'Rolling out red carpet for the inciting incident...',
    'Polishing the premise until it catches moonlight...',
    'Adjusting atmosphere levels to "electric storm"...',
    'Planting one breadcrumb and seven complications...',
    'Sneaking tension into the room through the vents...',
    'Ironing the opening beats until they snap...',
    'Installing fireworks behind the first reveal...',
    'Teaching chapter one to kick the door in politely...',
    'Loading the scene with premium-grade anticipation...',
    'Strapping a rocket booster to the first conflict...',
    'Rehearsing the cold open with dramatic fanfare...',
    'Spiking the intro punch bowl with intrigue...',
    'Rolling the first line down the runway like it owns the place...',
    'Handing the narrator a martini and a secret...',
    'Planting an inciting incident in a tasteful flowerpot...',
    'Turning the "mood" knob until it clicks ominously...',
    'Teaching the opening paragraph to flirt with danger...',
    'Launching the hook and yelling "stick the landing!"...',
    'Inflating atmosphere with a bicycle pump of suspense...',
    'Giving the setting a dramatic entrance and a name tag...',
    'Slipping a mystery under the door like a coupon...',
    'Arranging the first beat like a fancy charcuterie board...',
    'Warming up the tension with a gentle hiss...',
    'Introducing the protagonist with OSHA-certified charisma...',
    'Adding a cinematic zoom to a completely normal object...',
    'Letting chapter one kick a chair and apologize later...',
    'Sprinkling curiosity dust on everything not nailed down...',
    'Loading the opening with premium-grade "uh oh"...',
    'Teaching the first scene to smile with sharp teeth...',
    'Staging an accidental prophecy for ambiance...',
    'Polishing the opening image until it reflects anxiety...',
    'Installing a tiny siren behind the subtext...',
    'Serving the premise on a silver platter of problems...',
    'Tucking a loaded detail into a casual sentence...',
    'Giving the hook a whistle and a criminal record...',
    'Arranging coincidences so they look innocent...',
    'Starting with calm, then gently setting it on fire...',
    'Bringing in the conflict like it\'s late for work...',
    'Dropping a question mark from the ceiling dramatically...',
    'Teaching the opening to whisper "keep reading"...',
    'Rolling out the vibe carpet and tripping on it...',
    'Packing the first page with legally binding intrigue...',
    'Spicing the intro with a pinch of impending doom...',
    'Setting the scene like a candle, then blowing it out...',
    'Giving the narrator a wink and plausible deniability...',
    'Threading a promise through the first three sentences...',
    'Summoning the hook with interpretive dance and fog...',
    'Coating the first sentence in fresh dramatic lacquer...',
    'Hiring a skywriter to spell out the inciting incident...',
    'Mic-checking the narrator for volume and gravitas...',
    'Fastening the seatbelt sign for narrative turbulence...',
    'Queuing the dramatic sting for paragraph two...',
  ],
  WRITING_CONTINUING_PAGE: [
    'Stitching consequences into the timeline...',
    'Keeping the plot train barely on the rails...',
    'Handing the scene to the next narrator...',
    'Adding one more suspiciously perfect twist...',
    'Refueling the momentum engine with cliffhangers...',
    'Untangling side quests from the chandelier...',
    'Passing notes between cause and effect...',
    'Patching continuity leaks with narrative gum...',
    'Setting the stakes to "gently terrifying"...',
    'Rotating the mystery box for better suspense...',
    'Escorting loose ends toward responsible adulthood...',
    'Threading foreshadowing through a tiny needle...',
    'Bolting the midpoint together with dramatic screws...',
    'Checking the subplot humidity levels...',
    'Giving consequences room to breathe ominously...',
    'Synchronizing character arcs with the moon phase...',
    'Reheating tension until pleasantly unstable...',
    'Guiding the pacing with a traffic baton...',
    'Sliding the dominoes into place with tweezers...',
    'Issuing plot passports for cross-scene travel...',
    'Escorting momentum past the valley of distractions...',
    'Tightening cause-and-effect with a torque wrench...',
    'Stacking fresh dilemmas like unstable pancakes...',
    'Refilling the tension reservoir one drop at a time...',
    'Sending character decisions through quality control...',
    'Keeping the subplot orchestra in the same tempo...',
    'Shoveling narrative coal into the third-act furnace...',
    'Documenting every consequence for legal reasons...',
    'Steering this chapter through emotional weather...',
    'Balancing revelations on a very narrow shelf...',
    'Adding controlled sparks to the conflict wiring...',
    'Rotating viewpoints to prevent dramatic traffic jams...',
    'Escalating stakes with OSHA-compliant urgency...',
    'Fastening the next beat with industrial foreshadowing...',
    'Checking dialogue pressure before the next release...',
    'Threading payoffs through active construction zones...',
    'Keeping the emotional RPMs in the red...',
    'Redirecting loose chaos into productive chaos...',
    'Feeding the suspense creature on a strict schedule...',
    'Escorting every choice toward glorious consequences...',
    'Passing the scene baton without dropping any secrets...',
    'Inflating the conflict balloon to optimal squeak...',
    'Splicing fresh momentum into the narrative bloodstream...',
    'Escorting revelations through a crowded hallway...',
    'Tightening suspense screws until they hum...',
    'Giving the stakes a double shot of espresso...',
    'Laying banana peels in front of bad decisions...',
    'Sweeping emotional shrapnel into future chapters...',
    'Keeping the tension kite aloft in crosswinds...',
    'Threading character growth through laser grids...',
    'Adding speed bumps before every easy answer...',
    'Scheduling consequences for prime-time impact...',
    'Greasing the plot gears with dramatic irony...',
    'Rolling the next complication down a marble track...',
    'Letting the subtext simmer on low chaos...',
    'Installing handrails on this slippery escalation...',
    'Routing every shortcut straight into trouble...',
    'Pressurizing the next beat for maximum pop...',
    'Funneling uncertainty into a very loud maybe...',
    'Keeping this chapter one decision away from disaster...',
    'Chasing continuity gremlins with a rolled-up newspaper...',
    'Topping up tension like it\'s windshield wiper fluid...',
    'Letting consequences jog in, out of breath...',
    'Turning a small choice into a large problem...',
    'Rehearsing a payoff, then hiding it behind a curtain...',
    'Taping foreshadowing under the table like chewing gum...',
    'Keeping the pacing from eating the furniture...',
    'Adding a complication because the plot looked comfortable...',
    'Massaging the timeline until it stops making that noise...',
    'Redirecting a subplot that wandered into traffic...',
    'Escorting loose ends toward responsible closure...',
    'Handing the characters a situation and watching it explode...',
    'Folding tension into the dialogue like secret origami...',
    'Installing a new dilemma where the hallway used to be...',
    'Turning up the stakes and snapping the knob off...',
    'Refilling suspense from the big jug labeled "don\'t ask"...',
    'Sliding cause-and-effect into place with jazz hands...',
    'Pulling a thread and pretending it was always there...',
    'Keeping the plot upright with emotional scaffolding...',
    'Giving the protagonist a new reason to regret breathing...',
    'Sprinkling subtext like parmesan over the scene...',
    'Shuffling revelations until one bites us...',
    'Letting the quiet moment load a slingshot...',
    'Adding a pause so heavy it needs its own chair...',
    'Dragging the story forward by its confident little ankles...',
    'Handing the scene a banana peel of irony...',
    'Replacing "maybe" with "oh no" in the margins...',
    'Tightening the screws on a perfectly good situation...',
    'Teaching the next beat to arrive with a smirk...',
    'Flipping the hourglass and watching everyone panic...',
    'Stacking problems neatly so they fall better later...',
    'Making the consequences sign in at the front desk...',
    'Laying down foreshadowing like suspicious breadcrumbs...',
    'Installing a cliffhanger with childproof locks...',
    'Steering the chapter through emotional potholes...',
    'Oiling the hinges on the next pivotal door...',
    'Winding the tension spring one more careful click...',
    'Polishing the dominoes before tipping the first one...',
    'Adjusting the emotional thermostat to "simmering"...',
    'Loading the next surprise into the narrative chamber...',
  ],
  ANALYZING_SCENE: [
    'Checking the scene for narrative wobble...',
    'Comparing outcomes with the prophecy chart...',
    'Scanning for hidden cause-and-effect crumbs...',
    'Measuring tension levels with a tiny ruler...',
    'Dusting the clues for emotional fingerprints...',
    'Listening for suspiciously meaningful silence...',
    'Highlighting motifs in five shades of concern...',
    'Interrogating the subtext under bright lights...',
    'Charting who knows what on a corkboard...',
    'Running diagnostics on dramatic timing...',
    'Counting unresolved questions on both hands...',
    'Testing each beat for maximum narrative bounce...',
    'Inspecting dialogue for secret trapdoors...',
    'Triangulating intent, action, and fallout...',
    'Separating facts from very confident guesses...',
    'Scanning the room for Chekhov objects...',
    'Stress-testing the logic with a rubber hammer...',
    'Weighing emotional impact on calibrated scales...',
    'Decoding facial expressions into strategic data...',
    'Marking potential plot potholes with neon flags...',
    'Running forensic tests on suspicious adverbs...',
    'Cross-examining every beat for motive and means...',
    'Measuring subtext depth with sonar equipment...',
    'Cataloging narrative anomalies by timestamp...',
    'Comparing stated goals to actual chaos produced...',
    'Tracing dramatic footprints across the scene floor...',
    'Stress-auditing every reaction for plausibility...',
    'Triaging unresolved tension by urgency level...',
    'Putting each line under a microscope of intent...',
    'Building an evidence board out of eyebrow raises...',
    'Searching for quiet details doing loud work...',
    'Tagging emotional pivots with forensic tape...',
    'Verifying that every reveal earns its oxygen...',
    'Checking continuity seams for daylight leaks...',
    'Profiling conflict patterns for repeat offenders...',
    'Testing interpretation theories in a wind tunnel...',
    'Flagging dialogue that knows too much too soon...',
    'Auditing who changed, why, and at what cost...',
    'Reconstructing the scene from consequence fragments...',
    'Checking whether the silence says more than the speech...',
    'Running motive prints through the clue database...',
    'Timing each pause with a suspense stopwatch...',
    'Sampling the vibe for trace amounts of foreshadowing...',
    'Inspecting reactions for counterfeit confidence...',
    'Charting emotional weather by line and gesture...',
    'Testing every alibi under a hot desk lamp...',
    'Mapping power shifts with tiny magnetic arrows...',
    'Verifying who blinked first and why...',
    'Sifting dialogue sediment for hidden gold...',
    'Comparing what was said to what was swallowed...',
    'X-raying the scene for concealed turning points...',
    'Measuring dramatic friction with calibrated gloves...',
    'Isolating the exact moment the room changed shape...',
    'Tagging suspicious coincidences for lab review...',
    'Checking whether each choice leaves a footprint...',
    'Triangulating tension from tone, timing, and eye contact...',
    'Profiling every beat for intent-to-impact ratio...',
    'Stress-testing assumptions against inconvenient facts...',
    'Pinning red yarn between questions and consequences...',
    'Auditing the unspoken stuff for maximum significance...',
    'Putting the scene in a vibes MRI...',
    'Running the dialogue through a truth-detector toaster...',
    'Checking subtext levels with a haunted thermometer...',
    'Counting motive fingerprints under a blacklight...',
    'Weighing the silence to see if it\'s hiding snacks...',
    'Testing each beat for structural "oops" noises...',
    'Shaking the scene gently to see what falls out...',
    'Measuring tension like it\'s flour (and we forgot a cup)...',
    'Auditing reactions for suspicious freshness...',
    'Inspecting eyebrow movement for hidden contracts...',
    'Running a background check on that "casual" detail...',
    'Cross-examining the pacing like a stern accountant...',
    'Checking if the stakes are actually doing their job...',
    'Highlighting the moment everything got weird...',
    'Comparing intentions to outcomes with a disappointed sigh...',
    'Tagging emotional pivots with bright orange cones...',
    'Searching for clues disguised as furniture...',
    'Tracking power shifts with tiny angry arrows...',
    'Verifying that the reveal didn\'t teleport in...',
    'Checking for plot holes large enough to rent...',
    'Analyzing the scene\'s aura for trace foreshadowing...',
    'Looking for the exact line that started the fire...',
    'Interrogating coincidence until it confesses...',
    'Mapping who\'s lying, who\'s coping, who\'s thriving...',
    'Examining the tone for unauthorized genre drift...',
    'Testing plausibility by poking it with a stick...',
    'Checking whether the conflict has a pulse...',
    'Noting which detail is going to hurt later...',
    'Running the scene through the “does this land?” trampoline...',
    'Diagnosing emotional whiplash with a tiny clipboard...',
    'Profiling the subtext like it owes us money...',
    'Confirming the stakes aren\'t just decorative...',
    'Counting unresolved questions and losing count...',
    'Scanning the scene for Chekhov\'s suspicious lampshade...',
    'Replaying the moment with slow-motion panic...',
    'Dusting the dialogue for latent dramatic irony...',
    'Cataloguing every nervous glance by timestamp...',
    'Running the tension through a spectrometer of concern...',
    'Interviewing the silence about what it witnessed...',
    'Filing a forensic report on the emotional crime scene...',
  ],
  STRUCTURING_STORY: [
    'Pouring the foundation for a brand-new story...',
    'Surveying the narrative landscape for load-bearing themes...',
    'Mixing dramatic concrete to spec...',
    'Driving stakes into the thematic bedrock...',
    'Unrolling the master blueprint across the table...',
    'Marking where the first act wall goes...',
    'Hammering together the scaffolding of destiny...',
    'Laying rebar through the dramatic spine...',
    'Consulting the structural engineer about tension loads...',
    'Measuring twice, building once (hopefully)...',
    'Excavating the foundation for maximum gravitas...',
    'Installing the central pillar of conflict...',
    'Framing the first-act doorway with ceremonial studs...',
    'Bolting the thematic crossbeams into place...',
    'Pouring fresh footings under the premise...',
    'Raising the ridge beam between setup and payoff...',
    'Running narrative plumbing through the walls...',
    'Wiring the foreshadowing circuits into the framing...',
    'Hanging the plot trusses with calculated precision...',
    'Leveling the story foundation with a laser of intent...',
    'Anchoring character arcs to the structural grid...',
    'Fitting tension joists between act one and act two...',
    'Erecting the scaffolding around a promising premise...',
    'Sketching load paths for maximum emotional impact...',
    'Securing permits for dramatic escalation...',
    'Pouring the slab that all future chaos rests upon...',
    'Setting corner stones at each act boundary...',
    'Welding the inciting incident to the main truss...',
    'Inspecting the blueprint for adequate twist clearance...',
    'Building the framework one dramatic beam at a time...',
    'Planting the structural columns of rising action...',
    'Laying ductwork for the flow of consequences...',
    'Installing load-bearing themes at critical junctions...',
    'Nailing the opening header with confident swings...',
    'Calibrating the arc crane for heavy lifting...',
    'Framing rooms for confrontation, revelation, and regret...',
    'Threading steel cables through the narrative skeleton...',
    'Bracing the midpoint against predictable collapse...',
    'Testing soil density under the emotional foundation...',
    'Raising walls between what was and what will be...',
    'Drafting elevation views of the dramatic landscape...',
    'Scheduling the climax pour for optimal curing...',
    'Installing the damp course against genre seepage...',
    'Fitting the keystone into the thematic archway...',
    'Mapping utility routes for subplot distribution...',
    'Templating window openings for dramatic reveals...',
    'Checking that the blueprint survives its own ambition...',
    'Assembling the crane to lift the central conflict...',
    'Grouting the gaps between intention and execution...',
    'Setting expansion joints for character growth...',
    'Bolting the inciting incident to solid ground...',
    'Constructing the staircase from setup to catastrophe...',
    'Verifying the shear walls can handle plot twists...',
    'Hoisting the narrative ridgepole into final position...',
    'Compacting the subgrade before laying down themes...',
    'Installing fire stops between volatile subplots...',
    'Roughing in the dramatic plumbing before drywall...',
    'Squaring the corners where acts meet...',
    'Ordering the correct gauge of suspense wire...',
    'Backfilling around the freshly poured premise...',
    'Marking elevation benchmarks for rising tension...',
    'Strapping hurricane ties onto the climax frame...',
    'Routing the emotional HVAC through every chapter...',
    'Gluing laminated beams of layered meaning together...',
    'Setting the formwork for a freshly poured conflict...',
    'Troweling the surface of a brand-new dramatic slab...',
    'Plumbing the depths for a solid thematic footing...',
    'Craning the first major reveal into position...',
    'Shimming the structure until the themes sit plumb...',
    'Chalking lines on the subfloor of possibility...',
    'Fastening joist hangers to the backbone of the plot...',
    'Curing the premise under controlled dramatic heat...',
    'Shooting grade with a transit of narrative intent...',
    'Staking out the lot lines of genre and tone...',
    'Vibrating the concrete to remove pockets of cliché...',
    'Tying rebar knots at every critical junction...',
    'Snapping chalk lines between the first scene and the last...',
    'Forming the footings for a multi-act structure...',
    'Torquing the anchor bolts on the story\'s foundation...',
    'Cutting the ribbon on a freshly framed narrative...',
    'Dry-fitting the plot skeleton before final assembly...',
    'Installing temporary bracing until the story cures...',
    'Blueprinting emergency exits from every dead end...',
    'Aligning the laser level with thematic true north...',
    'Backfilling the foundation trench with backstory...',
    'Sealing the vapor barrier against tone leaks...',
    'Placing embed plates for future character attachments...',
    'Inspecting the rebar cage before the big pour...',
    'Setting string lines for perfectly straight story arcs...',
    'Mixing a batch of structural-grade dramatic tension...',
    'Tamping the gravel base of worldbuilding details...',
    'Installing the sill plate on a freshly leveled premise...',
    'Raising the first wall panel with a satisfying thunk...',
    'Certifying the foundation for occupancy by characters...',
    'Breaking ground on a promising new narrative site...',
    'Pressure-testing the climax for structural soundness...',
    'Welding the theme to the load-bearing plot beams...',
    'Running the final walkthrough before narrative occupancy...',
    'Riveting the turning point to the structural frame...',
    'Certifying the arc for dramatic habitation...',
  ],
  RESTRUCTURING_STORY: [
    'Rearranging story beams without waking dragons...',
    'Tightening bolts on the adventure skeleton...',
    'Re-threading plot cables behind the walls...',
    'Deploying emergency structure duct tape...',
    'Moving chapter furniture with narrative dollies...',
    'Replacing squeaky scenes with reinforced tension...',
    'Installing support arcs under weak spots...',
    'Rerouting character traffic to reduce pileups...',
    'Welding the midpoint to the ending frame...',
    'Stacking stakes where they can do the most damage...',
    'Refitting transitions with smoother gears...',
    'Laying fresh track for the final act train...',
    'Demolishing one wobbly beat at a safe distance...',
    'Reinforcing the foundation with consequence cement...',
    'Hoisting the payoff into load-bearing position...',
    'Rebalancing the structure for emotional wind...',
    'Rewiring callbacks to the main power grid...',
    'Swapping in a sturdier sequence of events...',
    'Labeling every moving part "fragile but important"...',
    'Running final inspections with a hard hat...',
    'Relocating major twists to safer load-bearing chapters...',
    'Installing seismic braces for surprise reveals...',
    'Regrading the slope so tension flows downhill...',
    'Replacing narrative scaffolding with permanent supports...',
    'Cutting new doorways between disconnected scenes...',
    'Rebalancing act breaks to avoid dramatic sinkholes...',
    'Retrofitting the climax with reinforced cause-and-effect...',
    'Demoting decorative detours to optional side streets...',
    'Rerouting exposition through cleaner pipelines...',
    'Re-centering the core conflict on solid bedrock...',
    'Lifting sagging subplots with hydraulic jacks...',
    'Refitting the opening so the ending actually fits...',
    'Realigning chapter joints for smoother movement...',
    'Bolstering weak transitions with structural callbacks...',
    'Converting dead-end beats into through-lines...',
    'Consolidating duplicate conflicts into one heavy hitter...',
    'Replacing narrative bloat with precision-engineered stakes...',
    'Moving the emotional keystone back into place...',
    'Repainting the whole arc with clearer contrast...',
    'Running a full structural scan before reopening...',
    'Installing shock absorbers on every major twist...',
    'Redistributing weight away from the saggy middle...',
    'Replacing decorative scenes with load-bearing drama...',
    'Threading steel cables through the act breaks...',
    'Reinforcing weak joints with callback brackets...',
    'Rebuilding the climax staircase to code...',
    'Moving exposition crates off emergency exits...',
    'Swapping brittle beats for tempered story glass...',
    'Pouring fresh concrete under the central conflict...',
    'Converting narrative dead space into useful corridors...',
    'Retensioning the arc so it does not wobble...',
    'Installing pressure valves for high-stakes moments...',
    'Aligning every subplot gear with the master crank...',
    'Reframing chapter walls to fit bigger payoffs...',
    'Replacing mystery drywall with transparent intent...',
    'Upgrading transitions from rope bridge to highway...',
    'Hoisting delayed consequences into plain view...',
    'Routing emotional load through stronger pillars...',
    'Removing decorative scaffolds still pretending to be scenes...',
    'Checking the whole structure for sequel-proof stability...',
    'Dragging Act Two back into the building by the collar...',
    'Installing load-bearing consequences where vibes used to be...',
    'Refactoring the plot like it\'s legacy code from 2009...',
    'Moving scenes around until the story stops hissing...',
    'Welding character arcs into a sturdier triangle...',
    'Replacing a weak beat with a stronger, angrier beat...',
    'Rerouting exposition through a tunnel marked “fun”...',
    'Rebalancing the middle so it stops sagging politely...',
    'Turning a detour into a shortcut with a crowbar...',
    'Swapping two chapters and pretending it was destiny...',
    'Tightening the arc until it makes a satisfying click...',
    'Removing decorative scenes that keep stealing oxygen...',
    'Bolting the climax onto the rest of the story properly...',
    'Upgrading transitions from "teleport" to "walk"...',
    'Cutting a new doorway between two stubborn moments...',
    'Rehousing a twist in a safer, louder neighborhood...',
    'Patching story seams with industrial-grade foreshadowing...',
    'Repositioning the emotional keystone with heavy machinery...',
    'Consolidating three minor problems into one huge problem...',
    'Replacing narrative fluff with concentrated menace...',
    'Rebuilding the payoff staircase so it won\'t collapse...',
    'Installing a support beam under this shaky motivation...',
    'Moving the reveal earlier before it misses the bus...',
    'Re-threading the through-line until it stops unraveling...',
    'Shoving the plot back onto the rails with a forklift...',
    'Demoting a scene to "optional content" with a stern look...',
    'Aligning subplots so they stop arguing in public...',
    'Fixing the pacing with a wrench and hurt feelings...',
    'Sanding down a clunky beat until it sparkles dangerously...',
    'Replacing "and then" with "therefore" in the walls...',
    'Reattaching the beginning to the ending with duct tape...',
    'Giving the story a posture correction and a pep talk...',
    'Pulling the arc taut like a bowstring of doom...',
    'Reinforcing the theme so it can survive impact...',
    'Re-casting a coincidence as a consequence (shhh)...',
    'Hauling debris from the collapsed subplot...',
    'Rewiring the emotional grid after that power surge...',
    'Jacking up the sagging middle with fresh conflict...',
    'Emergency-patching the timeline with narrative spackle...',
    'Issuing a change order for the entire third act...',
  ],
  DECOMPOSING_ENTITIES: [
    'Cataloguing every nervous tic and catchphrase...',
    'Cross-referencing NPC gossip with confirmed facts...',
    'Teaching the quill to mimic everyone\'s handwriting...',
    'Filing worldbuilding lore under "probably important"...',
    'Extracting verbal DNA from character descriptions...',
    'Interviewing each character about their favorite words...',
    'Sorting personality traits into labeled jars...',
    'Building a voice-print database from scratch...',
    'Mapping every relationship on a giant corkboard...',
    'Translating "mysterious backstory" into useful bullet points...',
    'Asking NPCs to say "the quick brown fox" for calibration...',
    'Recording speech patterns with a tiny narrative microphone...',
    'Filing character motivations by urgency and pettiness...',
    'Decomposing worldbuilding into bite-sized propositions...',
    'Teaching the engine to tell characters apart by voice...',
    'Pressing flowers from the worldbuilding garden into facts...',
    'Labeling every character quirk with a color-coded sticky note...',
    'Running personality tests on fictional people...',
    'Extracting catchphrases like they\'re rare gemstones...',
    'Studying who says "indeed" vs "yeah" vs "hmm"...',
    'Converting prose descriptions into structured dossiers...',
    'Giving each NPC a vocal fingerprint and a file number...',
    'Distilling character essays into personality espresso...',
    'Sorting knowledge boundaries so nobody cheats...',
    'Building a pronunciation guide for made-up words...',
    'Auditing character voices for accidental cloning...',
    'Tagging every world fact with its jurisdiction...',
    'Separating character from caricature with tiny tweezers...',
    'Filing appearance notes under "will need this later"...',
    'Ensuring no two characters accidentally sound like twins...',
    'Deconstructing personalities without a license...',
    'Organizing motivations by "noble" and "suspicious"...',
    'Archiving verbal tics for scene-appropriate deployment...',
    'Cross-checking speech samples against the originality index...',
    'Turning worldbuilding essays into indexed fact cards...',
    'Giving each character a unique linguistic thumbprint...',
    'Sorting relationship dynamics by emotional voltage...',
    'Extracting knowledge boundaries like careful surgery...',
    'Teaching the engine who knows what and who doesn\'t...',
    'Assembling character profiles with forensic precision...',
    'Bottling each voice like a rare perfume...',
    'Reading between the lines of every NPC description...',
    'Building a fact atlas of the fictional universe...',
    'Tuning the voice detector to catch subtle dialect shifts...',
    'Pressing raw lore into neat, domain-stamped tablets...',
    'Asking each character to demonstrate their "thinking face"...',
    'Measuring the gap between "what they say" and "how they say it"...',
    'Constructing a Rosetta Stone of character dialects...',
    'Encoding world rules into machine-readable prophecy...',
    'Polishing character profiles until they gleam distinctly...',
    'Pinning character specimens to the personality corkboard...',
    'Dusting worldbuilding fragments for narrative fingerprints...',
    'Placing each secret under glass for archival preservation...',
    'Taxonomizing fictional species by snark level and habitat...',
    'Dissecting relationship webs with sterilized plot scissors...',
    'Alphabetizing false beliefs by how confidently they\'re held...',
    'Mounting verbal tics in specimen frames for later study...',
    'Carbon-dating each rumor to its approximate origin point...',
    'Calibrating the lie detector for fictional nervous systems...',
    'Shelving disputed facts in the "handle with tongs" section...',
    'Extracting personality cores without damaging the backstory...',
    'Logging each character\'s favorite swear word for posterity...',
    'Administering Rorschach tests to NPCs who didn\'t volunteer...',
    'Tagging world facts by epistemic status and stubbornness...',
    'Separating genuine mysteries from poorly labeled plot holes...',
    'Measuring each character\'s sarcasm-to-sincerity ratio...',
    'Placing governance structures under the political microscope...',
    'Indexing every faction grudge in the rivalry filing cabinet...',
    'Isolating speech patterns in the narrative centrifuge...',
    'Stamping each world fact with its domain classification...',
    'Cataloguing who\'s lying and who just thinks they\'re right...',
    'Weighing character leverage on the interpersonal scales...',
    'Preparing slides of relationship tension for close inspection...',
    'Classifying magic systems by how much they break physics...',
    'Recording each NPC\'s sentence structure like birdsong...',
    'Filing economy details under "someone will ask about this"...',
    'Sequencing the genome of each character\'s vocabulary...',
    'Labeling knowledge gaps with "does not know" stickers...',
    'Performing an autopsy on the worldbuilding prose...',
    'Sorting cultural norms from cultural wishful thinking...',
    'Storing character secrets in the narrative vault...',
    'Mapping power dynamics with emotional sonar equipment...',
    'Quarantining unreliable narrator material for review...',
    'Fitting each religion into its proper taxonomic bracket...',
    'Distilling geography descriptions into cartographic facts...',
    'Assigning threat levels to each character\'s hidden agenda...',
    'Counting how many characters say "actually" unprompted...',
    'Pickling ecological details in preservation fluid...',
    'Measuring vocabulary breadth with the linguistic calipers...',
    'Archiving historical events by how disputed they still are...',
    'Clipping dialect samples to each character\'s dossier...',
    'Scanning for personality overlap with the uniqueness detector...',
    'Laminating world laws so nobody can smudge them later...',
    'Noting which characters finish sentences and which trail off...',
    'Filing technology levels under "plausible" through "ambitious"...',
    'Pinning relationship valence readings to the tension board...',
    'Excavating character knowledge like a careful archaeologist...',
    'Sorting language families into the constructed linguistics drawer...',
    'Bagging and tagging every unconfirmed rumor in the setting...',
    'Compiling the master index of who trusts whom and why...',
  ],
  RESOLVING_AGENDAS: [
    'Eavesdropping on NPCs whispering behind closed doors...',
    'Reviewing everyone\'s secret diary entries...',
    'Tracking who stabbed whom in the back today...',
    'Calculating grudge interest rates...',
    'Checking which NPCs are plotting revenge...',
    'Updating the grudge board with fresh pins...',
    'Listening at keyholes for nefarious scheming...',
    'Tallying up who owes favors to whom...',
    'Unfolding a corkboard of overlapping schemes...',
    'Cataloging side-eye incidents for future reference...',
    'Intercepting coded notes between shady allies...',
    'Checking whether anyone upgraded their backstabbing gear...',
    'Reviewing minutes from the secret villains\' brunch...',
    'Counting how many NPCs muttered "soon" this chapter...',
    'Auditing off-screen mischief reports...',
    'Filing incident reports for unsanctioned scheming...',
    'Measuring the ambient levels of treachery...',
    'Polling NPCs on their current treachery satisfaction...',
    'Cross-referencing alibis with suspicious absences...',
    'Recalculating everyone\'s loyalty scores...',
    'Monitoring the rumor mill for fresh gossip...',
    'Updating the conspiracy flowchart...',
    'Checking which NPCs have been pacing suspiciously...',
    'Reviewing blackmail material inventories...',
    'Verifying whether anyone sent ravens this turn...',
    'Scanning for dramatic monologue rehearsals...',
    'Adjusting NPC ambition sliders...',
    'Cataloging nervous glances exchanged this chapter...',
    'Running background checks on everyone\'s motives...',
    'Noting which NPCs smiled at the wrong moment...',
    'Tabulating petty feuds and ancient grudges...',
    'Sorting agendas by desperation level...',
    'Checking who\'s been sharpening metaphorical knives...',
    'Decoding passive-aggressive gift exchanges...',
    'Reviewing who has been suspiciously helpful lately...',
    'Evaluating the off-screen power shuffle...',
    'Tracking alliance formation and betrayal timelines...',
    'Checking which NPCs have contingency plans...',
    'Measuring fear levels against leverage ratios...',
    'Updating the "Who Wants What" spreadsheet...',
    'Intercepting a messenger pigeon with interesting news...',
    'Analyzing NPC body language from last scene...',
    'Checking if any NPCs have developed new anxieties...',
    'Reviewing the NPC suggestion box...',
    'Detecting a shift in the balance of scheming...',
    'Comparing stated intentions with actual behavior...',
    'Auditing the NPC snack cabinet for stress eating...',
    'Marking territories on the political influence map...',
    'Checking if anyone moved their chess pieces overnight...',
    'Reviewing suspicious purchases from the last chapter...',
    'Verifying that no one switched sides during the break...',
    'Running a threat assessment on recent compliments...',
    'Cataloging unfinished sentences and loaded pauses...',
    'Checking for unsigned letters slid under doors...',
    'Recalculating the probability of betrayal per NPC...',
    'Reviewing who has been making too many promises...',
    'Tracking which NPCs avoided eye contact this scene...',
    'Flagging characters with implausibly clean hands...',
    'Noting who laughed a little too long at dinner...',
    'Updating the off-screen activity ledger...',
    'Checking the villain\'s calendar for “light treason” slots...',
    'Reading NPC thoughts like it\'s gossip magazine hour...',
    'Updating everyone\'s "who do I hate today?" playlist...',
    'Monitoring suspiciously polite smiles for hidden knives...',
    'Counting how many schemes are currently fermenting...',
    'Watching alliances form like mold in a dark fridge...',
    'Checking who just leveled up in pettiness...',
    'Auditing the off-screen shenanigans ledger...',
    'Refreshing the “Who Wants What” dashboard (it screams)...',
    'Intercepting a whisper and billing it for drama...',
    'Tracking passive-aggression like it\'s a rare animal...',
    'Checking the rumor mill\'s RPMs...',
    'Inspecting favors like they\'re ticking time bombs...',
    'Noting which NPC is one compliment away from betrayal...',
    'Reviewing blackmail inventories for seasonal updates...',
    'Scanning for new rivalries blooming in the wild...',
    'Timing how long before someone says "trust me"...',
    'Checking if anyone\'s "helpfulness" seems weaponized...',
    'Recalculating loyalty after that one eyebrow raise...',
    'Measuring treachery levels in parts per million...',
    'Verifying who just sent a "totally normal" letter...',
    'Watching the power dynamics do a little dance...',
    'Checking which NPC is speedrunning revenge...',
    'Updating the conspiracy corkboard with fresh spaghetti...',
    'Listening for the sound of plans being made without us...',
    'Tracking who\'s collecting leverage like shiny coins...',
    'Marking territories on the influence map with crayons...',
    'Checking who\'s stress-eating near the secret door...',
    'Reviewing the villain group chat highlights...',
    'Detecting new agendas forming in the narrative fog...',
    'Following a trail of side-eyes to its source...',
    'Confirming who just became a problem on purpose...',
    'Noting which promise is about to come due with interest...',
    'Watching friendships develop structural weaknesses...',
    'Counting how many NPCs just said "interesting" too slowly...',
    'Checking the dead drop for unsigned ultimatums...',
    'Decrypting that suspiciously friendly dinner invitation...',
    'Tallying up who owes silence to whom...',
    'Running surveillance on that oddly cheerful NPC...',
    'Updating the dossier on everyone who smiled wrong...',
  ],
};
const STAGE_DISPLAY_NAMES = {
  GENERATING_CONCEPTS: 'IDEATING',
  EVALUATING_CONCEPTS: 'EVALUATING',
  STRESS_TESTING_CONCEPT: 'HARDENING',
  GENERATING_SPINE: 'ENVISIONING',
  PLANNING_PAGE: 'PLANNING',
  ACCOUNTING_STATE: 'ACCOUNTING',
  CURATING_CONTEXT: 'LOREKEEPING',
  WRITING_OPENING_PAGE: 'WRITING',
  WRITING_CONTINUING_PAGE: 'WRITING',
  ANALYZING_SCENE: 'ANALYZING',
  STRUCTURING_STORY: 'STRUCTURING',
  DECOMPOSING_ENTITIES: 'STUDYING',
  RESTRUCTURING_STORY: 'RESTRUCTURING',
  RESOLVING_AGENDAS: 'SCHEMING',
};

// ── Choice / Delta enums and label maps ──────────────────────────

var CHOICE_TYPES = [
  { value: 'TACTICAL_APPROACH', label: 'Method/Tactic' },
  { value: 'MORAL_DILEMMA', label: 'Moral Choice' },
  { value: 'IDENTITY_EXPRESSION', label: 'Define Yourself' },
  { value: 'RELATIONSHIP_SHIFT', label: 'Relationship' },
  { value: 'RESOURCE_COMMITMENT', label: 'Spend/Risk' },
  { value: 'INVESTIGATION', label: 'Investigate' },
  { value: 'PATH_DIVERGENCE', label: 'Change Direction' },
  { value: 'CONFRONTATION', label: 'Confront/Fight' },
  { value: 'AVOIDANCE_RETREAT', label: 'Avoid/Flee' },
];

var PRIMARY_DELTAS = [
  { value: 'LOCATION_CHANGE', label: 'Location' },
  { value: 'GOAL_SHIFT', label: 'Goal' },
  { value: 'RELATIONSHIP_CHANGE', label: 'Relationship' },
  { value: 'URGENCY_CHANGE', label: 'Time Pressure' },
  { value: 'ITEM_CONTROL', label: 'Item' },
  { value: 'EXPOSURE_CHANGE', label: 'Attention' },
  { value: 'CONDITION_CHANGE', label: 'Condition' },
  { value: 'INFORMATION_REVEALED', label: 'Information' },
  { value: 'THREAT_SHIFT', label: 'Danger' },
  { value: 'CONSTRAINT_CHANGE', label: 'Limitation' },
];

var CHOICE_TYPE_LABEL_MAP = {};
CHOICE_TYPES.forEach(function (ct) { CHOICE_TYPE_LABEL_MAP[ct.value] = ct.label; });

var PRIMARY_DELTA_LABEL_MAP = {};
PRIMARY_DELTAS.forEach(function (pd) { PRIMARY_DELTA_LABEL_MAP[pd.value] = pd.label; });

  // ── Utility functions ──────────────────────────────────────────────

  function getApiKey() {
    return sessionStorage.getItem(API_KEY_STORAGE_KEY);
  }

  function setApiKey(key) {
    sessionStorage.setItem(API_KEY_STORAGE_KEY, key);
  }

  function createProgressId() {
    if (window.crypto && typeof window.crypto.randomUUID === 'function') {
      return window.crypto.randomUUID();
    }

    return 'progress-' + Date.now() + '-' + Math.random().toString(16).slice(2);
  }

  function getRandomInt(minInclusive, maxInclusive) {
    return Math.floor(Math.random() * (maxInclusive - minInclusive + 1)) + minInclusive;
  }

  function pickRandomPhrase(phrases, previousPhrase) {
    if (!Array.isArray(phrases) || phrases.length === 0) {
      return '';
    }

    if (phrases.length === 1) {
      return phrases[0];
    }

    var selected = phrases[getRandomInt(0, phrases.length - 1)];
    while (selected === previousPhrase) {
      selected = phrases[getRandomInt(0, phrases.length - 1)];
    }
    return selected;
  }

  function escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = String(text ?? '');
    return div.innerHTML;
  }

  function escapeHtmlWithBreaks(text) {
    return escapeHtml(text).replace(/\n/g, '<br>');
  }

  function enumToIconName(enumValue) {
    if (typeof enumValue !== 'string' || enumValue.length === 0) {
      return '';
    }
    return enumValue.toLowerCase().replace(/_/g, '-');
  }

  function getIconPath(enumValue) {
    var name = enumToIconName(enumValue);
    return name ? '/images/icons/' + name + '.png' : '';
  }

  function getThreadIconPath(threadType, urgency) {
    if (typeof threadType !== 'string' || threadType.length === 0) {
      return '';
    }
    if (typeof urgency !== 'string' || urgency.length === 0) {
      return '';
    }
    return '/images/icons/thread-' + threadType.toLowerCase() + '-' + urgency.toLowerCase() + '.png';
  }

  function getPromiseIconPath(promiseType, urgency) {
    if (typeof promiseType !== 'string' || promiseType.length === 0) {
      return '';
    }
    if (typeof urgency !== 'string' || urgency.length === 0) {
      return '';
    }
    return '/images/icons/promise-' + promiseType.toLowerCase().replace(/_/g, '-') + '-' + urgency.toLowerCase() + '.png';
  }


  // ── Loading progress controller ────────────────────────────────────

  function createLoadingProgressController(loadingElement) {
    var stageTextElement = loadingElement ? loadingElement.querySelector('.loading-stage') : null;
    var statusTextElement = loadingElement
      ? loadingElement.querySelector('.loading-status') || loadingElement.querySelector('p')
      : null;
    var fallbackText = statusTextElement && statusTextElement.textContent
      ? statusTextElement.textContent
      : 'Loading...';
    var stopped = true;
    var progressId = '';
    var currentStage = null;
    var currentPhrase = '';
    var pollTimeout = null;
    var phraseTimeout = null;

    function setStatusText(text) {
      if (statusTextElement) {
        statusTextElement.textContent = text;
      }
    }

    function setStageText(stageName) {
      if (stageTextElement) {
        stageTextElement.textContent = stageName || '';
      }
    }

    function clearTimers() {
      if (pollTimeout !== null) {
        clearTimeout(pollTimeout);
        pollTimeout = null;
      }
      if (phraseTimeout !== null) {
        clearTimeout(phraseTimeout);
        phraseTimeout = null;
      }
    }

    function setFallbackText() {
      currentStage = null;
      currentPhrase = '';
      if (phraseTimeout !== null) {
        clearTimeout(phraseTimeout);
        phraseTimeout = null;
      }
      setStageText('');
      setStatusText(fallbackText);
    }

    function schedulePhraseRotation() {
      if (phraseTimeout !== null) {
        clearTimeout(phraseTimeout);
        phraseTimeout = null;
      }

      if (stopped || !currentStage) {
        return;
      }

      var phrases = STAGE_PHRASE_POOLS[currentStage];
      if (!Array.isArray(phrases) || phrases.length === 0) {
        return;
      }

      var delay = getRandomInt(PHRASE_ROTATION_MIN_MS, PHRASE_ROTATION_MAX_MS);
      phraseTimeout = window.setTimeout(function() {
        if (stopped || !currentStage) {
          return;
        }
        currentPhrase = pickRandomPhrase(phrases, currentPhrase);
        setStatusText(currentPhrase);
        schedulePhraseRotation();
      }, delay);
    }

    function applyStage(stage) {
      var phrases = STAGE_PHRASE_POOLS[stage];
      if (!Array.isArray(phrases) || phrases.length === 0) {
        setFallbackText();
        return;
      }

      if (currentStage !== stage) {
        currentStage = stage;
        setStageText(STAGE_DISPLAY_NAMES[stage] || '');
        currentPhrase = '';
        currentPhrase = pickRandomPhrase(phrases, currentPhrase);
        setStatusText(currentPhrase);
        schedulePhraseRotation();
        return;
      }

      if (phraseTimeout === null) {
        schedulePhraseRotation();
      }
    }

    async function pollProgress() {
      if (stopped || !progressId) {
        return;
      }

      try {
        var response = await fetch('/generation-progress/' + encodeURIComponent(progressId), {
          cache: 'no-store',
        });

        if (!response.ok) {
          throw new Error('Progress polling failed');
        }

        var snapshot = await response.json();
        if (snapshot.status === 'running') {
          if (typeof snapshot.activeStage === 'string') {
            applyStage(snapshot.activeStage);
          } else {
            setFallbackText();
          }
        } else if (snapshot.status === 'unknown') {
          setFallbackText();
        } else if (snapshot.status === 'completed' || snapshot.status === 'failed') {
          stop();
          return;
        } else {
          setFallbackText();
        }
      } catch (_error) {
        setFallbackText();
      }

      if (!stopped) {
        pollTimeout = window.setTimeout(pollProgress, PROGRESS_POLL_INTERVAL_MS);
      }
    }

    function start(newProgressId) {
      stop();
      progressId = newProgressId;
      stopped = false;
      setFallbackText();
      void pollProgress();
    }

    function stop() {
      stopped = true;
      progressId = '';
      currentStage = null;
      currentPhrase = '';
      clearTimers();
      setStatusText(fallbackText);
    }

    return {
      start: start,
      stop: stop,
    };
  }


  // ── Thread renderers ──────────────────────────────────────────────

  function renderThreadBadgePill(threadType, urgency) {
    var iconPath = getThreadIconPath(threadType, urgency);
    var html = '<span class="thread-icon-pill" aria-hidden="true">';

    html += '<span class="thread-icon-badge">';
    if (iconPath) {
      html += '<img class="thread-icon"'
        + ' src="' + escapeHtml(iconPath) + '"'
        + ' alt="" title="' + escapeHtml(threadType + ' (' + urgency + ')') + '"'
        + ' loading="lazy"'
        + " onerror=\"this.style.display='none'\">";
    }
    html += '</span>';

    html += '</span>';
    return html;
  }

  function renderThreatBadgePill(threatType) {
    var threatTypeIconPath = getIconPath('threat_' + threatType);
    var html = '<span class="thread-icon-pill" aria-hidden="true">';

    html += '<span class="thread-icon-badge thread-icon-badge--type thread-icon-badge--threat">';
    if (threatTypeIconPath) {
      html += '<img class="thread-icon thread-icon--type thread-icon--threat"'
        + ' src="' + escapeHtml(threatTypeIconPath) + '"'
        + ' alt="" title="' + escapeHtml(threatType) + '"'
        + ' loading="lazy"'
        + " onerror=\"this.style.display='none'\">";
    }
    html += '</span>';

    html += '</span>';
    return html;
  }

  function renderConstraintBadgePill(constraintType) {
    var constraintTypeIconPath = getIconPath('constraint_' + constraintType);
    var html = '<span class="thread-icon-pill" aria-hidden="true">';

    html += '<span class="thread-icon-badge thread-icon-badge--type">';
    if (constraintTypeIconPath) {
      html += '<img class="thread-icon thread-icon--type"'
        + ' src="' + escapeHtml(constraintTypeIconPath) + '"'
        + ' alt="" title="' + escapeHtml(constraintType) + '"'
        + ' loading="lazy"'
        + " onerror=\"this.style.display='none'\">";
    }
    html += '</span>';

    html += '</span>';
    return html;
  }

  function renderPromiseBadgePill(promiseType, urgency) {
    var iconPath = getPromiseIconPath(promiseType, urgency);
    var html = '<span class="thread-icon-pill" aria-hidden="true">';

    html += '<span class="thread-icon-badge thread-icon-badge--type thread-icon-badge--promise">';
    if (iconPath) {
      html += '<img class="thread-icon thread-icon--type thread-icon--promise"'
        + ' src="' + escapeHtml(iconPath) + '"'
        + ' alt="" title="' + escapeHtml(promiseType + ' (' + urgency + ')') + '"'
        + ' loading="lazy"'
        + " onerror=\"this.style.display='none'\">";
    }
    html += '</span>';

    html += '</span>';
    return html;
  }

  function getOpenThreadUrgencyClass(urgency) {
    if (urgency === 'HIGH') {
      return 'open-threads-text--high';
    }
    if (urgency === 'MEDIUM') {
      return 'open-threads-text--medium';
    }
    if (urgency === 'LOW') {
      return 'open-threads-text--low';
    }
    return 'open-threads-text--low';
  }

  function getUrgencyPriority(urgency) {
    if (urgency === 'HIGH') {
      return 0;
    }
    if (urgency === 'MEDIUM') {
      return 1;
    }
    if (urgency === 'LOW') {
      return 2;
    }
    return 3;
  }

  function buildOpenThreadOverflowSummary(hiddenThreads) {
    if (!Array.isArray(hiddenThreads) || hiddenThreads.length === 0) {
      return null;
    }

    var highCount = 0;
    var mediumCount = 0;
    var lowCount = 0;

    hiddenThreads.forEach(function(thread) {
      if (thread.urgency === 'HIGH') {
        highCount += 1;
        return;
      }
      if (thread.urgency === 'MEDIUM') {
        mediumCount += 1;
        return;
      }
      if (thread.urgency === 'LOW') {
        lowCount += 1;
      }
    });

    var parts = [];
    if (highCount > 0) {
      parts.push(highCount + ' (high)');
    }
    if (mediumCount > 0) {
      parts.push(mediumCount + ' (medium)');
    }
    if (lowCount > 0) {
      parts.push(lowCount + ' (low)');
    }

    if (parts.length === 0) {
      return null;
    }

    return 'Not shown: ' + parts.join(', ');
  }

  function ensureSidebarContainer() {
    return document.getElementById('sidebar-widgets');
  }

  function cleanupEmptySidebar() {
    // Container is a grid cell; never remove it
  }

  function renderOpenThreadsPanel(openThreads, openThreadOverflowSummary, sidebarContainer) {
    const existingPanel = document.getElementById('open-threads-panel');

    if (!Array.isArray(openThreads) || openThreads.length === 0) {
      if (existingPanel) {
        existingPanel.remove();
      }
      return;
    }

    const normalizedThreads = openThreads
      .map(function(thread, index) {
        if (!thread || typeof thread !== 'object') {
          return null;
        }

        var id = typeof thread.id === 'string' ? thread.id : '';
        var text = typeof thread.text === 'string' ? thread.text : '';
        var threadType = typeof thread.threadType === 'string' ? thread.threadType : '';
        var urgency = typeof thread.urgency === 'string' ? thread.urgency : '';

        if (!id || !text || !threadType || !urgency) {
          return null;
        }

        return { id: id, text: text, threadType: threadType, urgency: urgency, index: index };
      })
      .filter(function(thread) {
        return thread !== null;
      })
      .sort(function(left, right) {
        var urgencyDelta = getUrgencyPriority(left.urgency) - getUrgencyPriority(right.urgency);
        if (urgencyDelta !== 0) {
          return urgencyDelta;
        }
        return left.index - right.index;
      });

    if (normalizedThreads.length === 0) {
      if (existingPanel) {
        existingPanel.remove();
      }
      return;
    }

    const visibleThreads = normalizedThreads.slice(0, OPEN_THREADS_PANEL_LIMIT);
    const hiddenThreads = normalizedThreads.slice(OPEN_THREADS_PANEL_LIMIT);
    const normalizedOverflowSummary =
      typeof openThreadOverflowSummary === 'string' && openThreadOverflowSummary.trim().length > 0
        ? openThreadOverflowSummary.trim()
        : buildOpenThreadOverflowSummary(hiddenThreads);

    const listHtml = visibleThreads.map(function(thread) {
      var urgencyClass = getOpenThreadUrgencyClass(thread.urgency);
      return '<li class="open-threads-item">'
        + renderThreadBadgePill(thread.threadType, thread.urgency)
        + '<span class="open-threads-text ' + urgencyClass + '">' + escapeHtml(thread.text) + '</span>'
        + '</li>';
    }).join('');

    if (existingPanel) {
      const list = existingPanel.querySelector('#open-threads-list');
      if (list) {
        list.innerHTML = listHtml;
      }
      const existingSummary = existingPanel.querySelector('#open-threads-overflow-summary');
      if (normalizedOverflowSummary) {
        if (existingSummary) {
          existingSummary.textContent = normalizedOverflowSummary;
        } else {
          const summary = document.createElement('div');
          summary.className = 'open-threads-overflow-summary';
          summary.id = 'open-threads-overflow-summary';
          summary.textContent = normalizedOverflowSummary;
          existingPanel.appendChild(summary);
        }
      } else if (existingSummary) {
        existingSummary.remove();
      }
      return;
    }

    const summaryHtml = normalizedOverflowSummary
      ? '<div class="open-threads-overflow-summary" id="open-threads-overflow-summary">'
          + escapeHtml(normalizedOverflowSummary)
          + '</div>'
      : '';
    const panel = document.createElement('aside');
    panel.className = 'open-threads-panel';
    panel.id = 'open-threads-panel';
    panel.setAttribute('aria-labelledby', 'open-threads-title');
    panel.innerHTML = '<h3 class="open-threads-title" id="open-threads-title">Active Threads</h3>'
      + '<ul class="open-threads-list" id="open-threads-list">'
      + listHtml
      + '</ul>'
      + summaryHtml;

    sidebarContainer.appendChild(panel);
  }

  function renderKeyedEntryPanel(config) {
    var existingPanel = document.getElementById(config.panelId);

    if (!Array.isArray(config.entries) || config.entries.length === 0) {
      if (existingPanel) {
        existingPanel.remove();
      }
      return;
    }

    var normalized = config.entries
      .filter(function(entry) {
        return entry && typeof entry === 'object'
          && typeof entry.id === 'string' && entry.id.length > 0
          && typeof entry.text === 'string' && entry.text.length > 0;
      });

    if (normalized.length === 0) {
      if (existingPanel) {
        existingPanel.remove();
      }
      return;
    }

    var limit = typeof config.limit === 'number' ? config.limit : KEYED_ENTRY_PANEL_LIMIT;
    var visible = normalized.slice(0, limit);
    var hiddenCount = normalized.length - limit;
    var overflowText = typeof config.overflowSummary === 'string' && config.overflowSummary.trim().length > 0
      ? config.overflowSummary.trim()
      : (hiddenCount > 0 ? '+' + hiddenCount + ' more not shown' : null);

    var listHtml = visible
      .map(function(entry) {
        if (typeof config.renderEntry === 'function') {
          return '<li class="' + config.itemClass + '">' + config.renderEntry(entry) + '</li>';
        }
        return '<li class="' + config.itemClass + '">' + escapeHtml(entry.text) + '</li>';
      })
      .join('');

    if (existingPanel) {
      var list = existingPanel.querySelector('#' + config.listId);
      if (list) {
        list.innerHTML = listHtml;
      }
      var existingSummary = existingPanel.querySelector('#' + config.overflowId);
      if (overflowText) {
        if (existingSummary) {
          existingSummary.textContent = overflowText;
        } else {
          var summary = document.createElement('div');
          summary.className = 'keyed-entry-overflow-summary';
          summary.id = config.overflowId;
          summary.textContent = overflowText;
          existingPanel.appendChild(summary);
        }
      } else if (existingSummary) {
        existingSummary.remove();
      }
      return;
    }

    var summaryHtml = overflowText
      ? '<div class="keyed-entry-overflow-summary" id="' + config.overflowId + '">'
          + escapeHtml(overflowText)
          + '</div>'
      : '';
    var panel = document.createElement('aside');
    panel.className = config.panelClass;
    panel.id = config.panelId;
    panel.setAttribute('aria-labelledby', config.titleId);
    panel.innerHTML = '<h3 class="' + config.titleClass + '" id="' + config.titleId + '">'
      + escapeHtml(config.title) + '</h3>'
      + '<ul class="' + config.listClass + '" id="' + config.listId + '">'
      + listHtml
      + '</ul>'
      + summaryHtml;

    config.container.appendChild(panel);
  }

  function renderActiveThreatsPanel(threats, threatsOverflowSummary, sidebarContainer) {
    renderKeyedEntryPanel({
      panelId: 'active-threats-panel',
      titleId: 'active-threats-title',
      listId: 'active-threats-list',
      overflowId: 'active-threats-overflow',
      panelClass: 'active-threats-panel',
      titleClass: 'active-threats-title',
      listClass: 'active-threats-list',
      itemClass: 'active-threats-item',
      title: 'Active Threats',
      entries: threats,
      overflowSummary: threatsOverflowSummary,
      container: sidebarContainer,
      renderEntry: function(entry) {
        var threatType = typeof entry.threatType === 'string' ? entry.threatType : '';
        if (!threatType) {
          return escapeHtml(entry.text);
        }
        return renderThreatBadgePill(threatType) + '<span>' + escapeHtml(entry.text) + '</span>';
      },
    });
  }

  function renderActiveConstraintsPanel(constraints, constraintsOverflowSummary, sidebarContainer) {
    renderKeyedEntryPanel({
      panelId: 'active-constraints-panel',
      titleId: 'active-constraints-title',
      listId: 'active-constraints-list',
      overflowId: 'active-constraints-overflow',
      panelClass: 'active-constraints-panel',
      titleClass: 'active-constraints-title',
      listClass: 'active-constraints-list',
      itemClass: 'active-constraints-item',
      title: 'Active Constraints',
      entries: constraints,
      overflowSummary: constraintsOverflowSummary,
      container: sidebarContainer,
      renderEntry: function(entry) {
        var constraintType = typeof entry.constraintType === 'string' ? entry.constraintType : '';
        if (!constraintType) {
          return escapeHtml(entry.text);
        }
        return (
          renderConstraintBadgePill(constraintType) + '<span>' + escapeHtml(entry.text) + '</span>'
        );
      },
    });
  }

  function formatPromiseScope(value) {
    if (typeof value !== 'string' || value.length === 0) {
      return '';
    }
    return value.charAt(0) + value.slice(1).toLowerCase();
  }

  function renderTrackedPromisesPanel(promises, trackedPromisesOverflowSummary, sidebarContainer) {
    renderKeyedEntryPanel({
      panelId: 'tracked-promises-panel',
      titleId: 'tracked-promises-title',
      listId: 'tracked-promises-list',
      overflowId: 'tracked-promises-overflow',
      panelClass: 'tracked-promises-panel',
      titleClass: 'tracked-promises-title',
      listClass: 'tracked-promises-list',
      itemClass: 'tracked-promises-item',
      title: 'Tracked Promises',
      entries: Array.isArray(promises) ? promises.map(function(p) {
        return {
          id: typeof p.id === 'string' ? p.id : '',
          text: typeof p.text === 'string' ? p.text : '',
          promiseType: typeof p.promiseType === 'string' ? p.promiseType : '',
          scope: typeof p.scope === 'string' ? p.scope : '',
          age: typeof p.age === 'number' ? p.age : 0,
          suggestedUrgency: typeof p.suggestedUrgency === 'string' ? p.suggestedUrgency : '',
        };
      }) : [],
      overflowSummary: trackedPromisesOverflowSummary,
      container: sidebarContainer,
      renderEntry: function(entry) {
        var scopeLabel = formatPromiseScope(entry.scope);
        return renderPromiseBadgePill(entry.promiseType, entry.suggestedUrgency)
          + (scopeLabel ? '<span class="promise-scope-badge">' + escapeHtml(scopeLabel) + '</span>' : '')
          + '<span class="promise-age-badge">' + entry.age + ' pg</span>'
          + '<span>' + escapeHtml(entry.text) + '</span>';
      },
    });
  }

  function ensureLeftSidebarContainer() {
    return document.getElementById('left-sidebar-widgets');
  }

  function cleanupEmptyLeftSidebar() {
    // Container is a grid cell; never remove it
  }

  function renderInventoryPanel(inventory, inventoryOverflowSummary, leftSidebarContainer) {
    renderKeyedEntryPanel({
      panelId: 'inventory-panel',
      titleId: 'inventory-title',
      listId: 'inventory-list',
      overflowId: 'inventory-overflow',
      panelClass: 'inventory-panel',
      titleClass: 'inventory-title',
      listClass: 'inventory-list',
      itemClass: 'inventory-item',
      title: 'Inventory',
      entries: inventory,
      overflowSummary: inventoryOverflowSummary,
      container: leftSidebarContainer,
      limit: LEFT_PANEL_LIMIT,
    });
  }

  function renderHealthPanel(health, healthOverflowSummary, leftSidebarContainer) {
    renderKeyedEntryPanel({
      panelId: 'health-panel',
      titleId: 'health-title',
      listId: 'health-list',
      overflowId: 'health-overflow',
      panelClass: 'health-panel',
      titleClass: 'health-title',
      listClass: 'health-list',
      itemClass: 'health-item',
      title: 'Health',
      entries: health,
      overflowSummary: healthOverflowSummary,
      container: leftSidebarContainer,
      limit: LEFT_PANEL_LIMIT,
    });
  }

  // ── Spine Renderer ──────────────────────────────────────────────────

  var SPINE_TYPE_LABELS = {
    QUEST: 'Quest',
    SURVIVAL: 'Survival',
    ESCAPE: 'Escape',
    REVENGE: 'Revenge',
    RESCUE: 'Rescue',
    RIVALRY: 'Rivalry',
    MYSTERY: 'Mystery',
    TEMPTATION: 'Temptation',
    TRANSFORMATION: 'Transformation',
    FORBIDDEN_LOVE: 'Forbidden Love',
    SACRIFICE: 'Sacrifice',
    FALL_FROM_GRACE: 'Fall from Grace',
    RISE_TO_POWER: 'Rise to Power',
    COMING_OF_AGE: 'Coming of Age',
    REBELLION: 'Rebellion',
  };

  var CONFLICT_TYPE_LABELS = {
    PERSON_VS_PERSON: 'Person vs Person',
    PERSON_VS_SELF: 'Person vs Self',
    PERSON_VS_SOCIETY: 'Person vs Society',
    PERSON_VS_NATURE: 'Person vs Nature',
    PERSON_VS_TECHNOLOGY: 'Person vs Technology',
    PERSON_VS_SUPERNATURAL: 'Person vs Supernatural',
    PERSON_VS_FATE: 'Person vs Fate',
  };

  var ARC_TYPE_LABELS = {
    POSITIVE_CHANGE: 'Positive Change',
    FLAT: 'Flat Arc',
    DISILLUSIONMENT: 'Disillusionment',
    FALL: 'Fall',
    CORRUPTION: 'Corruption',
  };

  var DYNAMIC_LABELS = {
    CONVERGENT: 'Convergent',
    DIVERGENT: 'Divergent',
    SUBSTITUTIVE: 'Substitutive',
    IRRECONCILABLE: 'Irreconcilable',
  };

  var selectedSpine = null;

  function getSelectedSpine() {
    return selectedSpine;
  }

  function clearSelectedSpine() {
    selectedSpine = null;
  }

  function renderSpineOptions(options, container, onSelect) {
    container.innerHTML = '';
    selectedSpine = null;

    options.forEach(function (option, index) {
      var card = document.createElement('div');
      card.className = 'spine-card';
      card.dataset.index = String(index);

      var badges = document.createElement('div');
      badges.className = 'spine-badges';
      badges.innerHTML =
        '<span class="spine-badge spine-badge-type">' +
        escapeHtml(SPINE_TYPE_LABELS[option.storySpineType] || option.storySpineType) +
        '</span>' +
        '<span class="spine-badge spine-badge-conflict">' +
        escapeHtml(CONFLICT_TYPE_LABELS[option.conflictType] || option.conflictType) +
        '</span>' +
        '<span class="spine-badge spine-badge-arc">' +
        escapeHtml(ARC_TYPE_LABELS[option.characterArcType] || option.characterArcType) +
        '</span>';

      var cdq = document.createElement('h3');
      cdq.className = 'spine-cdq';
      cdq.textContent = option.centralDramaticQuestion;

      var needWant = document.createElement('div');
      needWant.className = 'spine-need-want';
      needWant.innerHTML =
        '<div class="spine-field">' +
        '<span class="spine-label">Need:</span> ' +
        escapeHtml(option.protagonistNeedVsWant.need) +
        '</div>' +
        '<div class="spine-field">' +
        '<span class="spine-label">Want:</span> ' +
        escapeHtml(option.protagonistNeedVsWant.want) +
        '</div>' +
        '<div class="spine-field">' +
        '<span class="spine-label">Dynamic:</span> ' +
        '<span class="spine-badge spine-badge-dynamic">' +
        escapeHtml(DYNAMIC_LABELS[option.protagonistNeedVsWant.dynamic] || option.protagonistNeedVsWant.dynamic) +
        '</span>' +
        '</div>';

      var antag = document.createElement('div');
      antag.className = 'spine-antagonist';
      antag.innerHTML =
        '<div class="spine-field">' +
        '<span class="spine-label">Opposition:</span> ' +
        escapeHtml(option.primaryAntagonisticForce.description) +
        '</div>' +
        '<div class="spine-field">' +
        '<span class="spine-label">Pressure:</span> ' +
        escapeHtml(option.primaryAntagonisticForce.pressureMechanism) +
        '</div>';

      var tone = document.createElement('div');
      tone.className = 'spine-tone';
      var toneHtml = '';
      if (option.toneFeel && option.toneFeel.length > 0) {
        toneHtml +=
          '<div class="spine-field">' +
          '<span class="spine-label">Feel:</span> ' +
          '<span class="spine-tone-pills">';
        option.toneFeel.forEach(function (kw) {
          toneHtml +=
            '<span class="spine-tone-pill spine-tone-pill-positive">' +
            escapeHtml(kw) +
            '</span>';
        });
        toneHtml += '</span></div>';
      }
      if (option.toneAvoid && option.toneAvoid.length > 0) {
        toneHtml +=
          '<div class="spine-field">' +
          '<span class="spine-label">Avoids:</span> ' +
          '<span class="spine-tone-pills">';
        option.toneAvoid.forEach(function (kw) {
          toneHtml +=
            '<span class="spine-tone-pill spine-tone-pill-negative">' +
            escapeHtml(kw) +
            '</span>';
        });
        toneHtml += '</span></div>';
      }
      tone.innerHTML = toneHtml;

      card.appendChild(badges);
      card.appendChild(cdq);
      card.appendChild(needWant);
      card.appendChild(antag);
      card.appendChild(tone);

      card.addEventListener('click', function () {
        var allCards = container.querySelectorAll('.spine-card');
        allCards.forEach(function (c) {
          c.classList.remove('spine-card-selected');
        });
        card.classList.add('spine-card-selected');
        selectedSpine = option;
        if (typeof onSelect === 'function') {
          onSelect(option);
        }
      });

      container.appendChild(card);
    });
  }

  function clearSpineOptions(container) {
    container.innerHTML = '';
    selectedSpine = null;
  }

  function escapeHtml(text) {
    var div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
  }

  // ── Act Indicator Toggle ──────────────────────────────────────────

  function toggleActStructureDetails() {
    var indicator = document.getElementById('act-indicator');
    var details = document.getElementById('act-structure-details');
    if (!indicator || !details) return;

    var isExpanded = indicator.getAttribute('aria-expanded') === 'true';
    indicator.setAttribute('aria-expanded', String(!isExpanded));
    indicator.classList.toggle('act-indicator--expanded', !isExpanded);
    details.hidden = isExpanded;
  }

  function initActIndicator() {
    var indicator = document.getElementById('act-indicator');
    if (!indicator) return;

    indicator.addEventListener('click', toggleActStructureDetails);
    indicator.addEventListener('keydown', function(e) {
      if (e.key === 'Enter' || e.key === ' ') {
        e.preventDefault();
        toggleActStructureDetails();
      }
    });
  }

  function expandActStructureDetails() {
    var indicator = document.getElementById('act-indicator');
    var details = document.getElementById('act-structure-details');
    if (!indicator || !details) return;
    indicator.setAttribute('aria-expanded', 'true');
    indicator.classList.add('act-indicator--expanded');
    details.hidden = false;
  }

  function collapseActStructureDetails() {
    var indicator = document.getElementById('act-indicator');
    var details = document.getElementById('act-structure-details');
    if (!indicator || !details) return;
    indicator.setAttribute('aria-expanded', 'false');
    indicator.classList.remove('act-indicator--expanded');
    details.hidden = true;
  }

  // ── Concept Renderer ───────────────────────────────────────────────

  var CONCEPT_SCORE_FIELDS = [
    { key: 'hookStrength', label: 'Hook' },
    { key: 'conflictEngine', label: 'Conflict' },
    { key: 'agencyBreadth', label: 'Agency' },
    { key: 'noveltyLeverage', label: 'Novelty' },
    { key: 'branchingFitness', label: 'Branching' },
    { key: 'llmFeasibility', label: 'Feasibility' },
  ];

  var selectedConceptIndex = -1;

  function clearSelectedConcept() {
    selectedConceptIndex = -1;
  }

  function getSelectedConceptIndex() {
    return selectedConceptIndex;
  }

  function formatConceptLabel(value) {
    return String(value || '').replace(/_/g, ' ');
  }

  function getScoreColorClass(score) {
    if (score <= 2) return 'low';
    if (score <= 3) return 'mid';
    return 'high';
  }

  function renderScoreGrid(scores) {
    var cells = CONCEPT_SCORE_FIELDS.map(function (field) {
      var rawScore = Number(scores && scores[field.key]);
      var safeScore = Number.isFinite(rawScore) ? Math.max(0, Math.min(5, rawScore)) : 0;
      var colorClass = getScoreColorClass(safeScore);
      var fullCount = Math.floor(safeScore);
      var hasHalf = (safeScore % 1) >= 0.25;
      var pips = '';

      for (var i = 0; i < 5; i++) {
        if (i < fullCount) {
          pips += '<span class="concept-pip concept-pip--filled concept-pip--' + colorClass + '"></span>';
        } else if (i === fullCount && hasHalf) {
          pips += '<span class="concept-pip concept-pip--half concept-pip--' + colorClass + '"></span>';
        } else {
          pips += '<span class="concept-pip concept-pip--empty"></span>';
        }
      }

      return (
        '<div class="concept-score-cell">' +
          '<span class="concept-score-label">' + escapeHtml(field.label) + '</span>' +
          '<span class="concept-score-value concept-score-value--' + colorClass + '">' + safeScore.toFixed(1) + '</span>' +
          '<div class="concept-score-pips">' + pips + '</div>' +
        '</div>'
      );
    }).join('');

    return '<div class="concept-scores-grid">' + cells + '</div>';
  }

  function renderListItems(items) {
    if (!Array.isArray(items) || items.length === 0) {
      return '<li class="concept-list-empty">None</li>';
    }

    return items.map(function (item) {
      return '<li>' + escapeHtml(String(item)) + '</li>';
    }).join('');
  }

  function renderConceptCards(evaluatedConcepts, container, onSelect) {
    if (!container) {
      return;
    }

    container.innerHTML = '';
    selectedConceptIndex = -1;

    if (!Array.isArray(evaluatedConcepts) || evaluatedConcepts.length === 0) {
      container.innerHTML = '<p class="spine-section-subtitle">No concept candidates returned. Adjust your seeds and try again.</p>';
      return;
    }

    evaluatedConcepts.forEach(function (entry, index) {
      var concept = entry && entry.concept ? entry.concept : {};
      var card = document.createElement('article');
      card.className = 'spine-card concept-card';
      card.dataset.index = String(index);

      var overallScore = Number(entry && entry.overallScore);
      var safeOverall = Number.isFinite(overallScore) ? Math.max(0, Math.min(100, overallScore)) : 0;

      card.innerHTML =
        '<div class="spine-badges">' +
          '<span class="spine-badge spine-badge-type">' + escapeHtml(formatConceptLabel(concept.genreFrame)) + '</span>' +
          '<span class="spine-badge spine-badge-conflict">' + escapeHtml(formatConceptLabel(concept.conflictAxis)) + '</span>' +
          '<span class="spine-badge spine-badge-arc">Score ' + escapeHtml(Math.round(safeOverall).toString()) + '</span>' +
        '</div>' +
        '<h3 class="spine-cdq">' + escapeHtml(concept.oneLineHook || '') + '</h3>' +
        '<p class="spine-field">' + escapeHtml(concept.elevatorParagraph || '') + '</p>' +
        '<div class="spine-field"><span class="spine-label">Protagonist:</span> ' + escapeHtml(concept.protagonistRole || '') + '</div>' +
        '<div class="concept-scores">' + renderScoreGrid(entry && entry.scores) + '</div>' +
        '<div class="spine-field"><span class="spine-label">Tradeoff:</span> ' + escapeHtml(entry && entry.tradeoffSummary ? entry.tradeoffSummary : '') + '</div>' +
        '<div class="concept-feedback">' +
          '<div class="concept-feedback-block"><span class="spine-label">Strengths</span><ul>' + renderListItems(entry && entry.strengths) + '</ul></div>' +
          '<div class="concept-feedback-block"><span class="spine-label">Weaknesses</span><ul>' + renderListItems(entry && entry.weaknesses) + '</ul></div>' +
        '</div>' +
        '<label class="concept-harden-toggle">' +
          '<input type="checkbox" class="concept-harden-checkbox" data-concept-index="' + index + '"> Harden this concept' +
        '</label>';

      card.addEventListener('click', function () {
        var allCards = container.querySelectorAll('.concept-card');
        allCards.forEach(function (candidate) {
          candidate.classList.remove('spine-card-selected');
        });
        card.classList.add('spine-card-selected');
        selectedConceptIndex = index;

        if (typeof onSelect === 'function') {
          var hardenInput = card.querySelector('.concept-harden-checkbox');
          onSelect({
            evaluatedConcept: entry,
            index: index,
            hardenRequested: Boolean(hardenInput && hardenInput.checked),
          });
        }
      });

      var hardenCheckbox = card.querySelector('.concept-harden-checkbox');
      if (hardenCheckbox) {
        hardenCheckbox.addEventListener('click', function (event) {
          event.stopPropagation();
        });

        hardenCheckbox.addEventListener('change', function () {
          if (selectedConceptIndex !== index || typeof onSelect !== 'function') {
            return;
          }

          onSelect({
            evaluatedConcept: entry,
            index: index,
            hardenRequested: hardenCheckbox.checked,
          });
        });
      }

      container.appendChild(card);
    });
  }

  // ── Choice renderers ──────────────────────────────────────────────

  function renderChoiceButtons(choiceList) {
    return choiceList.map(function(choice, index) {
      var isExplored = Boolean(choice.nextPageId);
      var choiceText = typeof choice.text === 'string' ? choice.text : '';
      var choiceType = typeof choice.choiceType === 'string' ? choice.choiceType : '';
      var primaryDelta = typeof choice.primaryDelta === 'string' ? choice.primaryDelta : '';

      var typeIconPath = getIconPath(choiceType);
      var deltaIconPath = getIconPath(primaryDelta);
      var typeLabel = CHOICE_TYPE_LABEL_MAP[choiceType] || '';
      var deltaLabel = PRIMARY_DELTA_LABEL_MAP[primaryDelta] || '';

      var pillHtml = '';
      if (typeIconPath || deltaIconPath) {
        pillHtml = '<span class="choice-icon-pill" aria-hidden="true">';
        if (typeIconPath) {
          pillHtml += '<img class="choice-icon choice-icon--type"'
            + ' src="' + escapeHtml(typeIconPath) + '"'
            + ' alt="" title="' + escapeHtml(typeLabel) + '"'
            + ' width="32" height="32" loading="lazy"'
            + " onerror=\"this.style.display='none'\">";
        }
        if (deltaIconPath) {
          pillHtml += '<img class="choice-icon choice-icon--delta"'
            + ' src="' + escapeHtml(deltaIconPath) + '"'
            + ' alt="" title="' + escapeHtml(deltaLabel) + '"'
            + ' width="32" height="32" loading="lazy"'
            + " onerror=\"this.style.display='none'\">";
        }
        pillHtml += '</span>';
      }

      return '<div class="choice-row">'
        + pillHtml
        + '<button'
        + ' class="choice-btn"'
        + ' data-choice-index="' + index + '"'
        + ' data-choice-type="' + escapeHtml(choiceType) + '"'
        + ' data-primary-delta="' + escapeHtml(primaryDelta) + '"'
        + (isExplored ? ' data-explored="true"' : '')
        + '>'
        + '<span class="choice-text">' + escapeHtml(choiceText) + '</span>'
        + '</button>'
        + (isExplored ? '<span class="explored-marker" title="Previously explored">&#8617;</span>' : '')
        + '</div>';
    }).join('');
  }

  function renderSelectOptions(items) {
    return items.map(function(item) {
      return '<option value="' + escapeHtml(item.value) + '">' + escapeHtml(item.label) + '</option>';
    }).join('');
  }

  function renderProtagonistGuidanceAndCustomChoice(guidanceValues) {
    const safeEmotions = typeof guidanceValues.emotions === 'string'
      ? guidanceValues.emotions
      : '';
    const safeThoughts = typeof guidanceValues.thoughts === 'string'
      ? guidanceValues.thoughts
      : '';
    const safeSpeech = typeof guidanceValues.speech === 'string'
      ? guidanceValues.speech
      : '';

    return `
        <details class="protagonist-guidance">
          <summary class="protagonist-guidance__summary">Guide Your Protagonist</summary>
          <div class="protagonist-guidance__fields">
            <div class="protagonist-guidance__field">
              <label class="protagonist-guidance__label" for="guidance-emotions">Emotions</label>
              <textarea
                id="guidance-emotions"
                class="protagonist-guidance__textarea"
                name="suggestedEmotions"
                placeholder="e.g. Furious but hiding it behind a thin smile..."
                maxlength="500"
                rows="2"
              >${escapeHtml(safeEmotions)}</textarea>
            </div>
            <div class="protagonist-guidance__field">
              <label class="protagonist-guidance__label" for="guidance-thoughts">Thoughts</label>
              <textarea
                id="guidance-thoughts"
                class="protagonist-guidance__textarea"
                name="suggestedThoughts"
                placeholder="e.g. Wondering if the stranger recognized them..."
                maxlength="500"
                rows="2"
              >${escapeHtml(safeThoughts)}</textarea>
            </div>
            <div class="protagonist-guidance__field">
              <label class="protagonist-guidance__label" for="guidance-speech">Speech</label>
              <textarea
                id="guidance-speech"
                class="protagonist-guidance__textarea"
                name="suggestedSpeech"
                placeholder="e.g. 'Wake up, Alicia! We don't have much time.'"
                maxlength="500"
                rows="2"
              >${escapeHtml(safeSpeech)}</textarea>
            </div>
          </div>
        </details>
        <div class="custom-choice-container">
          <input type="text" class="custom-choice-input"
                 placeholder="Introduce your own custom choice..."
                 maxlength="500" />
          <button type="button" class="custom-choice-btn">Add</button>
        </div>
        <div class="custom-choice-enums">
          <select class="custom-choice-type">
            ${renderSelectOptions(CHOICE_TYPES)}
          </select>
          <select class="custom-choice-delta">
            ${renderSelectOptions(PRIMARY_DELTAS)}
          </select>
        </div>
        <div class="alert alert-error play-error" id="play-error" style="display: none;" role="alert" aria-live="polite"></div>
      `;
  }

  function rebuildChoicesSection(choiceList, guidanceValues, choicesEl, choicesSectionEl, bindFn) {
    choicesEl.innerHTML = renderChoiceButtons(choiceList);
    const existingGuidance = choicesSectionEl.querySelector('.protagonist-guidance');
    if (existingGuidance) {
      existingGuidance.remove();
    }
    const existingCustom = choicesSectionEl.querySelector('.custom-choice-container');
    if (existingCustom) {
      existingCustom.remove();
    }
    const existingEnums = choicesSectionEl.querySelector('.custom-choice-enums');
    if (existingEnums) {
      existingEnums.remove();
    }
    choicesEl.insertAdjacentHTML('afterend', renderProtagonistGuidanceAndCustomChoice(guidanceValues));
    bindFn();
  }

  // ── Affect renderer ──────────────────────────────────────────────

  var INTENSITY_DOT_COUNT = { mild: 1, moderate: 2, strong: 3, overwhelming: 4 };

  function renderAffectPanel(protagonistAffect, leftSidebarContainer) {
    var existingPanel = document.getElementById('affect-panel');

    if (!protagonistAffect || typeof protagonistAffect !== 'object') {
      if (existingPanel) {
        existingPanel.remove();
      }
      return;
    }

    var primaryEmotion = typeof protagonistAffect.primaryEmotion === 'string'
      ? protagonistAffect.primaryEmotion : '';
    var primaryIntensity = typeof protagonistAffect.primaryIntensity === 'string'
      ? protagonistAffect.primaryIntensity : 'mild';
    var primaryCause = typeof protagonistAffect.primaryCause === 'string'
      ? protagonistAffect.primaryCause : '';
    var secondaryEmotions = Array.isArray(protagonistAffect.secondaryEmotions)
      ? protagonistAffect.secondaryEmotions : [];
    var dominantMotivation = typeof protagonistAffect.dominantMotivation === 'string'
      ? protagonistAffect.dominantMotivation : '';

    if (!primaryEmotion) {
      if (existingPanel) {
        existingPanel.remove();
      }
      return;
    }

    var filledCount = INTENSITY_DOT_COUNT[primaryIntensity] || 1;
    var dotsHtml = '';
    for (var d = 0; d < 4; d++) {
      dotsHtml += '<span class="affect-dot' + (d < filledCount ? ' affect-dot--filled' : '') + '"></span>';
    }

    var primaryHtml = '<div class="affect-primary">'
      + '<span class="affect-emotion">' + escapeHtml(primaryEmotion) + '</span>'
      + '<div class="affect-dots" aria-label="Intensity: ' + escapeHtml(primaryIntensity) + '">'
      + dotsHtml
      + '<span class="affect-intensity-label">' + escapeHtml(primaryIntensity) + '</span>'
      + '</div>'
      + '<span class="affect-cause">' + escapeHtml(primaryCause) + '</span>'
      + '</div>';

    var secondariesHtml = '';
    if (secondaryEmotions.length > 0) {
      var pills = secondaryEmotions
        .filter(function(se) { return se && typeof se.emotion === 'string'; })
        .map(function(se) {
          var cause = typeof se.cause === 'string' ? se.cause : '';
          return '<span class="affect-pill" title="' + escapeHtml(cause) + '">'
            + escapeHtml(se.emotion) + '</span>';
        })
        .join('');
      if (pills) {
        secondariesHtml = '<div class="affect-secondaries">' + pills + '</div>';
      }
    }

    var motivationHtml = dominantMotivation
      ? '<div class="affect-motivation">' + escapeHtml(dominantMotivation) + '</div>'
      : '';

    var innerHtml = '<h3 class="affect-title" id="affect-title">Protagonist</h3>'
      + primaryHtml + secondariesHtml + motivationHtml;

    if (existingPanel) {
      existingPanel.setAttribute('data-intensity', primaryIntensity);
      existingPanel.innerHTML = innerHtml;
      return;
    }

    var panel = document.createElement('aside');
    panel.className = 'affect-panel';
    panel.id = 'affect-panel';
    panel.setAttribute('aria-labelledby', 'affect-title');
    panel.setAttribute('data-intensity', primaryIntensity);
    panel.innerHTML = innerHtml;

    // Insert at the top of left sidebar, before inventory/health
    leftSidebarContainer.insertBefore(panel, leftSidebarContainer.firstChild);
  }

// ── Analyst insights modal ───────────────────────────────────────

var OBJECTIVE_EVIDENCE_FILL = { NONE: 0, WEAK_IMPLICIT: 33, CLEAR_EXPLICIT: 100 };
var COMMITMENT_FILL = {
  NONE: 0,
  TENTATIVE: 25,
  EXPLICIT_REVERSIBLE: 60,
  EXPLICIT_IRREVERSIBLE: 100,
};
var ENTRY_READINESS_FILL = { NOT_READY: 0, PARTIAL: 50, READY: 100 };
var STRUCTURAL_POSITION_FILL = {
  WITHIN_ACTIVE_BEAT: 20,
  BRIDGING_TO_NEXT_BEAT: 60,
  CLEARLY_IN_NEXT_BEAT: 100,
};
var MOMENTUM_META = {
  STASIS: { css: 'momentum-badge--stasis', label: 'Stasis' },
  INCREMENTAL_PROGRESS: { css: 'momentum-badge--incremental', label: 'Incremental Progress' },
  MAJOR_PROGRESS: { css: 'momentum-badge--major', label: 'Major Progress' },
  REVERSAL_OR_SETBACK: { css: 'momentum-badge--reversal', label: 'Reversal' },
  SCOPE_SHIFT: { css: 'momentum-badge--scope-shift', label: 'Scope Shift' },
};
var COMPLETION_GATE_FILL = { PENDING: 0, SATISFIED: 100 };
var URGENCY_CLASS = { LOW: 'urgency-low', MEDIUM: 'urgency-medium', HIGH: 'urgency-high' };
var PAYOFF_CLASS = {
  RUSHED: 'payoff-rushed',
  ADEQUATE: 'payoff-adequate',
  WELL_EARNED: 'payoff-well-earned',
};

function parseAnalystDataFromDom() {
  var node = document.getElementById('analyst-data');
  if (!node || typeof node.textContent !== 'string') {
    return null;
  }

  try {
    var parsed = JSON.parse(node.textContent);
    return parsed && typeof parsed === 'object' ? parsed : null;
  } catch (_) {
    return null;
  }
}

function parseInsightsContextFromDom() {
  var node = document.getElementById('insights-context');
  if (!node || typeof node.textContent !== 'string') {
    return { actDisplayInfo: null, sceneSummary: null };
  }

  try {
    var parsed = JSON.parse(node.textContent);
    return parsed && typeof parsed === 'object'
      ? parsed
      : { actDisplayInfo: null, sceneSummary: null };
  } catch (_) {
    return { actDisplayInfo: null, sceneSummary: null };
  }
}

function formatAnalystEnum(value) {
  if (typeof value !== 'string' || value.length === 0) {
    return 'Unknown';
  }
  return value.toLowerCase().split('_').map(function(part) {
    return part.charAt(0).toUpperCase() + part.slice(1);
  }).join(' ');
}

function gaugeClass(fillPct) {
  if (fillPct <= 33) {
    return 'beat-gauge__fill--low';
  }
  if (fillPct <= 66) {
    return 'beat-gauge__fill--mid';
  }
  return 'beat-gauge__fill--high';
}

function renderGaugeRow(label, value, fillMap) {
  var fillPct = fillMap[value] || 0;
  return '<div class="beat-gauge__row">'
    + '<span class="beat-gauge__label">' + escapeHtml(label) + '</span>'
    + '<div class="beat-gauge__track">'
    + '<span class="beat-gauge__fill ' + gaugeClass(fillPct) + '" style="width:' + fillPct + '%"></span>'
    + '</div>'
    + '<span class="beat-gauge__level">' + escapeHtml(formatAnalystEnum(value)) + '</span>'
    + '</div>';
}

function renderPromisePayoffs(assessments, resolvedPromiseMeta) {
  if (!Array.isArray(assessments) || assessments.length === 0) {
    return '';
  }

  var metaMap = resolvedPromiseMeta && typeof resolvedPromiseMeta === 'object'
    ? resolvedPromiseMeta
    : {};

  var items = assessments.map(function(assessment) {
    var satisfaction = typeof assessment?.satisfactionLevel === 'string'
      ? assessment.satisfactionLevel
      : 'ADEQUATE';
    var payoffClass = PAYOFF_CLASS[satisfaction] || PAYOFF_CLASS.ADEQUATE;
    var description = typeof assessment?.description === 'string' ? assessment.description : '';
    var reasoning = typeof assessment?.reasoning === 'string' ? assessment.reasoning : '';
    var promiseId = typeof assessment?.promiseId === 'string' ? assessment.promiseId : '';

    var badgeHtml = '';
    var meta = promiseId ? metaMap[promiseId] : null;
    if (meta && typeof meta.promiseType === 'string' && typeof meta.urgency === 'string') {
      badgeHtml = '<span class="promise-payoff-badge">'
        + renderPromiseBadgePill(meta.promiseType, meta.urgency)
        + '</span>';
    }

    return '<li class="promise-payoff-item">'
      + badgeHtml
      + '<p class="payoff-thread-label">Promise</p>'
      + '<p class="payoff-thread-text" title="' + escapeHtml(description) + '">' + escapeHtml(description) + '</p>'
      + '<span class="payoff-satisfaction-badge payoff-satisfaction-badge--centered ' + payoffClass + '">'
      + escapeHtml(satisfaction)
      + '</span>'
      + '<p class="insights-copy payoff-reasoning">' + escapeHtml(reasoning) + '</p>'
      + '</li>';
  }).join('');

  return '<details class="insights-section" open>'
    + '<summary><h4>Promise Payoffs</h4></summary>'
    + '<ul class="payoff-list">' + items + '</ul>'
    + '</details>';
}

function renderThreadPayoffs(assessments, resolvedThreadMeta) {
  if (!Array.isArray(assessments) || assessments.length === 0) {
    return '';
  }

  var metaMap = resolvedThreadMeta && typeof resolvedThreadMeta === 'object'
    ? resolvedThreadMeta
    : {};

  var items = assessments.map(function(assessment) {
    var satisfaction = typeof assessment?.satisfactionLevel === 'string'
      ? assessment.satisfactionLevel
      : 'ADEQUATE';
    var payoffClass = PAYOFF_CLASS[satisfaction] || PAYOFF_CLASS.ADEQUATE;
    var threadText = typeof assessment?.threadText === 'string' ? assessment.threadText : '';
    var reasoning = typeof assessment?.reasoning === 'string' ? assessment.reasoning : '';
    var threadId = typeof assessment?.threadId === 'string' ? assessment.threadId : '';

    var badgeHtml = '';
    var meta = threadId ? metaMap[threadId] : null;
    if (meta && typeof meta.threadType === 'string' && typeof meta.urgency === 'string') {
      badgeHtml = '<span class="payoff-thread-badge">'
        + renderThreadBadgePill(meta.threadType, meta.urgency)
        + '</span>';
    }

    return '<li class="payoff-item">'
      + badgeHtml
      + '<p class="payoff-thread-label">Thread</p>'
      + '<p class="payoff-thread-text" title="' + escapeHtml(threadText) + '">' + escapeHtml(threadText) + '</p>'
      + '<span class="payoff-satisfaction-badge payoff-satisfaction-badge--centered ' + payoffClass + '">'
      + escapeHtml(satisfaction)
      + '</span>'
      + '<p class="insights-copy payoff-reasoning">' + escapeHtml(reasoning) + '</p>'
      + '</li>';
  }).join('');

  return '<details class="insights-section" open>'
    + '<summary><h4>Thread Payoffs</h4></summary>'
    + '<ul class="payoff-list">' + items + '</ul>'
    + '</details>';
}

function renderInsightsBody(analystResult, context) {
  if (!analystResult || typeof analystResult !== 'object') {
    return '<p class="insights-copy">No analyst insights are available for this page yet.</p>';
  }

  var ctx = context && typeof context === 'object' ? context : {};
  var headerHtml = '';

  if (typeof ctx.actDisplayInfo === 'string' && ctx.actDisplayInfo.length > 0) {
    headerHtml += '<p class="insights-beat-subtitle">' + escapeHtml(ctx.actDisplayInfo) + '</p>';
  }

  if (typeof ctx.sceneSummary === 'string' && ctx.sceneSummary.length > 0) {
    headerHtml += '<p class="insights-scene-summary">' + escapeHtml(ctx.sceneSummary) + '</p>';
  }

  var momentum = MOMENTUM_META[analystResult.sceneMomentum] || MOMENTUM_META.STASIS;
  var completionGateSatisfied = analystResult.completionGateSatisfied === true;
  var completionGateReason = typeof analystResult.completionGateFailureReason === 'string'
    ? analystResult.completionGateFailureReason
    : '';
  var completionGateValue = completionGateSatisfied ? 'SATISFIED' : 'PENDING';

  var pacingHtml = '';
  if (analystResult.pacingIssueDetected === true) {
    pacingHtml = '<details class="pacing-alert" open role="status">'
      + '<summary><h4>Pacing Alert</h4></summary>'
      + '<p class="insights-copy">' + escapeHtml(analystResult.pacingIssueReason || '') + '</p>'
      + '<span class="insights-chip">Recommended: '
      + escapeHtml(formatAnalystEnum(analystResult.recommendedAction))
      + '</span>'
      + '</details>';
  }

  var toneHtml = '';
  if (analystResult.toneAdherent === false) {
    toneHtml = '<details class="tone-warning" open role="status">'
      + '<summary><h4>Tone Warning</h4></summary>'
      + '<p class="insights-copy">' + escapeHtml(analystResult.toneDriftDescription || '') + '</p>'
      + '</details>';
  }

  return headerHtml
    + '<details class="insights-section" open>'
    + '<summary><h4>Beat Progress</h4></summary>'
    + '<div class="beat-gauge">'
    + renderGaugeRow('Objective Evidence', analystResult.objectiveEvidenceStrength, OBJECTIVE_EVIDENCE_FILL)
    + renderGaugeRow('Commitment', analystResult.commitmentStrength, COMMITMENT_FILL)
    + renderGaugeRow('Entry Readiness', analystResult.entryConditionReadiness, ENTRY_READINESS_FILL)
    + renderGaugeRow('Structural Position', analystResult.structuralPositionSignal, STRUCTURAL_POSITION_FILL)
    + renderGaugeRow('Completion Gate', completionGateValue, COMPLETION_GATE_FILL)
    + '</div>'
    + (completionGateReason
      ? '<p class="completion-gate-reason">' + escapeHtml(completionGateReason) + '</p>'
      : '')
    + '</details>'
    + '<details class="insights-section" open>'
    + '<summary><h4>Momentum</h4></summary>'
    + '<span class="momentum-badge ' + momentum.css + '">' + escapeHtml(momentum.label) + '</span>'
    + '</details>'
    + pacingHtml
    + renderPromisePayoffs(analystResult.promisePayoffAssessments, ctx.resolvedPromiseMeta || {})
    + renderThreadPayoffs(analystResult.threadPayoffAssessments, ctx.resolvedThreadMeta || {})
    + toneHtml;
}

function createInsightsButton() {
  var button = document.createElement('button');
  button.type = 'button';
  button.className = 'insights-btn';
  button.id = 'insights-btn';
  button.setAttribute('aria-haspopup', 'dialog');
  button.setAttribute('aria-controls', 'insights-modal');
  button.innerHTML = '<span class="insights-btn__icon" aria-hidden="true">🔍</span>'
    + '<span class="insights-btn__label">Story Insights</span>';
  return button;
}

function createAnalystInsightsController(initialAnalystResult, initialContext) {
  var analystResult = initialAnalystResult && typeof initialAnalystResult === 'object'
    ? initialAnalystResult
    : null;
  var insightsContext = initialContext && typeof initialContext === 'object'
    ? initialContext
    : { actDisplayInfo: null, sceneSummary: null };
  var modal = document.getElementById('insights-modal');
  var modalBody = document.getElementById('insights-modal-body');
  var closeButton = document.getElementById('insights-close-btn');
  var headerActions = document.getElementById('story-header-actions');
  var button = document.getElementById('insights-btn');

  if (!modal || !modalBody || !closeButton || !headerActions) {
    return {
      update: function() {},
    };
  }

  if (!button) {
    button = createInsightsButton();
    headerActions.insertBefore(button, headerActions.firstChild);
  }

  function closeModal() {
    modal.style.display = 'none';
  }

  function openModal() {
    if (!analystResult) {
      return;
    }
    modal.style.display = 'flex';
  }

  function render() {
    modalBody.innerHTML = renderInsightsBody(analystResult, insightsContext);
    button.style.display = analystResult ? 'inline-flex' : 'none';
    if (!analystResult) {
      closeModal();
    }
  }

  button.addEventListener('click', openModal);
  closeButton.addEventListener('click', closeModal);
  modal.addEventListener('click', function(event) {
    if (event.target === modal) {
      closeModal();
    }
  });
  document.addEventListener('keydown', function(event) {
    if (event.key === 'Escape') {
      closeModal();
    }
  });

  render();

  return {
    update: function(nextAnalystResult, nextContext) {
      analystResult =
        nextAnalystResult && typeof nextAnalystResult === 'object' ? nextAnalystResult : null;
      if (nextContext && typeof nextContext === 'object') {
        insightsContext = nextContext;
      }
      render();
    },
  };
}

// ── Story lore modal ─────────────────────────────────────────────

function extractWorldFactText(fact) {
  if (typeof fact === 'string') {
    return fact.length > 0 ? fact : null;
  }
  if (fact && typeof fact === 'object' && typeof fact.text === 'string' && fact.text.length > 0) {
    return fact.text;
  }
  return null;
}

function parseLoreDataFromDom() {
  var node = document.getElementById('lore-data');
  if (!node || typeof node.textContent !== 'string') {
    return { worldFacts: [], characterCanon: {} };
  }

  try {
    var parsed = JSON.parse(node.textContent);
    if (!parsed || typeof parsed !== 'object') {
      return { worldFacts: [], characterCanon: {} };
    }

    var worldFacts = Array.isArray(parsed.worldFacts)
      ? parsed.worldFacts.map(extractWorldFactText).filter(Boolean)
      : [];
    var characterCanon = parsed.characterCanon && typeof parsed.characterCanon === 'object'
      ? parsed.characterCanon
      : {};

    return { worldFacts: worldFacts, characterCanon: characterCanon };
  } catch (_) {
    return { worldFacts: [], characterCanon: {} };
  }
}

function normalizeCharacterCanon(characterCanon) {
  if (!characterCanon || typeof characterCanon !== 'object') {
    return {};
  }

  var normalized = {};
  Object.keys(characterCanon).forEach(function(characterName) {
    var facts = characterCanon[characterName];
    if (!Array.isArray(facts)) {
      return;
    }

    var validFacts = facts.filter(function(fact) {
      return typeof fact === 'string' && fact.length > 0;
    });
    if (validFacts.length > 0) {
      normalized[characterName] = validFacts;
    }
  });

  return normalized;
}

function renderLoreWorldPanel(worldFacts) {
  if (!Array.isArray(worldFacts) || worldFacts.length === 0) {
    return '<p class="lore-empty">No world facts established yet.</p>';
  }

  var list = worldFacts
    .map(function(fact) {
      return '<li>' + escapeHtml(fact) + '</li>';
    })
    .join('');
  return '<ul class="lore-world-list">' + list + '</ul>';
}

function renderLoreCharactersPanel(characterCanon) {
  var characterNames = Object.keys(characterCanon);
  if (characterNames.length === 0) {
    return '<p class="lore-empty">No character facts established yet.</p>';
  }

  return characterNames
    .map(function(characterName) {
      var facts = characterCanon[characterName];
      var factList = facts
        .map(function(fact) {
          return '<li>' + escapeHtml(fact) + '</li>';
        })
        .join('');

      return '<div class="lore-character-card">'
        + '<button type="button" class="lore-character-name" aria-expanded="false">'
        + escapeHtml(characterName)
        + '</button>'
        + '<ul class="lore-character-facts" style="display: none;">'
        + factList
        + '</ul>'
        + '</div>';
    })
    .join('');
}

function createLoreModalController(initialData) {
  var modal = document.getElementById('lore-modal');
  var triggerButton = document.getElementById('lore-trigger-btn');
  var closeButton = document.getElementById('lore-close-btn');
  var worldPanel = document.getElementById('lore-panel-world');
  var charactersPanel = document.getElementById('lore-panel-characters');
  var worldTab = document.getElementById('lore-tab-world');
  var charactersTab = document.getElementById('lore-tab-characters');
  var countBadge = document.getElementById('lore-count-badge');
  var leftSidebar = document.getElementById('left-sidebar-widgets');

  if (
    !modal
    || !triggerButton
    || !closeButton
    || !worldPanel
    || !charactersPanel
    || !worldTab
    || !charactersTab
    || !countBadge
    || !leftSidebar
  ) {
    return {
      update: function() {},
    };
  }

  function keepTriggerAtBottom() {
    leftSidebar.appendChild(triggerButton);
  }

  function closeModal() {
    modal.style.display = 'none';
  }

  function openModal() {
    modal.style.display = 'flex';
  }

  function activateTab(tabName) {
    var isWorld = tabName === 'world';

    worldTab.classList.toggle('lore-tab--active', isWorld);
    worldTab.setAttribute('aria-selected', isWorld ? 'true' : 'false');
    worldPanel.style.display = isWorld ? '' : 'none';

    charactersTab.classList.toggle('lore-tab--active', !isWorld);
    charactersTab.setAttribute('aria-selected', isWorld ? 'false' : 'true');
    charactersPanel.style.display = isWorld ? 'none' : '';
  }

  function bindCharacterToggles() {
    var names = charactersPanel.querySelectorAll('.lore-character-name');
    names.forEach(function(nameButton) {
      nameButton.addEventListener('click', function() {
        var card = nameButton.closest('.lore-character-card');
        if (!card) {
          return;
        }

        var factsList = card.querySelector('.lore-character-facts');
        if (!factsList) {
          return;
        }

        var expanded = card.classList.toggle('lore-character-card--expanded');
        nameButton.setAttribute('aria-expanded', expanded ? 'true' : 'false');
        factsList.style.display = expanded ? 'block' : 'none';
      });
    });
  }

  function renderLore(worldFactsInput, characterCanonInput) {
    var worldFacts = Array.isArray(worldFactsInput)
      ? worldFactsInput.map(extractWorldFactText).filter(Boolean)
      : [];
    var characterCanon = normalizeCharacterCanon(characterCanonInput);

    worldPanel.innerHTML = renderLoreWorldPanel(worldFacts);
    charactersPanel.innerHTML = renderLoreCharactersPanel(characterCanon);
    bindCharacterToggles();

    var characterFactCount = Object.values(characterCanon).reduce(function(total, facts) {
      return total + facts.length;
    }, 0);
    countBadge.textContent = '(' + (worldFacts.length + characterFactCount) + ')';
    keepTriggerAtBottom();
  }

  triggerButton.addEventListener('click', openModal);
  closeButton.addEventListener('click', closeModal);
  worldTab.addEventListener('click', function() {
    activateTab('world');
  });
  charactersTab.addEventListener('click', function() {
    activateTab('characters');
  });
  modal.addEventListener('click', function(event) {
    if (event.target === modal) {
      closeModal();
    }
  });
  document.addEventListener('keydown', function(event) {
    if (event.key === 'Escape') {
      closeModal();
    }
  });

  activateTab('world');
  renderLore(initialData.worldFacts, initialData.characterCanon);

  return {
    update: function(worldFacts, characterCanon) {
      renderLore(worldFacts, characterCanon);
    },
  };
}

// ── Story recap modal ────────────────────────────────────────────

function parseRecapDataFromDom() {
  var node = document.getElementById('recap-data');
  if (!node || typeof node.textContent !== 'string') {
    return [];
  }

  try {
    var parsed = JSON.parse(node.textContent);
    if (!Array.isArray(parsed)) {
      return [];
    }

    return parsed.filter(function(entry) {
      return entry
        && typeof entry === 'object'
        && typeof entry.pageId === 'number'
        && Number.isInteger(entry.pageId)
        && entry.pageId >= 1
        && typeof entry.summary === 'string';
    });
  } catch (_) {
    return [];
  }
}

function createRecapModalController(initialData) {
  var modal = document.getElementById('recap-modal');
  var triggerButton = document.getElementById('recap-btn');
  var closeButton = document.getElementById('recap-close-btn');
  var modalBody = document.getElementById('recap-modal-body');
  var entries = Array.isArray(initialData) ? initialData : [];

  if (!modal || !triggerButton || !closeButton || !modalBody) {
    return {
      update: function() {},
    };
  }

  function closeModal() {
    modal.style.display = 'none';
  }

  function openModal() {
    modal.style.display = 'flex';
  }

  function renderRecapBody() {
    if (!Array.isArray(entries) || entries.length === 0) {
      modalBody.innerHTML = '<p class="recap-empty">No scenes recorded yet.</p>';
      return;
    }

    modalBody.innerHTML = entries.map(function(entry, index) {
      var sceneLabel = 'Scene ' + String(index + 1);
      return '<article class="recap-entry">'
        + '<span class="recap-page-label">' + escapeHtml(sceneLabel) + '</span>'
        + '<p class="recap-summary">' + escapeHtml(entry.summary) + '</p>'
        + '</article>';
    }).join('');
  }

  triggerButton.addEventListener('click', openModal);
  closeButton.addEventListener('click', closeModal);
  modal.addEventListener('click', function(event) {
    if (event.target === modal) {
      closeModal();
    }
  });
  document.addEventListener('keydown', function(event) {
    if (event.key === 'Escape') {
      closeModal();
    }
  });

  renderRecapBody();

  return {
    update: function(nextEntries) {
      entries = Array.isArray(nextEntries) ? nextEntries : [];
      renderRecapBody();
    },
  };
}

  // ── NPC Relationship renderer ────────────────────────────────────

  function renderNpcRelationshipCard(rel) {
    if (!rel || typeof rel !== 'object') {
      return '';
    }

    var npcName = typeof rel.npcName === 'string' ? rel.npcName : '';
    var dynamic = typeof rel.dynamic === 'string' ? rel.dynamic : '';
    var valence = typeof rel.valence === 'number' ? rel.valence : 0;
    var history = typeof rel.history === 'string' ? rel.history : '';
    var currentTension = typeof rel.currentTension === 'string' ? rel.currentTension : '';
    var leverage = typeof rel.leverage === 'string' ? rel.leverage : '';

    if (!npcName) {
      return '';
    }

    var valencePercent = ((valence + 5) / 10) * 100;
    if (valencePercent < 0) valencePercent = 0;
    if (valencePercent > 100) valencePercent = 100;

    var html = '<div class="npc-rel-card" data-npc="' + escapeHtml(npcName) + '">';
    html += '<div class="npc-rel-header">';
    html += '<span class="npc-rel-name">' + escapeHtml(npcName) + '</span>';
    html += '<span class="npc-rel-dynamic-pill" title="' + escapeHtml(dynamic) + '">' + escapeHtml(dynamic) + '</span>';
    html += '</div>';
    html += '<div class="npc-rel-gauge">';
    html += '<div class="npc-rel-gauge-bar">';
    html += '<span class="npc-rel-gauge-marker" style="left: ' + valencePercent + '%"></span>';
    html += '</div>';
    html += '</div>';
    html += '<div class="npc-rel-details" style="display: none;">';
    if (history) {
      html += '<p class="npc-rel-detail"><strong>History:</strong> ' + escapeHtml(history) + '</p>';
    }
    if (currentTension) {
      html += '<p class="npc-rel-detail"><strong>Tension:</strong> ' + escapeHtml(currentTension) + '</p>';
    }
    if (leverage) {
      html += '<p class="npc-rel-detail"><strong>Leverage:</strong> ' + escapeHtml(leverage) + '</p>';
    }
    html += '</div>';
    html += '</div>';
    return html;
  }

  function bindNpcRelationshipCardToggles(panel) {
    if (!panel) {
      return;
    }
    var cards = panel.querySelectorAll('.npc-rel-card');
    cards.forEach(function(card) {
      var header = card.querySelector('.npc-rel-header');
      var details = card.querySelector('.npc-rel-details');
      if (!header || !details) {
        return;
      }
      header.addEventListener('click', function() {
        var isHidden = details.style.display === 'none';
        details.style.display = isHidden ? 'block' : 'none';
      });
    });
  }

  function renderNpcRelationshipsPanel(relationships, leftSidebarContainer) {
    var existingPanel = document.getElementById('npc-relationships-panel');

    if (!Array.isArray(relationships) || relationships.length === 0) {
      if (existingPanel) {
        existingPanel.remove();
      }
      return;
    }

    var cardsHtml = relationships.map(function(rel) {
      return renderNpcRelationshipCard(rel);
    }).join('');

    if (!cardsHtml) {
      if (existingPanel) {
        existingPanel.remove();
      }
      return;
    }

    if (existingPanel) {
      var content = existingPanel.querySelector('#npc-relationships-content');
      if (content) {
        content.innerHTML = cardsHtml;
      }
      bindNpcRelationshipCardToggles(existingPanel);
      return;
    }

    var panel = document.createElement('aside');
    panel.className = 'npc-relationships-panel';
    panel.id = 'npc-relationships-panel';
    panel.setAttribute('aria-labelledby', 'npc-relationships-title');
    panel.innerHTML = '<h3 class="npc-relationships-title" id="npc-relationships-title">NPC Relationships</h3>'
      + '<div class="npc-relationships-content" id="npc-relationships-content">'
      + cardsHtml
      + '</div>';

    // Insert after affect panel, before inventory panel
    var affectPanel = leftSidebarContainer.querySelector('#affect-panel');
    var inventoryPanel = leftSidebarContainer.querySelector('#inventory-panel');
    if (affectPanel && affectPanel.nextSibling) {
      leftSidebarContainer.insertBefore(panel, affectPanel.nextSibling);
    } else if (inventoryPanel) {
      leftSidebarContainer.insertBefore(panel, inventoryPanel);
    } else {
      leftSidebarContainer.appendChild(panel);
    }

    bindNpcRelationshipCardToggles(panel);
  }

  // ── State renderers ───────────────────────────────────────────────

  function renderStateChanges(changes, narrativeElement) {
    let stateChangesElement = document.getElementById('state-changes');

    if (Array.isArray(changes) && changes.length > 0) {
      const items = changes.map((change) => `<li>${escapeHtml(change)}</li>`).join('');
      const stateHtml = `<h4>What happened:</h4><ul>${items}</ul>`;

      if (stateChangesElement) {
        stateChangesElement.innerHTML = stateHtml;
        stateChangesElement.style.display = 'block';
      } else {
        stateChangesElement = document.createElement('aside');
        stateChangesElement.className = 'state-changes';
        stateChangesElement.id = 'state-changes';
        stateChangesElement.innerHTML = stateHtml;
        narrativeElement.after(stateChangesElement);
      }
    } else if (stateChangesElement) {
      stateChangesElement.style.display = 'none';
      stateChangesElement.innerHTML = '';
    }
  }

  function renderDeviationBanner(deviationInfo, choicesSectionEl) {
    const existingBanner = document.getElementById('deviation-banner');
    if (existingBanner) {
      existingBanner.remove();
    }

    if (!deviationInfo || !deviationInfo.detected) {
      return;
    }

    const beatsText = deviationInfo.beatsInvalidated
      ? ` (${deviationInfo.beatsInvalidated} story beat${deviationInfo.beatsInvalidated > 1 ? 's' : ''} replanned)`
      : '';

    const banner = document.createElement('aside');
    banner.className = 'deviation-banner';
    banner.id = 'deviation-banner';
    banner.innerHTML = `
        <div class="deviation-icon">&#x1F504;</div>
        <div class="deviation-content">
          <h4>Story Path Shifted</h4>
          <p>${escapeHtml(deviationInfo.reason)}${beatsText}</p>
        </div>
      `;

    if (choicesSectionEl) {
      choicesSectionEl.parentNode.insertBefore(banner, choicesSectionEl);
    }
  }

  function renderMilestoneBanner(milestoneInfo, narrativeElement) {
    var existingBanner = document.getElementById('milestone-banner');
    if (existingBanner) {
      existingBanner.remove();
    }

    if (!milestoneInfo) {
      return;
    }

    var banner = document.createElement('div');
    banner.className = 'milestone-banner milestone-banner--' + milestoneInfo.type;
    banner.id = 'milestone-banner';

    if (milestoneInfo.type === 'act') {
      banner.innerHTML =
        '<div class="milestone-banner__act-title">Act ' + milestoneInfo.actNumber + ' Complete</div>'
        + '<div class="milestone-banner__act-name">' + escapeHtml(milestoneInfo.actName || '') + '</div>';
    } else {
      banner.innerHTML =
        '<div class="milestone-banner__beat-label">Beat Concluded</div>'
        + '<div class="milestone-banner__beat-name">' + escapeHtml(milestoneInfo.beatName || '') + '</div>';
    }

    narrativeElement.after(banner);
  }


  // ── Error display ─────────────────────────────────────────────────

  function showPlayError(message, choicesSectionEl) {
    var errorBlock = choicesSectionEl.querySelector('#play-error');
    if (!errorBlock) {
      errorBlock = document.createElement('div');
      errorBlock.className = 'alert alert-error play-error';
      errorBlock.id = 'play-error';
      errorBlock.setAttribute('role', 'alert');
      errorBlock.setAttribute('aria-live', 'polite');
      const customChoiceEnums = choicesSectionEl.querySelector('.custom-choice-enums');
      if (customChoiceEnums) {
        customChoiceEnums.insertAdjacentElement('afterend', errorBlock);
      } else {
        choicesSectionEl.appendChild(errorBlock);
      }
    }

    errorBlock.textContent = message;
    errorBlock.style.display = 'block';
  }

  function clearPlayError(choicesSectionEl) {
    var errorBlock = choicesSectionEl.querySelector('#play-error');
    if (!errorBlock) {
      return;
    }

    errorBlock.textContent = '';
    errorBlock.style.display = 'none';
  }

  function showFormError(message) {
    let errorDiv = document.querySelector('.alert-error');
    if (!errorDiv) {
      errorDiv = document.createElement('div');
      errorDiv.className = 'alert alert-error';
      const form = document.querySelector('.story-form');
      if (form && form.parentNode) {
        form.parentNode.insertBefore(errorDiv, form);
      }
    }
    errorDiv.textContent = message;
    errorDiv.style.display = 'block';
  }


  // ── NPC manager ───────────────────────────────────────────────────

  function collectNpcEntries() {
    var entries = document.querySelectorAll('#npc-entries .npc-entry');
    var npcs = [];
    entries.forEach(function(entry) {
      var name = entry.querySelector('.npc-entry-header strong');
      var desc = entry.querySelector('.npc-entry-description');
      if (name && desc) {
        npcs.push({ name: name.textContent, description: desc.textContent });
      }
    });
    return npcs;
  }

  function addNpcEntry(name, description) {
    var container = document.getElementById('npc-entries');
    if (!container) return;

    var entry = document.createElement('div');
    entry.className = 'npc-entry';

    var header = document.createElement('div');
    header.className = 'npc-entry-header';

    var strong = document.createElement('strong');
    strong.textContent = name;

    var removeBtn = document.createElement('button');
    removeBtn.type = 'button';
    removeBtn.className = 'btn btn-small btn-danger npc-remove-btn';
    removeBtn.textContent = '\u00D7';
    removeBtn.addEventListener('click', function() {
      entry.remove();
    });

    header.appendChild(strong);
    header.appendChild(removeBtn);

    var descP = document.createElement('p');
    descP.className = 'npc-entry-description';
    descP.textContent = description;

    entry.appendChild(header);
    entry.appendChild(descP);
    container.appendChild(entry);
  }

  function initNpcControls() {
    var addBtn = document.getElementById('npc-add-btn');
    var nameInput = document.getElementById('npc-name-input');
    var descInput = document.getElementById('npc-desc-input');

    if (!addBtn || !nameInput || !descInput) return;

    addBtn.addEventListener('click', function() {
      var name = nameInput.value.trim();
      var desc = descInput.value.trim();
      if (!name || !desc) return;

      addNpcEntry(name, desc);
      nameInput.value = '';
      descInput.value = '';
      nameInput.focus();
    });

    // Bind remove buttons for server-rendered entries (validation error re-render)
    document.querySelectorAll('.npc-remove-btn').forEach(function(btn) {
      btn.addEventListener('click', function() {
        var entry = btn.closest('.npc-entry');
        if (entry) entry.remove();
      });
    });
  }


  // ── Controllers ───────────────────────────────────────────────────

  function initPlayPage() {
    const container = document.querySelector('.play-container');
    if (!container) {
      return;
    }

    const storyId = container.dataset.storyId;
    let currentPageId = Number.parseInt(container.dataset.pageId || '1', 10);
    if (!Number.isFinite(currentPageId) || currentPageId < 1) {
      currentPageId = 1;
    }

    const choicesSection = document.getElementById('choices-section');
    const choices = document.getElementById('choices');
    const narrative = document.getElementById('narrative');
    const loading = document.getElementById('loading');
    const apiKeyModal = document.getElementById('api-key-modal');
    const initialInsightsContext = parseInsightsContextFromDom();
    const insightsController = createAnalystInsightsController(parseAnalystDataFromDom(), initialInsightsContext);
    const recapController = createRecapModalController(parseRecapDataFromDom());
    const loreController = createLoreModalController(parseLoreDataFromDom());

    if (!storyId || !narrative || !loading || !apiKeyModal) {
      return;
    }

    var initialRelPanel = document.getElementById('npc-relationships-panel');
    if (initialRelPanel) {
      bindNpcRelationshipCardToggles(initialRelPanel);
    }

    var previousActNumber = null;
    var initialActIndicator = document.getElementById('act-indicator');
    if (initialActIndicator) {
      var initialWrapper = document.getElementById('act-indicator-wrapper');
      if (initialWrapper) {
        previousActNumber = Number(initialWrapper.dataset.actNumber || '0') || null;
      }
    }
    initActIndicator();

    const hasChoicesUi = choicesSection instanceof HTMLElement && choices instanceof HTMLElement;
    const loadingProgress = createLoadingProgressController(loading);

    function ensureApiKey() {
      return new Promise((resolve, reject) => {
        const key = getApiKey();
        if (key) {
          resolve(key);
          return;
        }

        const form = document.getElementById('api-key-form');
        const input = document.getElementById('modal-api-key');

        if (!(form instanceof HTMLFormElement) || !input) {
          reject(new Error('API key prompt is unavailable.'));
          return;
        }

        apiKeyModal.style.display = 'flex';

        const handleSubmit = (event) => {
          event.preventDefault();
          const newKey = input.value.trim();
          if (newKey.length < 10) {
            alert('Please enter a valid API key');
            return;
          }

          form.removeEventListener('submit', handleSubmit);
          setApiKey(newKey);
          apiKeyModal.style.display = 'none';
          resolve(newKey);
        };

        form.addEventListener('submit', handleSubmit);
      });
    }

    function getProtagonistGuidanceValues() {
      if (!choicesSection) {
        return { emotions: '', thoughts: '', speech: '' };
      }

      const emotionsEl = choicesSection.querySelector('#guidance-emotions');
      const thoughtsEl = choicesSection.querySelector('#guidance-thoughts');
      const speechEl = choicesSection.querySelector('#guidance-speech');

      return {
        emotions: emotionsEl instanceof HTMLTextAreaElement ? emotionsEl.value : '',
        thoughts: thoughtsEl instanceof HTMLTextAreaElement ? thoughtsEl.value : '',
        speech: speechEl instanceof HTMLTextAreaElement ? speechEl.value : '',
      };
    }

    function setChoicesDisabled(disabled) {
      if (!choices) {
        return;
      }
      const allButtons = choices.querySelectorAll('.choice-btn');
      allButtons.forEach((button) => {
        button.disabled = disabled;
      });
    }

    function handleCustomChoiceSubmit() {
      if (!choicesSection || !choices) {
        return;
      }
      const input = choicesSection.querySelector('.custom-choice-input');
      if (!input) return;

      const text = input.value.trim();
      if (!text) return;
      clearPlayError(choicesSection);

      const addBtn = choicesSection.querySelector('.custom-choice-btn');
      if (addBtn) addBtn.disabled = true;
      input.disabled = true;

      const choiceTypeSelect = choicesSection.querySelector('.custom-choice-type');
      const primaryDeltaSelect = choicesSection.querySelector('.custom-choice-delta');
      const choiceType = choiceTypeSelect ? choiceTypeSelect.value : 'TACTICAL_APPROACH';
      const primaryDelta = primaryDeltaSelect ? primaryDeltaSelect.value : 'GOAL_SHIFT';

      fetch(`/play/${storyId}/custom-choice`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ pageId: currentPageId, choiceText: text, choiceType: choiceType, primaryDelta: primaryDelta }),
      })
        .then(function(response) {
          return response.json().then(function(data) {
            if (!response.ok) {
              throw new Error(data.error || 'Failed to add custom choice');
            }
            return data;
          });
        })
        .then(function(data) {
          rebuildChoicesSection(
            data.choices,
            getProtagonistGuidanceValues(),
            choices,
            choicesSection,
            bindCustomChoiceEvents
          );
        })
        .catch(function(error) {
          showPlayError(error instanceof Error ? error.message : 'Failed to add custom choice', choicesSection);
          if (addBtn) addBtn.disabled = false;
          if (input) input.disabled = false;
        });
    }

    function bindCustomChoiceEvents() {
      if (!choicesSection) {
        return;
      }
      const addBtn = choicesSection.querySelector('.custom-choice-btn');
      const input = choicesSection.querySelector('.custom-choice-input');

      if (addBtn) {
        addBtn.addEventListener('click', handleCustomChoiceSubmit);
      }
      if (input) {
        input.addEventListener('keydown', function(e) {
          if (e.key === 'Enter') {
            e.preventDefault();
            handleCustomChoiceSubmit();
          }
        });
      }
    }

    if (hasChoicesUi) {
      // Bind events for the initial custom choice input rendered by the server
      bindCustomChoiceEvents();
    }

    if (hasChoicesUi) {
      choices.addEventListener('click', async (event) => {
        const clickedElement = event.target;
        if (!(clickedElement instanceof HTMLElement)) {
          return;
        }

        const button = clickedElement.closest('.choice-btn');
        if (!button || button.disabled) {
          return;
        }

        const choiceIndex = Number.parseInt(button.dataset.choiceIndex || '', 10);
        if (!Number.isFinite(choiceIndex) || choiceIndex < 0) {
          return;
        }

        try {
          clearPlayError(choicesSection);
          const isExplored = button.dataset.explored === 'true';
          const apiKey = isExplored ? getApiKey() : await ensureApiKey();

        setChoicesDisabled(true);
        loading.style.display = 'flex';

        const body = {
          pageId: currentPageId,
          choiceIndex,
          progressId: createProgressId(),
        };
        const guidanceValues = getProtagonistGuidanceValues();
        const protagonistGuidance = {};
        if (guidanceValues.emotions.trim().length > 0) {
          protagonistGuidance.suggestedEmotions = guidanceValues.emotions.trim();
        }
        if (guidanceValues.thoughts.trim().length > 0) {
          protagonistGuidance.suggestedThoughts = guidanceValues.thoughts.trim();
        }
        if (guidanceValues.speech.trim().length > 0) {
          protagonistGuidance.suggestedSpeech = guidanceValues.speech.trim();
        }
        if (Object.keys(protagonistGuidance).length > 0) {
          body.protagonistGuidance = protagonistGuidance;
        }
        if (apiKey) {
          body.apiKey = apiKey;
        }
        loadingProgress.start(body.progressId);

        const response = await fetch(`/play/${storyId}/choice`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(body),
        });

        const data = await response.json();

        if (!response.ok) {
          // Log enhanced error details if available
          if (data.code) {
            console.error('Error code:', data.code, '| Retryable:', data.retryable);
          }
          if (data.debug) {
            console.error('Debug info:', data.debug);
          }
          throw new Error(data.error || 'Failed to process choice');
        }

        if (!data.page) {
          throw new Error('Invalid response from server');
        }
        insightsController.update(data.page.analystResult, {
          actDisplayInfo: data.actDisplayInfo ? data.actDisplayInfo.displayString : null,
          sceneSummary: data.page.sceneSummary || null,
          resolvedThreadMeta: data.page.resolvedThreadMeta || {},
          resolvedPromiseMeta: data.page.resolvedPromiseMeta || {},
        });
        recapController.update(data.recapSummaries || []);

        currentPageId = data.page.id;
        container.dataset.pageId = String(currentPageId);

        history.pushState({}, '', `/play/${storyId}?page=${currentPageId}`);

        narrative.innerHTML = `<div class="narrative-text">${escapeHtmlWithBreaks(data.page.narrativeText || '')}</div>`;
        var leftSidebarContainer = ensureLeftSidebarContainer();
        renderAffectPanel(data.page.protagonistAffect, leftSidebarContainer);
        renderNpcRelationshipsPanel(data.page.npcRelationships, leftSidebarContainer);
        renderInventoryPanel(data.page.inventory, data.page.inventoryOverflowSummary, leftSidebarContainer);
        renderHealthPanel(data.page.health, data.page.healthOverflowSummary, leftSidebarContainer);
        cleanupEmptyLeftSidebar();
        loreController.update(data.globalCanon || [], data.globalCharacterCanon || {});
        var sidebarContainer = ensureSidebarContainer();
        renderOpenThreadsPanel(data.page.openThreads, data.page.openThreadOverflowSummary, sidebarContainer);
        renderActiveThreatsPanel(data.page.activeThreats, data.page.threatsOverflowSummary, sidebarContainer);
        renderActiveConstraintsPanel(data.page.activeConstraints, data.page.constraintsOverflowSummary, sidebarContainer);
        renderTrackedPromisesPanel(data.page.trackedPromises, data.page.trackedPromisesOverflowSummary, sidebarContainer);
        cleanupEmptySidebar();
        renderStateChanges(data.page.stateChanges, narrative);
        renderMilestoneBanner(data.milestoneInfo, narrative);
        renderDeviationBanner(data.deviationInfo, choicesSection);

        const pageIndicator = document.querySelector('.page-indicator');
        if (pageIndicator) {
          pageIndicator.textContent = `Page ${currentPageId}`;
        }

        // Update act indicator based on response
        var existingWrapper = document.getElementById('act-indicator-wrapper');
        if (data.actDisplayInfo) {
          var newActNumber = data.actDisplayInfo.actNumber;
          var actChanged = previousActNumber !== null && newActNumber !== previousActNumber;

          var detailsHtml = '';
          if (data.actDisplayInfo.actObjective || data.actDisplayInfo.actStakes || data.actDisplayInfo.beatObjective) {
            detailsHtml = '<div class="act-structure-details" id="act-structure-details" hidden>';
            if (data.actDisplayInfo.actObjective) {
              detailsHtml += '<div class="act-structure-details__item">'
                + '<span class="act-structure-details__label">Act Objective</span>'
                + '<span class="act-structure-details__text">' + escapeHtml(data.actDisplayInfo.actObjective) + '</span>'
                + '</div>';
            }
            if (data.actDisplayInfo.actStakes) {
              detailsHtml += '<div class="act-structure-details__item">'
                + '<span class="act-structure-details__label">Stakes</span>'
                + '<span class="act-structure-details__text">' + escapeHtml(data.actDisplayInfo.actStakes) + '</span>'
                + '</div>';
            }
            if (data.actDisplayInfo.beatObjective) {
              detailsHtml += '<div class="act-structure-details__item">'
                + '<span class="act-structure-details__label">Beat Objective</span>'
                + '<span class="act-structure-details__text">' + escapeHtml(data.actDisplayInfo.beatObjective) + '</span>'
                + '</div>';
            }
            detailsHtml += '</div>';
          }

          var wrapperHtml = '<span class="act-indicator act-indicator--clickable" id="act-indicator"'
            + ' role="button" tabindex="0" aria-expanded="false"'
            + ' aria-controls="act-structure-details">'
            + '<span class="act-indicator__arrow" aria-hidden="true">&#x25B8;</span>'
            + escapeHtml(data.actDisplayInfo.displayString)
            + '</span>';

          if (existingWrapper) {
            existingWrapper.innerHTML = wrapperHtml;
            existingWrapper.dataset.actNumber = String(newActNumber);
          } else {
            var storyTitleSection = document.querySelector('.story-title-section');
            if (storyTitleSection) {
              var newWrapper = document.createElement('div');
              newWrapper.className = 'act-indicator-wrapper';
              newWrapper.id = 'act-indicator-wrapper';
              newWrapper.dataset.actNumber = String(newActNumber);
              newWrapper.innerHTML = wrapperHtml;
              storyTitleSection.appendChild(newWrapper);
            }
          }

          // Place details panel after .story-header (outside the flex row)
          var existingDetails = document.getElementById('act-structure-details');
          if (existingDetails) {
            existingDetails.remove();
          }
          if (detailsHtml) {
            var storyHeader = document.getElementById('story-header');
            if (storyHeader) {
              storyHeader.insertAdjacentHTML('afterend', detailsHtml);
            }
          }

          initActIndicator();
          if (actChanged) {
            expandActStructureDetails();
          }
          previousActNumber = newActNumber;
        } else if (existingWrapper) {
          existingWrapper.remove();
          var orphanedDetails = document.getElementById('act-structure-details');
          if (orphanedDetails) {
            orphanedDetails.remove();
          }
          previousActNumber = null;
        }

        if (data.page.isEnding) {
          choicesSection.innerHTML = `
            <div class="ending-banner">
              <h3>THE END</h3>
              <div class="ending-actions">
                <a href="/play/${storyId}/restart" class="btn btn-primary">Play Again</a>
                <a href="/" class="btn btn-secondary">Back to Stories</a>
              </div>
            </div>
          `;
        } else {
          const guidanceForRebuild = data.wasGenerated === true
            ? { emotions: '', thoughts: '', speech: '' }
            : getProtagonistGuidanceValues();
          rebuildChoicesSection(
            data.page.choices,
            guidanceForRebuild,
            choices,
            choicesSection,
            bindCustomChoiceEvents
          );
        }

        var storyHeader = document.getElementById('story-header');
        if (storyHeader) {
          storyHeader.scrollIntoView({ behavior: 'smooth' });
        } else {
          narrative.scrollIntoView({ behavior: 'smooth' });
        }
        } catch (error) {
          console.error('Error:', error);
          // Log additional debug info if available
          if (error && typeof error === 'object' && 'debug' in error) {
            console.error('Debug info:', error.debug);
          }
          if (choicesSection) {
            showPlayError(
              error instanceof Error ? error.message : 'Something went wrong. Please try again.',
              choicesSection
            );
          }
          setChoicesDisabled(false);
        } finally {
          loadingProgress.stop();
          loading.style.display = 'none';
        }
      });
    }

    window.addEventListener('popstate', () => {
      location.reload();
    });
  }

  function initNewStoryPage() {
    const form = document.querySelector('.story-form');
    const loading = document.getElementById('loading');
    const conceptSelectorSection = document.getElementById('concept-selector-section');
    const manualStorySection = document.getElementById('manual-story-section');
    const conceptSelector = document.getElementById('concept-selector');
    const useConceptBtn = document.getElementById('use-concept-btn');
    const skipConceptBtn = document.getElementById('skip-concept-btn');
    const generateSpineBtn = document.getElementById('generate-spine-btn');
    const regenerateSpineBtn = document.getElementById('regenerate-spines-btn');
    const spineContainer = document.getElementById('spine-options');
    const spineSection = document.getElementById('spine-section');
    const conceptContextPanel = document.getElementById('concept-context-panel');
    const errorDiv = document.querySelector('.alert-error');

    if (!form || !loading || !generateSpineBtn) {
      return;
    }
    const loadingProgress = createLoadingProgressController(loading);
    var selectedConceptSpec = null;
    var loadedConceptsMap = {};

    initNpcControls();

    function toTrimmedString(value) {
      return typeof value === 'string' ? value.trim() : '';
    }

    function hideExistingError() {
      if (errorDiv) {
        errorDiv.style.display = 'none';
      }
    }

    function revealManualStorySection() {
      if (conceptSelectorSection) {
        conceptSelectorSection.style.display = 'none';
      }
      if (manualStorySection) {
        manualStorySection.style.display = 'block';
      }
    }

    function formatConceptLabel(value) {
      return String(value || '').replace(/_/g, ' ');
    }

    function asTrimmedLines(items) {
      if (!Array.isArray(items)) {
        return [];
      }

      return items
        .filter(function (item) {
          return typeof item === 'string' && item.trim().length > 0;
        })
        .map(function (item) {
          return item.trim();
        });
    }

    function setValueById(id, value) {
      var field = document.getElementById(id);
      if (!field || typeof field.value !== 'string') {
        return;
      }

      field.value = value;
    }

    function renderConceptContextPanel(conceptSpec) {
      if (!conceptContextPanel) {
        return;
      }

      if (!conceptSpec) {
        conceptContextPanel.style.display = 'none';
        conceptContextPanel.innerHTML = '';
        return;
      }

      var actionVerbs = asTrimmedLines(conceptSpec.actionVerbs).join(', ');
      conceptContextPanel.innerHTML =
        '<h3>Selected Concept Context</h3>' +
        '<p><strong>Hook:</strong> ' + escapeHtml(conceptSpec.oneLineHook || '') + '</p>' +
        '<p><strong>Core conflict loop:</strong> ' + escapeHtml(conceptSpec.coreConflictLoop || '') + '</p>' +
        '<p><strong>Conflict axis:</strong> ' + escapeHtml(formatConceptLabel(conceptSpec.conflictAxis)) + '</p>' +
        '<p><strong>Pressure source:</strong> ' + escapeHtml(conceptSpec.pressureSource || '') + '</p>' +
        '<p><strong>Stakes:</strong> Personal: ' + escapeHtml(conceptSpec.stakesPersonal || '') + ' | Systemic: ' + escapeHtml(conceptSpec.stakesSystemic || '') + '</p>' +
        '<p><strong>Deadline:</strong> ' + escapeHtml(conceptSpec.deadlineMechanism || '') + '</p>' +
        '<p><strong>Action verbs:</strong> ' + escapeHtml(actionVerbs) + '</p>';
      conceptContextPanel.style.display = 'block';
    }

    function prefillFromConceptSpec(conceptSpec) {
      if (!conceptSpec) {
        return;
      }

      var role = toTrimmedString(conceptSpec.protagonistRole);
      var competence = toTrimmedString(conceptSpec.coreCompetence);
      var flaw = toTrimmedString(conceptSpec.coreFlaw);
      var characterConcept = 'Role: ' + role + '. Competence: ' + competence + '. Flaw: ' + flaw + '.';

      var settingAxioms = asTrimmedLines(conceptSpec.settingAxioms);
      var constraintSet = asTrimmedLines(conceptSpec.constraintSet);
      var keyInstitutions = asTrimmedLines(conceptSpec.keyInstitutions);
      var worldbuilding = [
        'Setting Axioms:',
        settingAxioms.length > 0 ? '- ' + settingAxioms.join('\n- ') : '-',
        '',
        'Constraints:',
        constraintSet.length > 0 ? '- ' + constraintSet.join('\n- ') : '-',
        '',
        'Key Institutions:',
        keyInstitutions.length > 0 ? '- ' + keyInstitutions.join('\n- ') : '-',
      ].join('\n');

      var tone = formatConceptLabel(conceptSpec.genreFrame) + ' - ' + toTrimmedString(conceptSpec.genreSubversion);

      setValueById('characterConcept', characterConcept);
      setValueById('worldbuilding', worldbuilding);
      setValueById('tone', tone);
      renderConceptContextPanel(conceptSpec);
    }

    function collectFormData() {
      var formData = new FormData(form);
      var npcs = collectNpcEntries();
      return {
        title: toTrimmedString(formData.get('title')),
        characterConcept: toTrimmedString(formData.get('characterConcept')),
        worldbuilding: toTrimmedString(formData.get('worldbuilding')),
        tone: toTrimmedString(formData.get('tone')),
        npcs: npcs.length > 0 ? npcs : undefined,
        startingSituation: toTrimmedString(formData.get('startingSituation')),
        apiKey: toTrimmedString(formData.get('apiKey')),
      };
    }

    // ── Concept selector logic ─────────────────────────────────────

    async function loadConceptList() {
      try {
        var response = await fetch('/concepts/api/list');
        var data = await response.json();
        if (!response.ok || !data.success) return;

        if (conceptSelector && Array.isArray(data.concepts)) {
          data.concepts.forEach(function (c) {
            loadedConceptsMap[c.id] = c;
            var option = document.createElement('option');
            option.value = c.id;
            option.textContent = c.name + ' (' + Math.round(c.evaluatedConcept.overallScore || 0) + ')';
            conceptSelector.appendChild(option);
          });
        }
      } catch (e) {
        // Non-fatal: concepts list unavailable
      }
    }

    if (conceptSelector) {
      loadConceptList();

      conceptSelector.addEventListener('change', function () {
        var conceptId = conceptSelector.value;
        if (useConceptBtn) {
          useConceptBtn.disabled = !conceptId;
        }
      });
    }

    if (useConceptBtn) {
      useConceptBtn.addEventListener('click', function (event) {
        event.preventDefault();
        var conceptId = conceptSelector ? conceptSelector.value : '';
        if (!conceptId) return;

        var savedConcept = loadedConceptsMap[conceptId];
        if (savedConcept && savedConcept.evaluatedConcept && savedConcept.evaluatedConcept.concept) {
          selectedConceptSpec = savedConcept.evaluatedConcept.concept;
          prefillFromConceptSpec(selectedConceptSpec);
          revealManualStorySection();
          if (manualStorySection && typeof manualStorySection.scrollIntoView === 'function') {
            manualStorySection.scrollIntoView({ behavior: 'smooth' });
          }
        }
      });
    }

    async function fetchSpineOptions() {
      hideExistingError();

      generateSpineBtn.disabled = true;
      if (regenerateSpineBtn) regenerateSpineBtn.disabled = true;
      loading.style.display = 'flex';
      var progressId = createProgressId();
      loadingProgress.start(progressId);

      try {
        var formValues = collectFormData();
        var response = await fetch('/stories/generate-spines', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            characterConcept: formValues.characterConcept,
            worldbuilding: formValues.worldbuilding,
            tone: formValues.tone,
            npcs: formValues.npcs,
            startingSituation: formValues.startingSituation,
            apiKey: formValues.apiKey,
            conceptSpec: selectedConceptSpec || undefined,
            progressId: progressId,
          }),
        });

        var data = await response.json();

        if (!response.ok || !data.success) {
          if (data.code) {
            console.error('Error code:', data.code, '| Retryable:', data.retryable);
          }
          throw new Error(data.error || 'Failed to generate spine options');
        }

        if (formValues.apiKey.length >= 10) {
          setApiKey(formValues.apiKey);
        }

        if (spineContainer && spineSection) {
          renderSpineOptions(data.options, spineContainer, function (option) {
            createStoryWithSpine(option);
          });
          spineSection.style.display = 'block';
          if (regenerateSpineBtn) regenerateSpineBtn.style.display = 'inline-block';
          spineSection.scrollIntoView({ behavior: 'smooth' });
        }
      } catch (error) {
        console.error('Spine generation error:', error);
        showFormError(error instanceof Error ? error.message : 'Something went wrong. Please try again.');
      } finally {
        loadingProgress.stop();
        loading.style.display = 'none';
        generateSpineBtn.disabled = false;
        if (regenerateSpineBtn) regenerateSpineBtn.disabled = false;
      }
    }

    async function createStoryWithSpine(spine) {
      hideExistingError();

      generateSpineBtn.disabled = true;
      if (regenerateSpineBtn) regenerateSpineBtn.disabled = true;
      loading.style.display = 'flex';
      var progressId = createProgressId();
      loadingProgress.start(progressId);

      try {
        var formValues = collectFormData();
        var response = await fetch('/stories/create-ajax', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            title: formValues.title,
            characterConcept: formValues.characterConcept,
            worldbuilding: formValues.worldbuilding,
            tone: formValues.tone,
            npcs: formValues.npcs,
            startingSituation: formValues.startingSituation,
            apiKey: formValues.apiKey,
            conceptSpec: selectedConceptSpec || undefined,
            spine: spine,
            progressId: progressId,
          }),
        });

        var data = await response.json();

        if (!response.ok || !data.success) {
          if (data.code) {
            console.error('Error code:', data.code, '| Retryable:', data.retryable);
          }
          if (data.debug) {
            console.error('Debug info:', data.debug);
          }
          throw new Error(data.error || 'Failed to create story');
        }

        window.location.assign('/play/' + data.storyId + '/briefing');
      } catch (error) {
        console.error('Story creation error:', error);
        showFormError(error instanceof Error ? error.message : 'Something went wrong. Please try again.');
        generateSpineBtn.disabled = false;
        if (regenerateSpineBtn) regenerateSpineBtn.disabled = false;
      } finally {
        loadingProgress.stop();
        loading.style.display = 'none';
      }
    }

    var storedApiKey = getApiKey();
    var apiKeyInput = document.getElementById('apiKey');
    if (apiKeyInput && storedApiKey && typeof apiKeyInput.value === 'string' && apiKeyInput.value.length === 0) {
      apiKeyInput.value = storedApiKey;
    }

    if (skipConceptBtn) {
      skipConceptBtn.addEventListener('click', function (event) {
        event.preventDefault();
        selectedConceptSpec = null;
        renderConceptContextPanel(null);
        revealManualStorySection();
      });
    }

    // Phase A: Generate Spine on button click
    generateSpineBtn.addEventListener('click', function (event) {
      event.preventDefault();
      fetchSpineOptions();
    });

    // Regenerate button
    if (regenerateSpineBtn) {
      regenerateSpineBtn.addEventListener('click', function (event) {
        event.preventDefault();
        if (spineContainer) clearSpineOptions(spineContainer);
        clearSelectedSpine();
        fetchSpineOptions();
      });
    }

    // Prevent default form submit (no longer a submit button)
    form.addEventListener('submit', function (event) {
      event.preventDefault();
    });
  }

  document.addEventListener('DOMContentLoaded', () => {
    initPlayPage();
    initNewStoryPage();
    initBriefingPage();
    initConceptsPage();
  });

  // ── Briefing page controller ─────────────────────────────────────

  function initBriefingPage() {
    var beginBtn = document.getElementById('begin-adventure-btn');
    var loading = document.getElementById('loading');
    var apiKeyModal = document.getElementById('api-key-modal');
    var briefingContainer = document.querySelector('.briefing-container');
    var errorBlock = document.getElementById('briefing-error');

    if (!beginBtn || !loading || !apiKeyModal || !briefingContainer) {
      return;
    }

    var storyId = briefingContainer.getAttribute('data-story-id');
    if (!storyId) {
      return;
    }

    var loadingProgress = createLoadingProgressController(loading);

    function setError(message) {
      if (!errorBlock) {
        return;
      }

      errorBlock.textContent = message;
      errorBlock.style.display = 'block';
    }

    function clearError() {
      if (!errorBlock) {
        return;
      }

      errorBlock.textContent = '';
      errorBlock.style.display = 'none';
    }

    function ensureApiKey() {
      return new Promise(function(resolve, reject) {
        var key = getApiKey();
        if (key) {
          resolve(key);
          return;
        }

        var form = document.getElementById('api-key-form');
        var input = document.getElementById('modal-api-key');
        var cancelBtn = document.getElementById('cancel-api-key');

        if (!(form instanceof HTMLFormElement) || !(input instanceof HTMLInputElement)) {
          reject(new Error('API key prompt is unavailable.'));
          return;
        }

        apiKeyModal.style.display = 'flex';

        function cleanup() {
          form.removeEventListener('submit', handleSubmit);
          if (cancelBtn) {
            cancelBtn.removeEventListener('click', handleCancel);
          }
        }

        function handleCancel() {
          cleanup();
          apiKeyModal.style.display = 'none';
          reject(new Error('API key is required.'));
        }

        function handleSubmit(event) {
          event.preventDefault();
          var newKey = input.value.trim();
          if (newKey.length < 10) {
            setError('Please enter a valid API key.');
            return;
          }

          clearError();
          cleanup();
          setApiKey(newKey);
          apiKeyModal.style.display = 'none';
          resolve(newKey);
        }

        form.addEventListener('submit', handleSubmit);
        if (cancelBtn) {
          cancelBtn.addEventListener('click', handleCancel);
        }
      });
    }

    async function beginAdventure(apiKey) {
      beginBtn.disabled = true;
      clearError();
      loading.style.display = 'flex';
      var progressId = createProgressId();
      loadingProgress.start(progressId);

      try {
        var response = await fetch('/play/' + storyId + '/begin', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            apiKey: apiKey,
            progressId: progressId,
          }),
        });
        var data = await response.json();

        if (!response.ok || !data.success) {
          throw new Error(data.error || 'Failed to begin adventure');
        }

        window.location.assign('/play/' + storyId + '?page=1&newStory=true');
      } catch (error) {
        setError(error instanceof Error ? error.message : 'Failed to begin adventure');
        beginBtn.disabled = false;
      } finally {
        loadingProgress.stop();
        loading.style.display = 'none';
      }
    }

    beginBtn.addEventListener('click', async function() {
      try {
        var apiKey = await ensureApiKey();
        await beginAdventure(apiKey);
      } catch (error) {
        setError(error instanceof Error ? error.message : 'Failed to begin adventure');
      }
    });
  }

  // ── Concepts Page Controller ─────────────────────────────────────

  function initConceptsPage() {
    var page = document.getElementById('concepts-page');
    if (!page) {
      return;
    }

    var loading = document.getElementById('loading');
    var generateBtn = document.getElementById('generate-concepts-btn');
    var conceptCardsContainer = document.getElementById('concept-cards');
    var conceptResultsSection = document.getElementById('concept-results-section');
    var savedConceptsList = document.getElementById('saved-concepts-list');
    var editModal = document.getElementById('concept-edit-modal');
    var editCloseBtn = document.getElementById('concept-edit-close');
    var editSaveBtn = document.getElementById('concept-edit-save');
    var editCancelBtn = document.getElementById('concept-edit-cancel');

    if (!loading || !generateBtn) {
      return;
    }

    var loadingProgress = createLoadingProgressController(loading);
    var currentEditConceptId = null;
    var lastGeneratedConcepts = null;
    var lastSeeds = null;

    // Restore API key from session storage
    var storedKey = getApiKey();
    var apiKeyInput = document.getElementById('conceptApiKey');
    if (apiKeyInput && storedKey && apiKeyInput.value.length === 0) {
      apiKeyInput.value = storedKey;
    }

    function getConceptApiKey() {
      var input = document.getElementById('conceptApiKey');
      var val = input && typeof input.value === 'string' ? input.value.trim() : '';
      return val || (getApiKey() || '').trim();
    }

    function collectSeeds() {
      var g = document.getElementById('genreVibes');
      var m = document.getElementById('moodKeywords');
      var c = document.getElementById('contentPreferences');
      var t = document.getElementById('thematicInterests');
      var s = document.getElementById('sparkLine');
      return {
        genreVibes: g && typeof g.value === 'string' ? g.value.trim() : '',
        moodKeywords: m && typeof m.value === 'string' ? m.value.trim() : '',
        contentPreferences: c && typeof c.value === 'string' ? c.value.trim() : '',
        thematicInterests: t && typeof t.value === 'string' ? t.value.trim() : '',
        sparkLine: s && typeof s.value === 'string' ? s.value.trim() : '',
      };
    }

    function showError(message) {
      if (typeof showFormError === 'function') {
        showFormError(message);
      } else {
        alert(message);
      }
    }

    // ── Generate concepts ──────────────────────────────────────────

    async function handleGenerate() {
      var apiKey = getConceptApiKey();
      if (apiKey.length < 10) {
        showError('OpenRouter API key is required');
        return;
      }

      var seeds = collectSeeds();
      if (!seeds.genreVibes && !seeds.moodKeywords && !seeds.contentPreferences && !seeds.thematicInterests && !seeds.sparkLine) {
        showError('At least one concept seed field is required');
        return;
      }

      generateBtn.disabled = true;
      loading.style.display = 'flex';
      var progressId = createProgressId();
      loadingProgress.start(progressId);

      try {
        var response = await fetch('/concepts/api/generate', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            genreVibes: seeds.genreVibes,
            moodKeywords: seeds.moodKeywords,
            contentPreferences: seeds.contentPreferences,
            thematicInterests: seeds.thematicInterests,
            sparkLine: seeds.sparkLine,
            apiKey: apiKey,
            progressId: progressId,
          }),
        });

        var data = await response.json();
        if (!response.ok || !data.success) {
          throw new Error(data.error || 'Failed to generate concepts');
        }

        setApiKey(apiKey);
        lastGeneratedConcepts = data.evaluatedConcepts;
        lastSeeds = seeds;

        renderGeneratedConcepts(data.evaluatedConcepts, seeds);
      } catch (error) {
        showError(error instanceof Error ? error.message : 'Something went wrong');
      } finally {
        loadingProgress.stop();
        loading.style.display = 'none';
        generateBtn.disabled = false;
      }
    }

    function renderGeneratedConcepts(evaluatedConcepts, seeds) {
      if (!conceptCardsContainer || !conceptResultsSection) {
        return;
      }

      conceptCardsContainer.innerHTML = '';

      if (!Array.isArray(evaluatedConcepts) || evaluatedConcepts.length === 0) {
        conceptCardsContainer.innerHTML = '<p class="spine-section-subtitle">No concepts generated. Adjust seeds and try again.</p>';
        conceptResultsSection.style.display = 'block';
        return;
      }

      evaluatedConcepts.forEach(function (entry, index) {
        var concept = entry && entry.concept ? entry.concept : {};
        var card = document.createElement('article');
        card.className = 'spine-card concept-card';
        card.dataset.index = String(index);

        var overallScore = Number(entry && entry.overallScore);
        var safeOverall = Number.isFinite(overallScore) ? Math.max(0, Math.min(100, overallScore)) : 0;

        card.innerHTML =
          '<div class="spine-badges">' +
            '<span class="spine-badge spine-badge-type">' + escapeHtml((concept.genreFrame || '').replace(/_/g, ' ')) + '</span>' +
            '<span class="spine-badge spine-badge-conflict">' + escapeHtml((concept.conflictAxis || '').replace(/_/g, ' ')) + '</span>' +
            '<span class="spine-badge spine-badge-arc">Score ' + escapeHtml(Math.round(safeOverall).toString()) + '</span>' +
          '</div>' +
          '<h3 class="spine-cdq">' + escapeHtml(concept.oneLineHook || '') + '</h3>' +
          '<p class="spine-field">' + escapeHtml(concept.elevatorParagraph || '') + '</p>' +
          '<div class="spine-field"><span class="spine-label">Protagonist:</span> ' + escapeHtml(concept.protagonistRole || '') + '</div>' +
          '<div class="concept-scores">' + renderScoreGrid(entry && entry.scores) + '</div>' +
          '<div class="spine-field"><span class="spine-label">Tradeoff:</span> ' + escapeHtml(entry && entry.tradeoffSummary ? entry.tradeoffSummary : '') + '</div>' +
          '<div class="concept-feedback">' +
            '<div class="concept-feedback-block"><span class="spine-label">Strengths</span><ul>' + renderListItems(entry && entry.strengths) + '</ul></div>' +
            '<div class="concept-feedback-block"><span class="spine-label">Weaknesses</span><ul>' + renderListItems(entry && entry.weaknesses) + '</ul></div>' +
          '</div>' +
          '<div class="form-actions" style="margin-top: 0.5rem;">' +
            '<button type="button" class="btn btn-primary btn-small concept-save-generated-btn" data-gen-index="' + index + '">Save to Library</button>' +
          '</div>';

        conceptCardsContainer.appendChild(card);
      });

      conceptResultsSection.style.display = 'block';
      conceptResultsSection.scrollIntoView({ behavior: 'smooth' });
    }

    // ── Save generated concept ─────────────────────────────────────

    if (conceptCardsContainer) {
      conceptCardsContainer.addEventListener('click', function (event) {
        var target = event.target;
        if (!(target instanceof HTMLElement)) return;
        var btn = target.closest('.concept-save-generated-btn');
        if (!btn) return;

        var index = Number(btn.dataset.genIndex);
        if (!Number.isFinite(index) || !lastGeneratedConcepts || !lastGeneratedConcepts[index]) return;

        btn.disabled = true;
        btn.textContent = 'Saving...';
        saveGeneratedConcept(lastGeneratedConcepts[index], lastSeeds, btn);
      });
    }

    async function saveGeneratedConcept(evaluatedConcept, seeds, btn) {
      try {
        var response = await fetch('/concepts/api/save', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            evaluatedConcept: evaluatedConcept,
            seeds: seeds || {},
          }),
        });

        var data = await response.json();
        if (!response.ok || !data.success) {
          throw new Error(data.error || 'Failed to save concept');
        }

        btn.textContent = 'Saved!';
        btn.classList.remove('btn-primary');
        btn.classList.add('btn-secondary');

        appendSavedConceptCard(data.concept);
      } catch (error) {
        btn.disabled = false;
        btn.textContent = 'Save to Library';
        showError(error instanceof Error ? error.message : 'Failed to save');
      }
    }

    function appendSavedConceptCard(concept) {
      if (!savedConceptsList) return;

      // Remove "no saved concepts" message if present
      var emptyMsg = savedConceptsList.closest('#saved-concepts-section');
      if (emptyMsg) {
        var emptyP = emptyMsg.querySelector('.spine-section-subtitle');
        if (emptyP) emptyP.remove();
      }

      var card = document.createElement('article');
      card.className = 'spine-card concept-card saved-concept-card';
      card.dataset.conceptId = concept.id;

      var c = concept.evaluatedConcept.concept;
      card.innerHTML =
        '<div class="spine-badges">' +
          '<span class="spine-badge spine-badge-type">' + escapeHtml((c.genreFrame || '').replace(/_/g, ' ')) + '</span>' +
          '<span class="spine-badge spine-badge-conflict">' + escapeHtml((c.conflictAxis || '').replace(/_/g, ' ')) + '</span>' +
          '<span class="spine-badge spine-badge-arc">Score ' + escapeHtml(Math.round(concept.evaluatedConcept.overallScore || 0).toString()) + '</span>' +
        '</div>' +
        '<h3 class="spine-cdq">' + escapeHtml(concept.name) + '</h3>' +
        '<p class="spine-field">' + escapeHtml(c.elevatorParagraph || '') + '</p>' +
        '<div class="spine-field"><span class="spine-label">Created:</span> ' + escapeHtml(new Date(concept.createdAt).toLocaleDateString()) + '</div>' +
        '<div class="form-actions" style="margin-top: 0.5rem;">' +
          '<button type="button" class="btn btn-secondary btn-small concept-edit-btn" data-concept-id="' + escapeHtml(concept.id) + '">Edit</button>' +
          '<button type="button" class="btn btn-primary btn-small concept-harden-btn" data-concept-id="' + escapeHtml(concept.id) + '">Harden</button>' +
          '<button type="button" class="btn btn-danger btn-small concept-delete-btn" data-concept-id="' + escapeHtml(concept.id) + '">Delete</button>' +
        '</div>';

      savedConceptsList.prepend(card);
    }

    // ── Delete concept ─────────────────────────────────────────────

    if (savedConceptsList) {
      savedConceptsList.addEventListener('click', function (event) {
        var target = event.target;
        if (!(target instanceof HTMLElement)) return;

        var deleteBtn = target.closest('.concept-delete-btn');
        if (deleteBtn) {
          var conceptId = deleteBtn.dataset.conceptId;
          if (conceptId && confirm('Delete this concept?')) {
            handleDelete(conceptId, deleteBtn);
          }
          return;
        }

        var editBtn = target.closest('.concept-edit-btn');
        if (editBtn) {
          var editId = editBtn.dataset.conceptId;
          if (editId) openEditModal(editId);
          return;
        }

        var hardenBtn = target.closest('.concept-harden-btn');
        if (hardenBtn && !hardenBtn.disabled) {
          var hardenId = hardenBtn.dataset.conceptId;
          if (hardenId) handleHarden(hardenId, hardenBtn);
        }
      });
    }

    async function handleDelete(conceptId, btn) {
      btn.disabled = true;
      try {
        var response = await fetch('/concepts/api/' + encodeURIComponent(conceptId), {
          method: 'DELETE',
        });

        var data = await response.json();
        if (!response.ok || !data.success) {
          throw new Error(data.error || 'Failed to delete');
        }

        var card = btn.closest('.saved-concept-card');
        if (card) card.remove();
      } catch (error) {
        btn.disabled = false;
        showError(error instanceof Error ? error.message : 'Failed to delete');
      }
    }

    // ── Harden concept ─────────────────────────────────────────────

    async function handleHarden(conceptId, btn) {
      var apiKey = getConceptApiKey();
      if (apiKey.length < 10) {
        showError('OpenRouter API key is required to harden a concept');
        return;
      }

      btn.disabled = true;
      btn.textContent = 'Hardening...';
      loading.style.display = 'flex';
      var progressId = createProgressId();
      loadingProgress.start(progressId);

      try {
        var response = await fetch('/concepts/api/' + encodeURIComponent(conceptId) + '/harden', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            apiKey: apiKey,
            progressId: progressId,
          }),
        });

        var data = await response.json();
        if (!response.ok || !data.success) {
          throw new Error(data.error || 'Failed to harden concept');
        }

        setApiKey(apiKey);
        btn.textContent = 'Already Hardened';

        // Update the card badges to show hardened status
        var card = btn.closest('.saved-concept-card');
        if (card) {
          var badges = card.querySelector('.spine-badges');
          if (badges) {
            var hardenBadge = document.createElement('span');
            hardenBadge.className = 'spine-badge spine-badge-type';
            hardenBadge.style.background = 'var(--accent-green, #2ecc71)';
            hardenBadge.textContent = 'Hardened';
            badges.appendChild(hardenBadge);
          }
        }
      } catch (error) {
        btn.disabled = false;
        btn.textContent = 'Harden';
        showError(error instanceof Error ? error.message : 'Failed to harden');
      } finally {
        loadingProgress.stop();
        loading.style.display = 'none';
      }
    }

    // ── Edit modal ─────────────────────────────────────────────────

    function getEditField(id) {
      return document.getElementById('edit-' + id);
    }

    function setEditValue(id, value) {
      var el = getEditField(id);
      if (el && typeof el.value === 'string') {
        el.value = value || '';
      }
    }

    function getEditValue(id) {
      var el = getEditField(id);
      return el && typeof el.value === 'string' ? el.value.trim() : '';
    }

    function linesToArray(text) {
      return text
        .split('\n')
        .map(function (line) { return line.trim(); })
        .filter(function (line) { return line.length > 0; });
    }

    async function openEditModal(conceptId) {
      if (!editModal) return;

      loading.style.display = 'flex';
      try {
        var response = await fetch('/concepts/api/' + encodeURIComponent(conceptId));
        var data = await response.json();
        if (!response.ok || !data.success || !data.concept) {
          throw new Error(data.error || 'Failed to load concept');
        }

        currentEditConceptId = conceptId;
        var c = data.concept.evaluatedConcept.concept;

        setEditValue('name', data.concept.name);
        setEditValue('oneLineHook', c.oneLineHook);
        setEditValue('elevatorParagraph', c.elevatorParagraph);
        setEditValue('protagonistRole', c.protagonistRole);
        setEditValue('coreCompetence', c.coreCompetence);
        setEditValue('coreFlaw', c.coreFlaw);
        setEditValue('coreConflictLoop', c.coreConflictLoop);
        setEditValue('pressureSource', c.pressureSource);
        setEditValue('stakesPersonal', c.stakesPersonal);
        setEditValue('stakesSystemic', c.stakesSystemic);
        setEditValue('deadlineMechanism', c.deadlineMechanism);
        setEditValue('genreSubversion', c.genreSubversion);
        setEditValue('genreFrame', c.genreFrame);
        setEditValue('conflictAxis', c.conflictAxis);
        setEditValue('branchingPosture', c.branchingPosture);
        setEditValue('settingScale', c.settingScale);
        setEditValue('stateComplexity', c.stateComplexity);
        setEditValue('actionVerbs', Array.isArray(c.actionVerbs) ? c.actionVerbs.join('\n') : '');
        setEditValue('settingAxioms', Array.isArray(c.settingAxioms) ? c.settingAxioms.join('\n') : '');
        setEditValue('constraintSet', Array.isArray(c.constraintSet) ? c.constraintSet.join('\n') : '');
        setEditValue('keyInstitutions', Array.isArray(c.keyInstitutions) ? c.keyInstitutions.join('\n') : '');

        editModal.style.display = 'flex';
      } catch (error) {
        showError(error instanceof Error ? error.message : 'Failed to load concept for editing');
      } finally {
        loading.style.display = 'none';
      }
    }

    function closeEditModal() {
      if (editModal) editModal.style.display = 'none';
      currentEditConceptId = null;
    }

    async function handleEditSave() {
      if (!currentEditConceptId) return;

      var conceptFields = {
        oneLineHook: getEditValue('oneLineHook'),
        elevatorParagraph: getEditValue('elevatorParagraph'),
        protagonistRole: getEditValue('protagonistRole'),
        coreCompetence: getEditValue('coreCompetence'),
        coreFlaw: getEditValue('coreFlaw'),
        coreConflictLoop: getEditValue('coreConflictLoop'),
        pressureSource: getEditValue('pressureSource'),
        stakesPersonal: getEditValue('stakesPersonal'),
        stakesSystemic: getEditValue('stakesSystemic'),
        deadlineMechanism: getEditValue('deadlineMechanism'),
        genreSubversion: getEditValue('genreSubversion'),
        genreFrame: getEditValue('genreFrame'),
        conflictAxis: getEditValue('conflictAxis'),
        branchingPosture: getEditValue('branchingPosture'),
        settingScale: getEditValue('settingScale'),
        stateComplexity: getEditValue('stateComplexity'),
        actionVerbs: linesToArray(getEditValue('actionVerbs')),
        settingAxioms: linesToArray(getEditValue('settingAxioms')),
        constraintSet: linesToArray(getEditValue('constraintSet')),
        keyInstitutions: linesToArray(getEditValue('keyInstitutions')),
      };

      var name = getEditValue('name');

      if (editSaveBtn) editSaveBtn.disabled = true;

      try {
        var response = await fetch('/concepts/api/' + encodeURIComponent(currentEditConceptId), {
          method: 'PUT',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ name: name, conceptFields: conceptFields }),
        });

        var data = await response.json();
        if (!response.ok || !data.success) {
          throw new Error(data.error || 'Failed to save changes');
        }

        // Update the card in the list
        var card = savedConceptsList
          ? savedConceptsList.querySelector('[data-concept-id="' + currentEditConceptId + '"]')
          : null;
        if (card && data.concept) {
          var c = data.concept.evaluatedConcept.concept;
          var titleEl = card.querySelector('.spine-cdq');
          if (titleEl) titleEl.textContent = data.concept.name;
          var paraEl = card.querySelector('.spine-field');
          if (paraEl) paraEl.textContent = c.elevatorParagraph || '';
        }

        closeEditModal();
      } catch (error) {
        showError(error instanceof Error ? error.message : 'Failed to save changes');
      } finally {
        if (editSaveBtn) editSaveBtn.disabled = false;
      }
    }

    // ── Event binding ──────────────────────────────────────────────

    generateBtn.addEventListener('click', function (event) {
      event.preventDefault();
      handleGenerate();
    });

    if (editCloseBtn) editCloseBtn.addEventListener('click', closeEditModal);
    if (editCancelBtn) editCancelBtn.addEventListener('click', closeEditModal);
    if (editSaveBtn) editSaveBtn.addEventListener('click', handleEditSave);
  }
})();
