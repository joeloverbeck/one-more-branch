/**
 * One More Branch - Client-side JavaScript
 * Generated by scripts/concat-client-js.js — do not edit directly.
 */

(function() {
  'use strict';

// ── Configuration ──────────────────────────────────────────────────

const API_KEY_STORAGE_KEY = 'omb_api_key';
const PROGRESS_POLL_INTERVAL_MS = 1200;
const PHRASE_ROTATION_MIN_MS = 3500;
const PHRASE_ROTATION_MAX_MS = 4500;
const OPEN_THREADS_PANEL_LIMIT = 6;
const KEYED_ENTRY_PANEL_LIMIT = 6;
const LEFT_PANEL_LIMIT = 10;

const STAGE_PHRASE_POOLS = {
  GENERATING_SPINE: [
    'Searching for the beating heart of the story...',
    'Asking the hard question nobody wants answered...',
    'Discovering what the protagonist really needs...',
    'Weighing impossible choices against each other...',
    'Finding the lie the hero believes...',
    'Unearthing the buried dramatic question...',
    'Consulting the oracle of narrative structure...',
    'Measuring the gap between want and need...',
    'Summoning the antagonistic forces of destiny...',
    'Sketching the skeleton of dramatic truth...',
    'Interrogating the protagonist\'s deepest fears...',
    'Calibrating the moral compass of the universe...',
    'Testing which pressures crack and which temper...',
    'Exploring the space between desire and necessity...',
    'Drafting the contract between hero and fate...',
    'Surveying the battlefield of inner conflict...',
    'Tracing the fault lines of character and world...',
    'Mapping the territory of impossible promises...',
    'Auditing the protagonist\'s emotional debts...',
    'Weighing the cost of every possible truth...',
  ],
  PLANNING_PAGE: [
    'Consulting the crystal flowchart...',
    'Drawing arrows between dramatic possibilities...',
    'Balancing destiny on a clipboard...',
    'Whispering to the page planner gremlins...',
    'Calling a meeting of the tiny committee in the wall...',
    'Spinning the wheel of plausible chaos...',
    'Asking the couch cushions for strategic advice...',
    'Filing a permit for emotional turbulence...',
    'Color-coding fate with suspicious confidence...',
    'Unfolding the emergency roadmap of maybes...',
    'Negotiating with the timeline using snacks...',
    'Pinning red string to absolutely everything...',
    'Rolling percentile dice for narrative nonsense...',
    'Drafting plans in invisible ink and optimism...',
    'Testing three plans and a backup plan for the backup...',
    'Summoning a brainstorming thundercloud...',
    'Aligning plot magnets to true north drama...',
    'Cross-referencing vibes with hard evidence...',
    'Sharpening pencils to a tactical point...',
    'Budgeting exactly seven units of suspense...',
    'Interviewing three raccoons about long-term strategy...',
    'Mapping alternate futures on a napkin atlas...',
    'Counting plot beats with abacus-level confidence...',
    'Assembling a task force of overqualified pigeons...',
    'Translating chaos into bullet points and coffee rings...',
    'Scheduling destiny in 15-minute calendar blocks...',
    'Running a tabletop exercise for worst-case melodrama...',
    'Tuning the risk radar to "politely catastrophic"...',
    'Checking if the backup prophecy has a backup...',
    'Building a tiny model of the plot out of cereal...',
    'Holding auditions for the next big complication...',
    'Labeling each possibility with a caution sticker...',
    'Comparing timelines for structural squeaks...',
    'Drafting contingency plans on the back of moonlight...',
    'Assigning cliffhangers to their proper jurisdictions...',
    'Sending reconnaissance balloons into chapter two...',
    'Running cost estimates on emotional collateral...',
    'Verifying assumptions with a dramatic checklist...',
    'Plotting escape routes from predictable outcomes...',
    'Stress-testing Plan A against the laws of irony...',
    'Calculating odds with a haunted spreadsheet...',
    'Summoning a consultant possum for tactical input...',
    'Folding contingency plans into paper airplanes...',
    'Checking whether destiny signed the waiver...',
    'Setting up cones around high-risk plot zones...',
    'Feeding strategy grapes to the idea committee...',
    'Using divining rods to locate hidden opportunities...',
    'Building a decision tree out of toothpicks...',
    'Forecasting drama with a barometer and vibes...',
    'Asking the office fern to rank our options...',
    'Air-dropping priorities into a sandbox of chaos...',
    'Measuring uncertainty in teaspoons and sighs...',
    'Consulting the emergency binder labeled "yikes"...',
    'Running a war game with tiny cardboard villains...',
    'Assigning probability hats to every wild guess...',
    'Negotiating timeline treaties at the snack table...',
    'Drafting scenario maps with glitter pens only...',
    'Shuffling strategic options like tarot cards...',
    'Placing caution tape around suspiciously easy plans...',
    'Checking if fate left comments on the whiteboard...',
    'Teaching a rubber duck to run the strategy meeting...',
    'Drafting a five-year plan in crayon and regret...',
    'Recalculating destiny after it failed a unit test...',
    'Arguing with the probability gremlin about rounding...',
    'Asking the magic 8-ball for actionable deliverables...',
    'Pretending the Gantt chart can feel shame...',
    'Herding stray plot ideas back into their pens...',
    'Replacing bold assumptions with slightly braver ones...',
    'Installing guardrails on a plan made of vibes...',
    'Checking the emergency exit route from Act Two...',
    'Bribing the risk assessment with a cinnamon roll...',
    'Running the "what if everything goes wrong" rehearsal...',
    'Pinning "do not trust this plan" on the plan...',
    'Assembling a strategy out of spare dramatic parts...',
    'Drafting the agenda, then losing it to a breeze...',
    'Testing our plan against a mischievous universe...',
    'Negotiating with inevitability for a smaller bite...',
    'Making a pros-and-cons list and eating the paper...',
    'Ordering chaos to please stay within business hours...',
    'Scheduling surprise revelations with suspicious precision...',
    'Poking the plot to see where it squeaks...',
    'Translating panic into a calm-looking flowchart...',
    'Selecting a route that avoids obvious foreshadowing...',
    'Practicing confident nods over a terrible idea...',
    'Calibrating optimism to "probably survivable"...',
    'Spinning the decision compass until it stops screaming...',
    'Checking if the plot has any allergies to logic...',
    'Issuing hard hats to all future consequences...',
    'Drafting a plan, then adding a plan for the plan...',
    'Consulting the backup backup backup plan\'s manager...',
    'Creating a "no melodrama" policy and ignoring it...',
    'Measuring ambition in centimeters and hubris...',
    'Folding the strategy into a paper swan of doom...',
    'Asking a suspicious crow to forecast outcomes...',
    'Running long-term projections on short-term chaos...'
  ],
  ACCOUNTING_STATE: [
    'Opening the ledger of consequences...',
    'Filing state changes in triplicate...',
    'Auditing active threats against current reality...',
    'Reconciling inventory with narrative receipts...',
    'Balancing the books of cause and effect...',
    'Stamping forms with the seal of inevitability...',
    'Checking thread IDs against the registry...',
    'Reviewing constraints for compliance...',
    'Verifying canon entries with the records office...',
    'Processing character-state updates through HR...',
    'Issuing a formal notice of escalation...',
    'Logging health updates in the permanent file...',
    'Cross-referencing urgency with actual danger...',
    'Reviewing removals for proper justification...',
    'Archiving resolved loops in the closed-cases drawer...',
    'Stamping this transition APPROVED...',
    'Running the final consistency audit...',
    'Reconciling ambition with available resources...',
    'Validating IDs with stern bureaucratic focus...',
    'Closing the books on this scene...'
  ],
  CURATING_CONTEXT: [
    'Consulting the ancient tomes...',
    'Cross-referencing character grudges...',
    'Alphabetizing plot threads by urgency...',
    'Dusting off the relevant lore scrolls...',
    'Cataloging who knows what and why...',
    'Filing canon facts by scene relevance...',
    'Sifting through backstory for gold...',
    'Indexing every grudge, oath, and rumor...',
    'Sorting character baggage by weight...',
    'Highlighting the bits that actually matter...',
    'Trimming the lore hedge into shape...',
    'Cross-checking alibis with established canon...',
    'Retrieving the right dossiers from the vault...',
    'Marking worldbuilding passages for inclusion...',
    'Shelving irrelevant details with a polite nod...',
    'Assembling the scene-specific cheat sheet...',
    'Pulling character files from the archive...',
    'Condensing three volumes into one sticky note...',
    'Verifying which NPCs are in the room...',
    'Building a relationship map out of red string...',
    'Checking speech patterns against dialogue records...',
    'Curating only the juiciest canon facts...',
    'Reviewing who said what to whom and when...',
    'Extracting verbal tics from prior conversations...',
    'Filtering worldbuilding through the scene lens...',
    'Packaging emotional baggage for scene delivery...',
    'Compiling a dossier of relevant tensions...',
    'Tagging characters by scene importance...',
    'Archiving the stuff nobody needs right now...',
    'Preparing the scene-focused briefing packet...',
    'Auditing character relationships for freshness...',
    'Sorting history into chronological cause-and-effect...',
    'Stamping canon facts with relevance ratings...',
    'Rolling up lore into a portable scroll...',
    'Pruning the context garden of decorative weeds...',
    'Assembling the cast list for this scene...',
    'Verifying continuity seals are unbroken...',
    'Checking which promises are due this chapter...',
    'Building the scene bible with archival precision...',
    'Extracting only the load-bearing lore...',
    'Selecting the right emotional ammunition...',
    'Summarizing three acts of history in two paragraphs...',
    'Folding context into an origami cheat sheet...',
    'Organizing character dynamics by voltage level...',
    'Labeling each fact by expiration scene...',
    'Pulling relevant memories from the narrative vault...',
    'Scanning the timeline for causality chains...',
    'Compressing epic backstory into scene-sized packets...',
    'Cross-referencing motives with opportunity...',
    'Sorting the important from the merely interesting...',
    'Weighing each detail on the relevance scale...',
    'Assembling a greatest-hits of narrative context...',
    'Checking which character arcs are load-bearing...',
    'Preparing a briefcase of curated consequences...',
    'Filing emotional receipts by character name...',
    'Distilling worldbuilding into scene-grade concentrate...',
    'Reviewing the interpersonal tension inventory...',
    'Selecting speech samples for voice consistency...',
    'Packaging the past into a useful present...',
    'Shaking lore crumbs out of the narrative sofa...',
    'Politely escorting irrelevant trivia into the void...',
    'Asking the canon to please stop moving when observed...',
    'Vacuuming up stray backstory glitter...',
    'Holding a tiny trial for disputed continuity facts...',
    'Labeling every rumor with "handle with care"...',
    'Making a neat pile of truths and a bigger pile of lies...',
    'Checking receipts for who promised what, exactly...',
    'Summoning the archivist spirit and offering snacks...',
    'Stitching together timelines that refuse to align...',
    'Extracting character voice samples like rare spices...',
    'Sorting grudges into "fresh", "fermented", and "apocalyptic"...',
    'Taping sticky notes onto the universe for later...',
    'Assembling a lore smoothie (no chunks, please)...',
    'Cross-referencing dramatic irony with actual knowledge...',
    'Confirming which NPCs exist in this reality...',
    'Auditing the backstory for unauthorized drama...',
    'Translating ancient lore into modern panic...',
    'Highlighting the one detail that will ruin everything...',
    'Putting context in a lunchbox for the scene...',
    'Checking the world bible for hidden footnotes...',
    'Digitizing a memory by squinting at it intensely...',
    'Sorting secrets by "should explode soon"...',
    'Dusting off the relationship web and sneezing...',
    'Reducing ten chapters of history to one meaningful glare...',
    'Asking the lore librarian where the "good stuff" is...',
    'Re-stacking canon until it stops wobbling...',
    'Filing emotional baggage under "carry-on only"...',
    'Finding the one fact everyone will misinterpret...',
    'Making sure the lore doesn\'t outshine the scene...',
    'Compressing exposition until it becomes a gemstone...',
    'Checking continuity with a tiny flashlight and dread...',
    'Scanning the past for unpaid consequences...',
    'Wrapping key facts in bubble wrap and tension...',
    'Marking irrelevant lore as "decorative but illegal here"...'
  ],
  WRITING_OPENING_PAGE: [
    'Rolling out the opening scene carpet...',
    'Polishing first impressions with glitter...',
    'Cueing the cinematic entrance music...',
    'Placing the camera at maximum drama angle...',
    'Turning on the fog machine for ambience...',
    'Teaching the narrator to make eye contact...',
    'Warming up the dialogue with tongue twisters...',
    'Deploying tasteful thunder in the distance...',
    'Adjusting the spotlight to "mysterious but friendly"...',
    'Setting out fresh metaphors in a neat row...',
    'Tuning the opening line to perfect pitch...',
    'Adding one dramatic pause for seasoning...',
    'Sweeping confetti off the exposition runway...',
    'Calibrating the first sentence launch sequence...',
    'Installing mood lighting in paragraph one...',
    'Bribing the hook to land cleanly...',
    'Giving the protagonist a very determined eyebrow...',
    'Pressing record on the cinematic narrator voice...',
    'Rehearsing the first reveal with jazz hands...',
    'Opening the curtain on controlled narrative chaos...',
    'Unboxing the very first sentence with white gloves...',
    'Loading the intro cannon with premium intrigue...',
    'Hanging a neon sign that says "pay attention"...',
    'Deploying a carefully trained opening gasp...',
    'Teaching paragraph one how to strut confidently...',
    'Spritzing the scene with fresh-pressed atmosphere...',
    'Dialing the narrative camera to impossible close-up...',
    'Placing a breadcrumb trail of irresistible questions...',
    'Testing the hook on a focus group of daydreamers...',
    'Repainting the sky in chapter-one colors...',
    'Priming the conflict engine for immediate ignition...',
    'Adding velvet ropes around the first big reveal...',
    'Handing the narrator a megaphone and a secret...',
    'Sculpting the opening beat with dramatic chisels...',
    'Letting the first line do one theatrical bow...',
    'Tightening the intro knots with narrative pliers...',
    'Positioning the stakes where everyone can trip on them...',
    'Charging the prologue batteries to 100 percent...',
    'Inviting curiosity to kick down the front door...',
    'Setting the tone dial to "you are now invested"...',
    'Sending the opening shot through a glamour filter...',
    'Preheating the first page to cinematic temperature...',
    'Waxing the runway for a dramatic character entrance...',
    'Packing the intro with legally approved goosebumps...',
    'Cueing a choir of suspiciously relevant violins...',
    'Teaching the first paragraph to wink at the reader...',
    'Unleashing a tiny stampede of immediate questions...',
    'Giving the hook a cape and excellent timing...',
    'Rolling out red carpet for the inciting incident...',
    'Polishing the premise until it catches moonlight...',
    'Adjusting atmosphere levels to "electric storm"...',
    'Planting one breadcrumb and seven complications...',
    'Sneaking tension into the room through the vents...',
    'Ironing the opening beats until they snap...',
    'Installing fireworks behind the first reveal...',
    'Teaching chapter one to kick the door in politely...',
    'Loading the scene with premium-grade anticipation...',
    'Strapping a rocket booster to the first conflict...',
    'Rehearsing the cold open with dramatic fanfare...',
    'Spiking the intro punch bowl with intrigue...',
    'Rolling the first line down the runway like it owns the place...',
    'Handing the narrator a martini and a secret...',
    'Planting an inciting incident in a tasteful flowerpot...',
    'Turning the "mood" knob until it clicks ominously...',
    'Teaching the opening paragraph to flirt with danger...',
    'Launching the hook and yelling "stick the landing!"...',
    'Inflating atmosphere with a bicycle pump of suspense...',
    'Giving the setting a dramatic entrance and a name tag...',
    'Slipping a mystery under the door like a coupon...',
    'Arranging the first beat like a fancy charcuterie board...',
    'Warming up the tension with a gentle hiss...',
    'Introducing the protagonist with OSHA-certified charisma...',
    'Adding a cinematic zoom to a completely normal object...',
    'Letting chapter one kick a chair and apologize later...',
    'Sprinkling curiosity dust on everything not nailed down...',
    'Loading the opening with premium-grade "uh oh"...',
    'Teaching the first scene to smile with sharp teeth...',
    'Staging an accidental prophecy for ambiance...',
    'Polishing the opening image until it reflects anxiety...',
    'Installing a tiny siren behind the subtext...',
    'Serving the premise on a silver platter of problems...',
    'Tucking a loaded detail into a casual sentence...',
    'Giving the hook a whistle and a criminal record...',
    'Arranging coincidences so they look innocent...',
    'Starting with calm, then gently setting it on fire...',
    'Bringing in the conflict like it\'s late for work...',
    'Dropping a question mark from the ceiling dramatically...',
    'Teaching the opening to whisper "keep reading"...',
    'Rolling out the vibe carpet and tripping on it...',
    'Packing the first page with legally binding intrigue...',
    'Spicing the intro with a pinch of impending doom...',
    'Setting the scene like a candle, then blowing it out...',
    'Giving the narrator a wink and plausible deniability...',
    'Threading a promise through the first three sentences...',
    'Summoning the hook with interpretive dance and fog...'
  ],
  WRITING_CONTINUING_PAGE: [
    'Stitching consequences into the timeline...',
    'Keeping the plot train barely on the rails...',
    'Handing the scene to the next narrator...',
    'Adding one more suspiciously perfect twist...',
    'Refueling the momentum engine with cliffhangers...',
    'Untangling side quests from the chandelier...',
    'Passing notes between cause and effect...',
    'Patching continuity leaks with narrative gum...',
    'Setting the stakes to "gently terrifying"...',
    'Rotating the mystery box for better suspense...',
    'Escorting loose ends toward responsible adulthood...',
    'Threading foreshadowing through a tiny needle...',
    'Bolting the midpoint together with dramatic screws...',
    'Checking the subplot humidity levels...',
    'Giving consequences room to breathe ominously...',
    'Synchronizing character arcs with the moon phase...',
    'Reheating tension until pleasantly unstable...',
    'Guiding the pacing with a traffic baton...',
    'Sliding the dominoes into place with tweezers...',
    'Issuing plot passports for cross-scene travel...',
    'Escorting momentum past the valley of distractions...',
    'Tightening cause-and-effect with a torque wrench...',
    'Stacking fresh dilemmas like unstable pancakes...',
    'Refilling the tension reservoir one drop at a time...',
    'Sending character decisions through quality control...',
    'Keeping the subplot orchestra in the same tempo...',
    'Shoveling narrative coal into the third-act furnace...',
    'Documenting every consequence for legal reasons...',
    'Steering this chapter through emotional weather...',
    'Balancing revelations on a very narrow shelf...',
    'Adding controlled sparks to the conflict wiring...',
    'Rotating viewpoints to prevent dramatic traffic jams...',
    'Escalating stakes with OSHA-compliant urgency...',
    'Fastening the next beat with industrial foreshadowing...',
    'Checking dialogue pressure before the next release...',
    'Threading payoffs through active construction zones...',
    'Keeping the emotional RPMs in the red...',
    'Redirecting loose chaos into productive chaos...',
    'Feeding the suspense creature on a strict schedule...',
    'Escorting every choice toward glorious consequences...',
    'Passing the scene baton without dropping any secrets...',
    'Inflating the conflict balloon to optimal squeak...',
    'Splicing fresh momentum into the narrative bloodstream...',
    'Escorting revelations through a crowded hallway...',
    'Tightening suspense screws until they hum...',
    'Giving the stakes a double shot of espresso...',
    'Laying banana peels in front of bad decisions...',
    'Sweeping emotional shrapnel into future chapters...',
    'Keeping the tension kite aloft in crosswinds...',
    'Threading character growth through laser grids...',
    'Adding speed bumps before every easy answer...',
    'Scheduling consequences for prime-time impact...',
    'Greasing the plot gears with dramatic irony...',
    'Rolling the next complication down a marble track...',
    'Letting the subtext simmer on low chaos...',
    'Installing handrails on this slippery escalation...',
    'Routing every shortcut straight into trouble...',
    'Pressurizing the next beat for maximum pop...',
    'Funneling uncertainty into a very loud maybe...',
    'Keeping this chapter one decision away from disaster...',
    'Chasing continuity gremlins with a rolled-up newspaper...',
    'Topping up tension like it\'s windshield wiper fluid...',
    'Letting consequences jog in, out of breath...',
    'Turning a small choice into a large problem...',
    'Rehearsing a payoff, then hiding it behind a curtain...',
    'Taping foreshadowing under the table like chewing gum...',
    'Keeping the pacing from eating the furniture...',
    'Adding a complication because the plot looked comfortable...',
    'Massaging the timeline until it stops making that noise...',
    'Redirecting a subplot that wandered into traffic...',
    'Escorting loose ends toward responsible closure...',
    'Handing the characters a situation and watching it explode...',
    'Folding tension into the dialogue like secret origami...',
    'Installing a new dilemma where the hallway used to be...',
    'Turning up the stakes and snapping the knob off...',
    'Refilling suspense from the big jug labeled "don\'t ask"...',
    'Sliding cause-and-effect into place with jazz hands...',
    'Pulling a thread and pretending it was always there...',
    'Keeping the plot upright with emotional scaffolding...',
    'Giving the protagonist a new reason to regret breathing...',
    'Sprinkling subtext like parmesan over the scene...',
    'Shuffling revelations until one bites us...',
    'Letting the quiet moment load a slingshot...',
    'Adding a pause so heavy it needs its own chair...',
    'Dragging the story forward by its confident little ankles...',
    'Handing the scene a banana peel of irony...',
    'Replacing "maybe" with "oh no" in the margins...',
    'Tightening the screws on a perfectly good situation...',
    'Teaching the next beat to arrive with a smirk...',
    'Flipping the hourglass and watching everyone panic...',
    'Stacking problems neatly so they fall better later...',
    'Making the consequences sign in at the front desk...',
    'Laying down foreshadowing like suspicious breadcrumbs...',
    'Installing a cliffhanger with childproof locks...',
    'Steering the chapter through emotional potholes...'
  ],
  ANALYZING_SCENE: [
    'Checking the scene for narrative wobble...',
    'Comparing outcomes with the prophecy chart...',
    'Scanning for hidden cause-and-effect crumbs...',
    'Measuring tension levels with a tiny ruler...',
    'Dusting the clues for emotional fingerprints...',
    'Listening for suspiciously meaningful silence...',
    'Highlighting motifs in five shades of concern...',
    'Interrogating the subtext under bright lights...',
    'Charting who knows what on a corkboard...',
    'Running diagnostics on dramatic timing...',
    'Counting unresolved questions on both hands...',
    'Testing each beat for maximum narrative bounce...',
    'Inspecting dialogue for secret trapdoors...',
    'Triangulating intent, action, and fallout...',
    'Separating facts from very confident guesses...',
    'Scanning the room for Chekhov objects...',
    'Stress-testing the logic with a rubber hammer...',
    'Weighing emotional impact on calibrated scales...',
    'Decoding facial expressions into strategic data...',
    'Marking potential plot potholes with neon flags...',
    'Running forensic tests on suspicious adverbs...',
    'Cross-examining every beat for motive and means...',
    'Measuring subtext depth with sonar equipment...',
    'Cataloging narrative anomalies by timestamp...',
    'Comparing stated goals to actual chaos produced...',
    'Tracing dramatic footprints across the scene floor...',
    'Stress-auditing every reaction for plausibility...',
    'Triaging unresolved tension by urgency level...',
    'Putting each line under a microscope of intent...',
    'Building an evidence board out of eyebrow raises...',
    'Searching for quiet details doing loud work...',
    'Tagging emotional pivots with forensic tape...',
    'Verifying that every reveal earns its oxygen...',
    'Checking continuity seams for daylight leaks...',
    'Profiling conflict patterns for repeat offenders...',
    'Testing interpretation theories in a wind tunnel...',
    'Flagging dialogue that knows too much too soon...',
    'Auditing who changed, why, and at what cost...',
    'Reconstructing the scene from consequence fragments...',
    'Checking whether the silence says more than the speech...',
    'Running motive prints through the clue database...',
    'Timing each pause with a suspense stopwatch...',
    'Sampling the vibe for trace amounts of foreshadowing...',
    'Inspecting reactions for counterfeit confidence...',
    'Charting emotional weather by line and gesture...',
    'Testing every alibi under a hot desk lamp...',
    'Mapping power shifts with tiny magnetic arrows...',
    'Verifying who blinked first and why...',
    'Sifting dialogue sediment for hidden gold...',
    'Comparing what was said to what was swallowed...',
    'X-raying the scene for concealed turning points...',
    'Measuring dramatic friction with calibrated gloves...',
    'Isolating the exact moment the room changed shape...',
    'Tagging suspicious coincidences for lab review...',
    'Checking whether each choice leaves a footprint...',
    'Triangulating tension from tone, timing, and eye contact...',
    'Profiling every beat for intent-to-impact ratio...',
    'Stress-testing assumptions against inconvenient facts...',
    'Pinning red yarn between questions and consequences...',
    'Auditing the unspoken stuff for maximum significance...',
    'Putting the scene in a vibes MRI...',
    'Running the dialogue through a truth-detector toaster...',
    'Checking subtext levels with a haunted thermometer...',
    'Counting motive fingerprints under a blacklight...',
    'Weighing the silence to see if it\'s hiding snacks...',
    'Testing each beat for structural "oops" noises...',
    'Shaking the scene gently to see what falls out...',
    'Measuring tension like it\'s flour (and we forgot a cup)...',
    'Auditing reactions for suspicious freshness...',
    'Inspecting eyebrow movement for hidden contracts...',
    'Running a background check on that "casual" detail...',
    'Cross-examining the pacing like a stern accountant...',
    'Checking if the stakes are actually doing their job...',
    'Highlighting the moment everything got weird...',
    'Comparing intentions to outcomes with a disappointed sigh...',
    'Tagging emotional pivots with bright orange cones...',
    'Searching for clues disguised as furniture...',
    'Tracking power shifts with tiny angry arrows...',
    'Verifying that the reveal didn\'t teleport in...',
    'Checking for plot holes large enough to rent...',
    'Analyzing the scene\'s aura for trace foreshadowing...',
    'Looking for the exact line that started the fire...',
    'Interrogating coincidence until it confesses...',
    'Mapping who\'s lying, who\'s coping, who\'s thriving...',
    'Examining the tone for unauthorized genre drift...',
    'Testing plausibility by poking it with a stick...',
    'Checking whether the conflict has a pulse...',
    'Noting which detail is going to hurt later...',
    'Running the scene through the “does this land?” trampoline...',
    'Diagnosing emotional whiplash with a tiny clipboard...',
    'Profiling the subtext like it owes us money...',
    'Confirming the stakes aren\'t just decorative...',
    'Counting unresolved questions and losing count...',
    'Scanning the scene for Chekhov\'s suspicious lampshade...',
    'Replaying the moment with slow-motion panic...'
  ],
  STRUCTURING_STORY: [
    'Pouring the foundation for a brand-new story...',
    'Surveying the narrative landscape for load-bearing themes...',
    'Mixing dramatic concrete to spec...',
    'Driving stakes into the thematic bedrock...',
    'Unrolling the master blueprint across the table...',
    'Marking where the first act wall goes...',
    'Hammering together the scaffolding of destiny...',
    'Laying rebar through the dramatic spine...',
    'Consulting the structural engineer about tension loads...',
    'Measuring twice, building once (hopefully)...',
    'Excavating the foundation for maximum gravitas...',
    'Installing the central pillar of conflict...',
    'Framing the first-act doorway with ceremonial studs...',
    'Bolting the thematic crossbeams into place...',
    'Pouring fresh footings under the premise...',
    'Raising the ridge beam between setup and payoff...',
    'Running narrative plumbing through the walls...',
    'Wiring the foreshadowing circuits into the framing...',
    'Hanging the plot trusses with calculated precision...',
    'Leveling the story foundation with a laser of intent...',
    'Anchoring character arcs to the structural grid...',
    'Fitting tension joists between act one and act two...',
    'Erecting the scaffolding around a promising premise...',
    'Sketching load paths for maximum emotional impact...',
    'Securing permits for dramatic escalation...',
    'Pouring the slab that all future chaos rests upon...',
    'Setting corner stones at each act boundary...',
    'Welding the inciting incident to the main truss...',
    'Inspecting the blueprint for adequate twist clearance...',
    'Building the framework one dramatic beam at a time...',
    'Planting the structural columns of rising action...',
    'Laying ductwork for the flow of consequences...',
    'Installing load-bearing themes at critical junctions...',
    'Nailing the opening header with confident swings...',
    'Calibrating the arc crane for heavy lifting...',
    'Framing rooms for confrontation, revelation, and regret...',
    'Threading steel cables through the narrative skeleton...',
    'Bracing the midpoint against predictable collapse...',
    'Testing soil density under the emotional foundation...',
    'Raising walls between what was and what will be...',
    'Drafting elevation views of the dramatic landscape...',
    'Scheduling the climax pour for optimal curing...',
    'Installing the damp course against genre seepage...',
    'Fitting the keystone into the thematic archway...',
    'Mapping utility routes for subplot distribution...',
    'Templating window openings for dramatic reveals...',
    'Checking that the blueprint survives its own ambition...',
    'Assembling the crane to lift the central conflict...',
    'Grouting the gaps between intention and execution...',
    'Setting expansion joints for character growth...',
    'Bolting the inciting incident to solid ground...',
    'Constructing the staircase from setup to catastrophe...',
    'Verifying the shear walls can handle plot twists...',
    'Hoisting the narrative ridgepole into final position...',
    'Compacting the subgrade before laying down themes...',
    'Installing fire stops between volatile subplots...',
    'Roughing in the dramatic plumbing before drywall...',
    'Squaring the corners where acts meet...',
    'Ordering the correct gauge of suspense wire...',
    'Backfilling around the freshly poured premise...',
    'Marking elevation benchmarks for rising tension...',
    'Strapping hurricane ties onto the climax frame...',
    'Routing the emotional HVAC through every chapter...',
    'Gluing laminated beams of layered meaning together...',
    'Setting the formwork for a freshly poured conflict...',
    'Troweling the surface of a brand-new dramatic slab...',
    'Plumbing the depths for a solid thematic footing...',
    'Craning the first major reveal into position...',
    'Shimming the structure until the themes sit plumb...',
    'Chalking lines on the subfloor of possibility...',
    'Fastening joist hangers to the backbone of the plot...',
    'Curing the premise under controlled dramatic heat...',
    'Shooting grade with a transit of narrative intent...',
    'Staking out the lot lines of genre and tone...',
    'Vibrating the concrete to remove pockets of cliché...',
    'Tying rebar knots at every critical junction...',
    'Snapping chalk lines between the first scene and the last...',
    'Forming the footings for a multi-act structure...',
    'Torquing the anchor bolts on the story\'s foundation...',
    'Cutting the ribbon on a freshly framed narrative...',
    'Dry-fitting the plot skeleton before final assembly...',
    'Installing temporary bracing until the story cures...',
    'Blueprinting emergency exits from every dead end...',
    'Aligning the laser level with thematic true north...',
    'Backfilling the foundation trench with backstory...',
    'Sealing the vapor barrier against tone leaks...',
    'Placing embed plates for future character attachments...',
    'Inspecting the rebar cage before the big pour...',
    'Setting string lines for perfectly straight story arcs...',
    'Mixing a batch of structural-grade dramatic tension...',
    'Tamping the gravel base of worldbuilding details...',
    'Installing the sill plate on a freshly leveled premise...',
    'Raising the first wall panel with a satisfying thunk...',
    'Certifying the foundation for occupancy by characters...',
    'Breaking ground on a promising new narrative site...',
  ],
  RESTRUCTURING_STORY: [
    'Rearranging story beams without waking dragons...',
    'Tightening bolts on the adventure skeleton...',
    'Re-threading plot cables behind the walls...',
    'Deploying emergency structure duct tape...',
    'Moving chapter furniture with narrative dollies...',
    'Replacing squeaky scenes with reinforced tension...',
    'Installing support arcs under weak spots...',
    'Rerouting character traffic to reduce pileups...',
    'Welding the midpoint to the ending frame...',
    'Stacking stakes where they can do the most damage...',
    'Refitting transitions with smoother gears...',
    'Laying fresh track for the final act train...',
    'Demolishing one wobbly beat at a safe distance...',
    'Reinforcing the foundation with consequence cement...',
    'Hoisting the payoff into load-bearing position...',
    'Rebalancing the structure for emotional wind...',
    'Rewiring callbacks to the main power grid...',
    'Swapping in a sturdier sequence of events...',
    'Labeling every moving part "fragile but important"...',
    'Running final inspections with a hard hat...',
    'Relocating major twists to safer load-bearing chapters...',
    'Installing seismic braces for surprise reveals...',
    'Regrading the slope so tension flows downhill...',
    'Replacing narrative scaffolding with permanent supports...',
    'Cutting new doorways between disconnected scenes...',
    'Rebalancing act breaks to avoid dramatic sinkholes...',
    'Retrofitting the climax with reinforced cause-and-effect...',
    'Demoting decorative detours to optional side streets...',
    'Rerouting exposition through cleaner pipelines...',
    'Re-centering the core conflict on solid bedrock...',
    'Lifting sagging subplots with hydraulic jacks...',
    'Refitting the opening so the ending actually fits...',
    'Realigning chapter joints for smoother movement...',
    'Bolstering weak transitions with structural callbacks...',
    'Converting dead-end beats into through-lines...',
    'Consolidating duplicate conflicts into one heavy hitter...',
    'Replacing narrative bloat with precision-engineered stakes...',
    'Moving the emotional keystone back into place...',
    'Repainting the whole arc with clearer contrast...',
    'Running a full structural scan before reopening...',
    'Installing shock absorbers on every major twist...',
    'Redistributing weight away from the saggy middle...',
    'Replacing decorative scenes with load-bearing drama...',
    'Threading steel cables through the act breaks...',
    'Reinforcing weak joints with callback brackets...',
    'Rebuilding the climax staircase to code...',
    'Moving exposition crates off emergency exits...',
    'Swapping brittle beats for tempered story glass...',
    'Pouring fresh concrete under the central conflict...',
    'Converting narrative dead space into useful corridors...',
    'Retensioning the arc so it does not wobble...',
    'Installing pressure valves for high-stakes moments...',
    'Aligning every subplot gear with the master crank...',
    'Reframing chapter walls to fit bigger payoffs...',
    'Replacing mystery drywall with transparent intent...',
    'Upgrading transitions from rope bridge to highway...',
    'Hoisting delayed consequences into plain view...',
    'Routing emotional load through stronger pillars...',
    'Removing decorative scaffolds still pretending to be scenes...',
    'Checking the whole structure for sequel-proof stability...',
    'Dragging Act Two back into the building by the collar...',
    'Installing load-bearing consequences where vibes used to be...',
    'Refactoring the plot like it\'s legacy code from 2009...',
    'Moving scenes around until the story stops hissing...',
    'Welding character arcs into a sturdier triangle...',
    'Replacing a weak beat with a stronger, angrier beat...',
    'Rerouting exposition through a tunnel marked “fun”...',
    'Rebalancing the middle so it stops sagging politely...',
    'Turning a detour into a shortcut with a crowbar...',
    'Swapping two chapters and pretending it was destiny...',
    'Tightening the arc until it makes a satisfying click...',
    'Removing decorative scenes that keep stealing oxygen...',
    'Bolting the climax onto the rest of the story properly...',
    'Upgrading transitions from "teleport" to "walk"...',
    'Cutting a new doorway between two stubborn moments...',
    'Rehousing a twist in a safer, louder neighborhood...',
    'Patching story seams with industrial-grade foreshadowing...',
    'Repositioning the emotional keystone with heavy machinery...',
    'Consolidating three minor problems into one huge problem...',
    'Replacing narrative fluff with concentrated menace...',
    'Rebuilding the payoff staircase so it won\'t collapse...',
    'Installing a support beam under this shaky motivation...',
    'Moving the reveal earlier before it misses the bus...',
    'Re-threading the through-line until it stops unraveling...',
    'Shoving the plot back onto the rails with a forklift...',
    'Demoting a scene to "optional content" with a stern look...',
    'Aligning subplots so they stop arguing in public...',
    'Fixing the pacing with a wrench and hurt feelings...',
    'Sanding down a clunky beat until it sparkles dangerously...',
    'Replacing "and then" with "therefore" in the walls...',
    'Reattaching the beginning to the ending with duct tape...',
    'Giving the story a posture correction and a pep talk...',
    'Pulling the arc taut like a bowstring of doom...',
    'Reinforcing the theme so it can survive impact...',
    'Re-casting a coincidence as a consequence (shhh)...'
  ],
  DECOMPOSING_ENTITIES: [
    'Cataloguing every nervous tic and catchphrase...',
    'Cross-referencing NPC gossip with confirmed facts...',
    'Teaching the quill to mimic everyone\'s handwriting...',
    'Filing worldbuilding lore under "probably important"...',
    'Extracting verbal DNA from character descriptions...',
    'Interviewing each character about their favorite words...',
    'Sorting personality traits into labeled jars...',
    'Building a voice-print database from scratch...',
    'Mapping every relationship on a giant corkboard...',
    'Translating "mysterious backstory" into useful bullet points...',
    'Asking NPCs to say "the quick brown fox" for calibration...',
    'Recording speech patterns with a tiny narrative microphone...',
    'Filing character motivations by urgency and pettiness...',
    'Decomposing worldbuilding into bite-sized propositions...',
    'Teaching the engine to tell characters apart by voice...',
    'Pressing flowers from the worldbuilding garden into facts...',
    'Labeling every character quirk with a color-coded sticky note...',
    'Running personality tests on fictional people...',
    'Extracting catchphrases like they\'re rare gemstones...',
    'Studying who says "indeed" vs "yeah" vs "hmm"...',
    'Converting prose descriptions into structured dossiers...',
    'Giving each NPC a vocal fingerprint and a file number...',
    'Distilling character essays into personality espresso...',
    'Sorting knowledge boundaries so nobody cheats...',
    'Building a pronunciation guide for made-up words...',
    'Auditing character voices for accidental cloning...',
    'Tagging every world fact with its jurisdiction...',
    'Separating character from caricature with tiny tweezers...',
    'Filing appearance notes under "will need this later"...',
    'Ensuring no two characters accidentally sound like twins...',
    'Deconstructing personalities without a license...',
    'Organizing motivations by "noble" and "suspicious"...',
    'Archiving verbal tics for scene-appropriate deployment...',
    'Cross-checking speech samples against the originality index...',
    'Turning worldbuilding essays into indexed fact cards...',
    'Giving each character a unique linguistic thumbprint...',
    'Sorting relationship dynamics by emotional voltage...',
    'Extracting knowledge boundaries like careful surgery...',
    'Teaching the engine who knows what and who doesn\'t...',
    'Assembling character profiles with forensic precision...',
    'Bottling each voice like a rare perfume...',
    'Reading between the lines of every NPC description...',
    'Building a fact atlas of the fictional universe...',
    'Tuning the voice detector to catch subtle dialect shifts...',
    'Pressing raw lore into neat, domain-stamped tablets...',
    'Asking each character to demonstrate their "thinking face"...',
    'Measuring the gap between "what they say" and "how they say it"...',
    'Constructing a Rosetta Stone of character dialects...',
    'Encoding world rules into machine-readable prophecy...',
    'Polishing character profiles until they gleam distinctly...',
  ],
  RESOLVING_AGENDAS: [
    'Eavesdropping on NPCs whispering behind closed doors...',
    'Reviewing everyone\'s secret diary entries...',
    'Tracking who stabbed whom in the back today...',
    'Calculating grudge interest rates...',
    'Checking which NPCs are plotting revenge...',
    'Updating the grudge board with fresh pins...',
    'Listening at keyholes for nefarious scheming...',
    'Tallying up who owes favors to whom...',
    'Unfolding a corkboard of overlapping schemes...',
    'Cataloging side-eye incidents for future reference...',
    'Intercepting coded notes between shady allies...',
    'Checking whether anyone upgraded their backstabbing gear...',
    'Reviewing minutes from the secret villains\' brunch...',
    'Counting how many NPCs muttered "soon" this chapter...',
    'Auditing off-screen mischief reports...',
    'Filing incident reports for unsanctioned scheming...',
    'Measuring the ambient levels of treachery...',
    'Polling NPCs on their current treachery satisfaction...',
    'Cross-referencing alibis with suspicious absences...',
    'Recalculating everyone\'s loyalty scores...',
    'Monitoring the rumor mill for fresh gossip...',
    'Updating the conspiracy flowchart...',
    'Checking which NPCs have been pacing suspiciously...',
    'Reviewing blackmail material inventories...',
    'Verifying whether anyone sent ravens this turn...',
    'Scanning for dramatic monologue rehearsals...',
    'Adjusting NPC ambition sliders...',
    'Cataloging nervous glances exchanged this chapter...',
    'Running background checks on everyone\'s motives...',
    'Noting which NPCs smiled at the wrong moment...',
    'Tabulating petty feuds and ancient grudges...',
    'Sorting agendas by desperation level...',
    'Checking who\'s been sharpening metaphorical knives...',
    'Decoding passive-aggressive gift exchanges...',
    'Reviewing who has been suspiciously helpful lately...',
    'Evaluating the off-screen power shuffle...',
    'Tracking alliance formation and betrayal timelines...',
    'Checking which NPCs have contingency plans...',
    'Measuring fear levels against leverage ratios...',
    'Updating the "Who Wants What" spreadsheet...',
    'Intercepting a messenger pigeon with interesting news...',
    'Analyzing NPC body language from last scene...',
    'Checking if any NPCs have developed new anxieties...',
    'Reviewing the NPC suggestion box...',
    'Detecting a shift in the balance of scheming...',
    'Comparing stated intentions with actual behavior...',
    'Auditing the NPC snack cabinet for stress eating...',
    'Marking territories on the political influence map...',
    'Checking if anyone moved their chess pieces overnight...',
    'Reviewing suspicious purchases from the last chapter...',
    'Verifying that no one switched sides during the break...',
    'Running a threat assessment on recent compliments...',
    'Cataloging unfinished sentences and loaded pauses...',
    'Checking for unsigned letters slid under doors...',
    'Recalculating the probability of betrayal per NPC...',
    'Reviewing who has been making too many promises...',
    'Tracking which NPCs avoided eye contact this scene...',
    'Flagging characters with implausibly clean hands...',
    'Noting who laughed a little too long at dinner...',
    'Updating the off-screen activity ledger...',
    'Checking the villain\'s calendar for “light treason” slots...',
    'Reading NPC thoughts like it\'s gossip magazine hour...',
    'Updating everyone\'s "who do I hate today?" playlist...',
    'Monitoring suspiciously polite smiles for hidden knives...',
    'Counting how many schemes are currently fermenting...',
    'Watching alliances form like mold in a dark fridge...',
    'Checking who just leveled up in pettiness...',
    'Auditing the off-screen shenanigans ledger...',
    'Refreshing the “Who Wants What” dashboard (it screams)...',
    'Intercepting a whisper and billing it for drama...',
    'Tracking passive-aggression like it\'s a rare animal...',
    'Checking the rumor mill\'s RPMs...',
    'Inspecting favors like they\'re ticking time bombs...',
    'Noting which NPC is one compliment away from betrayal...',
    'Reviewing blackmail inventories for seasonal updates...',
    'Scanning for new rivalries blooming in the wild...',
    'Timing how long before someone says "trust me"...',
    'Checking if anyone\'s "helpfulness" seems weaponized...',
    'Recalculating loyalty after that one eyebrow raise...',
    'Measuring treachery levels in parts per million...',
    'Verifying who just sent a "totally normal" letter...',
    'Watching the power dynamics do a little dance...',
    'Checking which NPC is speedrunning revenge...',
    'Updating the conspiracy corkboard with fresh spaghetti...',
    'Listening for the sound of plans being made without us...',
    'Tracking who\'s collecting leverage like shiny coins...',
    'Marking territories on the influence map with crayons...',
    'Checking who\'s stress-eating near the secret door...',
    'Reviewing the villain group chat highlights...',
    'Detecting new agendas forming in the narrative fog...',
    'Following a trail of side-eyes to its source...',
    'Confirming who just became a problem on purpose...',
    'Noting which promise is about to come due with interest...',
    'Watching friendships develop structural weaknesses...',
    'Counting how many NPCs just said "interesting" too slowly...'
  ],
};
const STAGE_DISPLAY_NAMES = {
  GENERATING_SPINE: 'ENVISIONING',
  PLANNING_PAGE: 'PLANNING',
  ACCOUNTING_STATE: 'ACCOUNTING',
  CURATING_CONTEXT: 'LOREKEEPING',
  WRITING_OPENING_PAGE: 'WRITING',
  WRITING_CONTINUING_PAGE: 'WRITING',
  ANALYZING_SCENE: 'ANALYZING',
  STRUCTURING_STORY: 'STRUCTURING',
  DECOMPOSING_ENTITIES: 'STUDYING',
  RESTRUCTURING_STORY: 'RESTRUCTURING',
  RESOLVING_AGENDAS: 'SCHEMING',
};

// ── Choice / Delta enums and label maps ──────────────────────────

var CHOICE_TYPES = [
  { value: 'TACTICAL_APPROACH', label: 'Method/Tactic' },
  { value: 'MORAL_DILEMMA', label: 'Moral Choice' },
  { value: 'IDENTITY_EXPRESSION', label: 'Define Yourself' },
  { value: 'RELATIONSHIP_SHIFT', label: 'Relationship' },
  { value: 'RESOURCE_COMMITMENT', label: 'Spend/Risk' },
  { value: 'INVESTIGATION', label: 'Investigate' },
  { value: 'PATH_DIVERGENCE', label: 'Change Direction' },
  { value: 'CONFRONTATION', label: 'Confront/Fight' },
  { value: 'AVOIDANCE_RETREAT', label: 'Avoid/Flee' },
];

var PRIMARY_DELTAS = [
  { value: 'LOCATION_CHANGE', label: 'Location' },
  { value: 'GOAL_SHIFT', label: 'Goal' },
  { value: 'RELATIONSHIP_CHANGE', label: 'Relationship' },
  { value: 'URGENCY_CHANGE', label: 'Time Pressure' },
  { value: 'ITEM_CONTROL', label: 'Item' },
  { value: 'EXPOSURE_CHANGE', label: 'Attention' },
  { value: 'CONDITION_CHANGE', label: 'Condition' },
  { value: 'INFORMATION_REVEALED', label: 'Information' },
  { value: 'THREAT_SHIFT', label: 'Danger' },
  { value: 'CONSTRAINT_CHANGE', label: 'Limitation' },
];

var CHOICE_TYPE_LABEL_MAP = {};
CHOICE_TYPES.forEach(function (ct) { CHOICE_TYPE_LABEL_MAP[ct.value] = ct.label; });

var PRIMARY_DELTA_LABEL_MAP = {};
PRIMARY_DELTAS.forEach(function (pd) { PRIMARY_DELTA_LABEL_MAP[pd.value] = pd.label; });

  // ── Utility functions ──────────────────────────────────────────────

  function getApiKey() {
    return sessionStorage.getItem(API_KEY_STORAGE_KEY);
  }

  function setApiKey(key) {
    sessionStorage.setItem(API_KEY_STORAGE_KEY, key);
  }

  function createProgressId() {
    if (window.crypto && typeof window.crypto.randomUUID === 'function') {
      return window.crypto.randomUUID();
    }

    return 'progress-' + Date.now() + '-' + Math.random().toString(16).slice(2);
  }

  function getRandomInt(minInclusive, maxInclusive) {
    return Math.floor(Math.random() * (maxInclusive - minInclusive + 1)) + minInclusive;
  }

  function pickRandomPhrase(phrases, previousPhrase) {
    if (!Array.isArray(phrases) || phrases.length === 0) {
      return '';
    }

    if (phrases.length === 1) {
      return phrases[0];
    }

    var selected = phrases[getRandomInt(0, phrases.length - 1)];
    while (selected === previousPhrase) {
      selected = phrases[getRandomInt(0, phrases.length - 1)];
    }
    return selected;
  }

  function escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = String(text ?? '');
    return div.innerHTML;
  }

  function escapeHtmlWithBreaks(text) {
    return escapeHtml(text).replace(/\n/g, '<br>');
  }

  function enumToIconName(enumValue) {
    if (typeof enumValue !== 'string' || enumValue.length === 0) {
      return '';
    }
    return enumValue.toLowerCase().replace(/_/g, '-');
  }

  function getIconPath(enumValue) {
    var name = enumToIconName(enumValue);
    return name ? '/images/icons/' + name + '.png' : '';
  }

  function getThreadIconPath(threadType, urgency) {
    if (typeof threadType !== 'string' || threadType.length === 0) {
      return '';
    }
    if (typeof urgency !== 'string' || urgency.length === 0) {
      return '';
    }
    return '/images/icons/thread-' + threadType.toLowerCase() + '-' + urgency.toLowerCase() + '.png';
  }


  // ── Loading progress controller ────────────────────────────────────

  function createLoadingProgressController(loadingElement) {
    var stageTextElement = loadingElement ? loadingElement.querySelector('.loading-stage') : null;
    var statusTextElement = loadingElement
      ? loadingElement.querySelector('.loading-status') || loadingElement.querySelector('p')
      : null;
    var fallbackText = statusTextElement && statusTextElement.textContent
      ? statusTextElement.textContent
      : 'Loading...';
    var stopped = true;
    var progressId = '';
    var currentStage = null;
    var currentPhrase = '';
    var pollTimeout = null;
    var phraseTimeout = null;

    function setStatusText(text) {
      if (statusTextElement) {
        statusTextElement.textContent = text;
      }
    }

    function setStageText(stageName) {
      if (stageTextElement) {
        stageTextElement.textContent = stageName || '';
      }
    }

    function clearTimers() {
      if (pollTimeout !== null) {
        clearTimeout(pollTimeout);
        pollTimeout = null;
      }
      if (phraseTimeout !== null) {
        clearTimeout(phraseTimeout);
        phraseTimeout = null;
      }
    }

    function setFallbackText() {
      currentStage = null;
      currentPhrase = '';
      if (phraseTimeout !== null) {
        clearTimeout(phraseTimeout);
        phraseTimeout = null;
      }
      setStageText('');
      setStatusText(fallbackText);
    }

    function schedulePhraseRotation() {
      if (phraseTimeout !== null) {
        clearTimeout(phraseTimeout);
        phraseTimeout = null;
      }

      if (stopped || !currentStage) {
        return;
      }

      var phrases = STAGE_PHRASE_POOLS[currentStage];
      if (!Array.isArray(phrases) || phrases.length === 0) {
        return;
      }

      var delay = getRandomInt(PHRASE_ROTATION_MIN_MS, PHRASE_ROTATION_MAX_MS);
      phraseTimeout = window.setTimeout(function() {
        if (stopped || !currentStage) {
          return;
        }
        currentPhrase = pickRandomPhrase(phrases, currentPhrase);
        setStatusText(currentPhrase);
        schedulePhraseRotation();
      }, delay);
    }

    function applyStage(stage) {
      var phrases = STAGE_PHRASE_POOLS[stage];
      if (!Array.isArray(phrases) || phrases.length === 0) {
        setFallbackText();
        return;
      }

      if (currentStage !== stage) {
        currentStage = stage;
        setStageText(STAGE_DISPLAY_NAMES[stage] || '');
        currentPhrase = '';
        currentPhrase = pickRandomPhrase(phrases, currentPhrase);
        setStatusText(currentPhrase);
        schedulePhraseRotation();
        return;
      }

      if (phraseTimeout === null) {
        schedulePhraseRotation();
      }
    }

    async function pollProgress() {
      if (stopped || !progressId) {
        return;
      }

      try {
        var response = await fetch('/generation-progress/' + encodeURIComponent(progressId), {
          cache: 'no-store',
        });

        if (!response.ok) {
          throw new Error('Progress polling failed');
        }

        var snapshot = await response.json();
        if (snapshot.status === 'running') {
          if (typeof snapshot.activeStage === 'string') {
            applyStage(snapshot.activeStage);
          } else {
            setFallbackText();
          }
        } else if (snapshot.status === 'unknown') {
          setFallbackText();
        } else if (snapshot.status === 'completed' || snapshot.status === 'failed') {
          stop();
          return;
        } else {
          setFallbackText();
        }
      } catch (_error) {
        setFallbackText();
      }

      if (!stopped) {
        pollTimeout = window.setTimeout(pollProgress, PROGRESS_POLL_INTERVAL_MS);
      }
    }

    function start(newProgressId) {
      stop();
      progressId = newProgressId;
      stopped = false;
      setFallbackText();
      void pollProgress();
    }

    function stop() {
      stopped = true;
      progressId = '';
      currentStage = null;
      currentPhrase = '';
      clearTimers();
      setStatusText(fallbackText);
    }

    return {
      start: start,
      stop: stop,
    };
  }


  // ── Thread renderers ──────────────────────────────────────────────

  function renderThreadBadgePill(threadType, urgency) {
    var iconPath = getThreadIconPath(threadType, urgency);
    var html = '<span class="thread-icon-pill" aria-hidden="true">';

    html += '<span class="thread-icon-badge">';
    if (iconPath) {
      html += '<img class="thread-icon"'
        + ' src="' + escapeHtml(iconPath) + '"'
        + ' alt="" title="' + escapeHtml(threadType + ' (' + urgency + ')') + '"'
        + ' loading="lazy"'
        + " onerror=\"this.style.display='none'\">";
    }
    html += '</span>';

    html += '</span>';
    return html;
  }

  function renderThreatBadgePill(threatType) {
    var threatTypeIconPath = getIconPath('threat_' + threatType);
    var html = '<span class="thread-icon-pill" aria-hidden="true">';

    html += '<span class="thread-icon-badge thread-icon-badge--type thread-icon-badge--threat">';
    if (threatTypeIconPath) {
      html += '<img class="thread-icon thread-icon--type thread-icon--threat"'
        + ' src="' + escapeHtml(threatTypeIconPath) + '"'
        + ' alt="" title="' + escapeHtml(threatType) + '"'
        + ' loading="lazy"'
        + " onerror=\"this.style.display='none'\">";
    }
    html += '</span>';

    html += '</span>';
    return html;
  }

  function renderConstraintBadgePill(constraintType) {
    var constraintTypeIconPath = getIconPath('constraint_' + constraintType);
    var html = '<span class="thread-icon-pill" aria-hidden="true">';

    html += '<span class="thread-icon-badge thread-icon-badge--type">';
    if (constraintTypeIconPath) {
      html += '<img class="thread-icon thread-icon--type"'
        + ' src="' + escapeHtml(constraintTypeIconPath) + '"'
        + ' alt="" title="' + escapeHtml(constraintType) + '"'
        + ' loading="lazy"'
        + " onerror=\"this.style.display='none'\">";
    }
    html += '</span>';

    html += '</span>';
    return html;
  }

  function getOpenThreadUrgencyClass(urgency) {
    if (urgency === 'HIGH') {
      return 'open-threads-text--high';
    }
    if (urgency === 'MEDIUM') {
      return 'open-threads-text--medium';
    }
    if (urgency === 'LOW') {
      return 'open-threads-text--low';
    }
    return 'open-threads-text--low';
  }

  function getUrgencyPriority(urgency) {
    if (urgency === 'HIGH') {
      return 0;
    }
    if (urgency === 'MEDIUM') {
      return 1;
    }
    if (urgency === 'LOW') {
      return 2;
    }
    return 3;
  }

  function buildOpenThreadOverflowSummary(hiddenThreads) {
    if (!Array.isArray(hiddenThreads) || hiddenThreads.length === 0) {
      return null;
    }

    var highCount = 0;
    var mediumCount = 0;
    var lowCount = 0;

    hiddenThreads.forEach(function(thread) {
      if (thread.urgency === 'HIGH') {
        highCount += 1;
        return;
      }
      if (thread.urgency === 'MEDIUM') {
        mediumCount += 1;
        return;
      }
      if (thread.urgency === 'LOW') {
        lowCount += 1;
      }
    });

    var parts = [];
    if (highCount > 0) {
      parts.push(highCount + ' (high)');
    }
    if (mediumCount > 0) {
      parts.push(mediumCount + ' (medium)');
    }
    if (lowCount > 0) {
      parts.push(lowCount + ' (low)');
    }

    if (parts.length === 0) {
      return null;
    }

    return 'Not shown: ' + parts.join(', ');
  }

  function ensureSidebarContainer() {
    return document.getElementById('sidebar-widgets');
  }

  function cleanupEmptySidebar() {
    // Container is a grid cell; never remove it
  }

  function renderOpenThreadsPanel(openThreads, openThreadOverflowSummary, sidebarContainer) {
    const existingPanel = document.getElementById('open-threads-panel');

    if (!Array.isArray(openThreads) || openThreads.length === 0) {
      if (existingPanel) {
        existingPanel.remove();
      }
      return;
    }

    const normalizedThreads = openThreads
      .map(function(thread, index) {
        if (!thread || typeof thread !== 'object') {
          return null;
        }

        var id = typeof thread.id === 'string' ? thread.id : '';
        var text = typeof thread.text === 'string' ? thread.text : '';
        var threadType = typeof thread.threadType === 'string' ? thread.threadType : '';
        var urgency = typeof thread.urgency === 'string' ? thread.urgency : '';

        if (!id || !text || !threadType || !urgency) {
          return null;
        }

        return { id: id, text: text, threadType: threadType, urgency: urgency, index: index };
      })
      .filter(function(thread) {
        return thread !== null;
      })
      .sort(function(left, right) {
        var urgencyDelta = getUrgencyPriority(left.urgency) - getUrgencyPriority(right.urgency);
        if (urgencyDelta !== 0) {
          return urgencyDelta;
        }
        return left.index - right.index;
      });

    if (normalizedThreads.length === 0) {
      if (existingPanel) {
        existingPanel.remove();
      }
      return;
    }

    const visibleThreads = normalizedThreads.slice(0, OPEN_THREADS_PANEL_LIMIT);
    const hiddenThreads = normalizedThreads.slice(OPEN_THREADS_PANEL_LIMIT);
    const normalizedOverflowSummary =
      typeof openThreadOverflowSummary === 'string' && openThreadOverflowSummary.trim().length > 0
        ? openThreadOverflowSummary.trim()
        : buildOpenThreadOverflowSummary(hiddenThreads);

    const listHtml = visibleThreads.map(function(thread) {
      var urgencyClass = getOpenThreadUrgencyClass(thread.urgency);
      return '<li class="open-threads-item">'
        + renderThreadBadgePill(thread.threadType, thread.urgency)
        + '<span class="open-threads-text ' + urgencyClass + '">' + escapeHtml(thread.text) + '</span>'
        + '</li>';
    }).join('');

    if (existingPanel) {
      const list = existingPanel.querySelector('#open-threads-list');
      if (list) {
        list.innerHTML = listHtml;
      }
      const existingSummary = existingPanel.querySelector('#open-threads-overflow-summary');
      if (normalizedOverflowSummary) {
        if (existingSummary) {
          existingSummary.textContent = normalizedOverflowSummary;
        } else {
          const summary = document.createElement('div');
          summary.className = 'open-threads-overflow-summary';
          summary.id = 'open-threads-overflow-summary';
          summary.textContent = normalizedOverflowSummary;
          existingPanel.appendChild(summary);
        }
      } else if (existingSummary) {
        existingSummary.remove();
      }
      return;
    }

    const summaryHtml = normalizedOverflowSummary
      ? '<div class="open-threads-overflow-summary" id="open-threads-overflow-summary">'
          + escapeHtml(normalizedOverflowSummary)
          + '</div>'
      : '';
    const panel = document.createElement('aside');
    panel.className = 'open-threads-panel';
    panel.id = 'open-threads-panel';
    panel.setAttribute('aria-labelledby', 'open-threads-title');
    panel.innerHTML = '<h3 class="open-threads-title" id="open-threads-title">Active Threads</h3>'
      + '<ul class="open-threads-list" id="open-threads-list">'
      + listHtml
      + '</ul>'
      + summaryHtml;

    sidebarContainer.appendChild(panel);
  }

  function renderKeyedEntryPanel(config) {
    var existingPanel = document.getElementById(config.panelId);

    if (!Array.isArray(config.entries) || config.entries.length === 0) {
      if (existingPanel) {
        existingPanel.remove();
      }
      return;
    }

    var normalized = config.entries
      .filter(function(entry) {
        return entry && typeof entry === 'object'
          && typeof entry.id === 'string' && entry.id.length > 0
          && typeof entry.text === 'string' && entry.text.length > 0;
      });

    if (normalized.length === 0) {
      if (existingPanel) {
        existingPanel.remove();
      }
      return;
    }

    var limit = typeof config.limit === 'number' ? config.limit : KEYED_ENTRY_PANEL_LIMIT;
    var visible = normalized.slice(0, limit);
    var hiddenCount = normalized.length - limit;
    var overflowText = typeof config.overflowSummary === 'string' && config.overflowSummary.trim().length > 0
      ? config.overflowSummary.trim()
      : (hiddenCount > 0 ? '+' + hiddenCount + ' more not shown' : null);

    var listHtml = visible
      .map(function(entry) {
        if (typeof config.renderEntry === 'function') {
          return '<li class="' + config.itemClass + '">' + config.renderEntry(entry) + '</li>';
        }
        return '<li class="' + config.itemClass + '">' + escapeHtml(entry.text) + '</li>';
      })
      .join('');

    if (existingPanel) {
      var list = existingPanel.querySelector('#' + config.listId);
      if (list) {
        list.innerHTML = listHtml;
      }
      var existingSummary = existingPanel.querySelector('#' + config.overflowId);
      if (overflowText) {
        if (existingSummary) {
          existingSummary.textContent = overflowText;
        } else {
          var summary = document.createElement('div');
          summary.className = 'keyed-entry-overflow-summary';
          summary.id = config.overflowId;
          summary.textContent = overflowText;
          existingPanel.appendChild(summary);
        }
      } else if (existingSummary) {
        existingSummary.remove();
      }
      return;
    }

    var summaryHtml = overflowText
      ? '<div class="keyed-entry-overflow-summary" id="' + config.overflowId + '">'
          + escapeHtml(overflowText)
          + '</div>'
      : '';
    var panel = document.createElement('aside');
    panel.className = config.panelClass;
    panel.id = config.panelId;
    panel.setAttribute('aria-labelledby', config.titleId);
    panel.innerHTML = '<h3 class="' + config.titleClass + '" id="' + config.titleId + '">'
      + escapeHtml(config.title) + '</h3>'
      + '<ul class="' + config.listClass + '" id="' + config.listId + '">'
      + listHtml
      + '</ul>'
      + summaryHtml;

    config.container.appendChild(panel);
  }

  function renderActiveThreatsPanel(threats, threatsOverflowSummary, sidebarContainer) {
    renderKeyedEntryPanel({
      panelId: 'active-threats-panel',
      titleId: 'active-threats-title',
      listId: 'active-threats-list',
      overflowId: 'active-threats-overflow',
      panelClass: 'active-threats-panel',
      titleClass: 'active-threats-title',
      listClass: 'active-threats-list',
      itemClass: 'active-threats-item',
      title: 'Active Threats',
      entries: threats,
      overflowSummary: threatsOverflowSummary,
      container: sidebarContainer,
      renderEntry: function(entry) {
        var threatType = typeof entry.threatType === 'string' ? entry.threatType : '';
        if (!threatType) {
          return escapeHtml(entry.text);
        }
        return renderThreatBadgePill(threatType) + '<span>' + escapeHtml(entry.text) + '</span>';
      },
    });
  }

  function renderActiveConstraintsPanel(constraints, constraintsOverflowSummary, sidebarContainer) {
    renderKeyedEntryPanel({
      panelId: 'active-constraints-panel',
      titleId: 'active-constraints-title',
      listId: 'active-constraints-list',
      overflowId: 'active-constraints-overflow',
      panelClass: 'active-constraints-panel',
      titleClass: 'active-constraints-title',
      listClass: 'active-constraints-list',
      itemClass: 'active-constraints-item',
      title: 'Active Constraints',
      entries: constraints,
      overflowSummary: constraintsOverflowSummary,
      container: sidebarContainer,
      renderEntry: function(entry) {
        var constraintType = typeof entry.constraintType === 'string' ? entry.constraintType : '';
        if (!constraintType) {
          return escapeHtml(entry.text);
        }
        return (
          renderConstraintBadgePill(constraintType) + '<span>' + escapeHtml(entry.text) + '</span>'
        );
      },
    });
  }

  function formatPromiseType(value) {
    if (typeof value !== 'string' || value.length === 0) {
      return 'Unknown';
    }
    return value.toLowerCase().split('_').map(function(part) {
      return part.charAt(0).toUpperCase() + part.slice(1);
    }).join(' ');
  }

  function renderTrackedPromisesPanel(promises, trackedPromisesOverflowSummary, sidebarContainer) {
    renderKeyedEntryPanel({
      panelId: 'tracked-promises-panel',
      titleId: 'tracked-promises-title',
      listId: 'tracked-promises-list',
      overflowId: 'tracked-promises-overflow',
      panelClass: 'tracked-promises-panel',
      titleClass: 'tracked-promises-title',
      listClass: 'tracked-promises-list',
      itemClass: 'tracked-promises-item',
      title: 'Tracked Promises',
      entries: Array.isArray(promises) ? promises.map(function(p) {
        return {
          id: typeof p.id === 'string' ? p.id : '',
          text: typeof p.text === 'string' ? p.text : '',
          promiseType: typeof p.promiseType === 'string' ? p.promiseType : '',
          age: typeof p.age === 'number' ? p.age : 0,
        };
      }) : [],
      overflowSummary: trackedPromisesOverflowSummary,
      container: sidebarContainer,
      renderEntry: function(entry) {
        var typeLabel = formatPromiseType(entry.promiseType);
        return '<span class="promise-type-text-badge">' + escapeHtml(typeLabel) + '</span>'
          + '<span class="promise-age-badge">' + entry.age + ' pg</span>'
          + '<span>' + escapeHtml(entry.text) + '</span>';
      },
    });
  }

  function ensureLeftSidebarContainer() {
    return document.getElementById('left-sidebar-widgets');
  }

  function cleanupEmptyLeftSidebar() {
    // Container is a grid cell; never remove it
  }

  function renderInventoryPanel(inventory, inventoryOverflowSummary, leftSidebarContainer) {
    renderKeyedEntryPanel({
      panelId: 'inventory-panel',
      titleId: 'inventory-title',
      listId: 'inventory-list',
      overflowId: 'inventory-overflow',
      panelClass: 'inventory-panel',
      titleClass: 'inventory-title',
      listClass: 'inventory-list',
      itemClass: 'inventory-item',
      title: 'Inventory',
      entries: inventory,
      overflowSummary: inventoryOverflowSummary,
      container: leftSidebarContainer,
      limit: LEFT_PANEL_LIMIT,
    });
  }

  function renderHealthPanel(health, healthOverflowSummary, leftSidebarContainer) {
    renderKeyedEntryPanel({
      panelId: 'health-panel',
      titleId: 'health-title',
      listId: 'health-list',
      overflowId: 'health-overflow',
      panelClass: 'health-panel',
      titleClass: 'health-title',
      listClass: 'health-list',
      itemClass: 'health-item',
      title: 'Health',
      entries: health,
      overflowSummary: healthOverflowSummary,
      container: leftSidebarContainer,
      limit: LEFT_PANEL_LIMIT,
    });
  }

  // ── Spine Renderer ──────────────────────────────────────────────────

  var SPINE_TYPE_LABELS = {
    QUEST: 'Quest',
    SURVIVAL: 'Survival',
    ESCAPE: 'Escape',
    REVENGE: 'Revenge',
    RESCUE: 'Rescue',
    RIVALRY: 'Rivalry',
    MYSTERY: 'Mystery',
    TEMPTATION: 'Temptation',
    TRANSFORMATION: 'Transformation',
    FORBIDDEN_LOVE: 'Forbidden Love',
    SACRIFICE: 'Sacrifice',
    FALL_FROM_GRACE: 'Fall from Grace',
    RISE_TO_POWER: 'Rise to Power',
    COMING_OF_AGE: 'Coming of Age',
    REBELLION: 'Rebellion',
  };

  var CONFLICT_TYPE_LABELS = {
    PERSON_VS_PERSON: 'Person vs Person',
    PERSON_VS_SELF: 'Person vs Self',
    PERSON_VS_SOCIETY: 'Person vs Society',
    PERSON_VS_NATURE: 'Person vs Nature',
    PERSON_VS_TECHNOLOGY: 'Person vs Technology',
    PERSON_VS_SUPERNATURAL: 'Person vs Supernatural',
    PERSON_VS_FATE: 'Person vs Fate',
  };

  var ARC_TYPE_LABELS = {
    POSITIVE_CHANGE: 'Positive Change',
    FLAT: 'Flat Arc',
    DISILLUSIONMENT: 'Disillusionment',
    FALL: 'Fall',
    CORRUPTION: 'Corruption',
  };

  var DYNAMIC_LABELS = {
    CONVERGENT: 'Convergent',
    DIVERGENT: 'Divergent',
    SUBSTITUTIVE: 'Substitutive',
    IRRECONCILABLE: 'Irreconcilable',
  };

  var selectedSpine = null;

  function getSelectedSpine() {
    return selectedSpine;
  }

  function clearSelectedSpine() {
    selectedSpine = null;
  }

  function renderSpineOptions(options, container, onSelect) {
    container.innerHTML = '';
    selectedSpine = null;

    options.forEach(function (option, index) {
      var card = document.createElement('div');
      card.className = 'spine-card';
      card.dataset.index = String(index);

      var badges = document.createElement('div');
      badges.className = 'spine-badges';
      badges.innerHTML =
        '<span class="spine-badge spine-badge-type">' +
        escapeHtml(SPINE_TYPE_LABELS[option.storySpineType] || option.storySpineType) +
        '</span>' +
        '<span class="spine-badge spine-badge-conflict">' +
        escapeHtml(CONFLICT_TYPE_LABELS[option.conflictType] || option.conflictType) +
        '</span>' +
        '<span class="spine-badge spine-badge-arc">' +
        escapeHtml(ARC_TYPE_LABELS[option.characterArcType] || option.characterArcType) +
        '</span>';

      var cdq = document.createElement('h3');
      cdq.className = 'spine-cdq';
      cdq.textContent = option.centralDramaticQuestion;

      var needWant = document.createElement('div');
      needWant.className = 'spine-need-want';
      needWant.innerHTML =
        '<div class="spine-field">' +
        '<span class="spine-label">Need:</span> ' +
        escapeHtml(option.protagonistNeedVsWant.need) +
        '</div>' +
        '<div class="spine-field">' +
        '<span class="spine-label">Want:</span> ' +
        escapeHtml(option.protagonistNeedVsWant.want) +
        '</div>' +
        '<div class="spine-field">' +
        '<span class="spine-label">Dynamic:</span> ' +
        '<span class="spine-badge spine-badge-dynamic">' +
        escapeHtml(DYNAMIC_LABELS[option.protagonistNeedVsWant.dynamic] || option.protagonistNeedVsWant.dynamic) +
        '</span>' +
        '</div>';

      var antag = document.createElement('div');
      antag.className = 'spine-antagonist';
      antag.innerHTML =
        '<div class="spine-field">' +
        '<span class="spine-label">Opposition:</span> ' +
        escapeHtml(option.primaryAntagonisticForce.description) +
        '</div>' +
        '<div class="spine-field">' +
        '<span class="spine-label">Pressure:</span> ' +
        escapeHtml(option.primaryAntagonisticForce.pressureMechanism) +
        '</div>';

      var tone = document.createElement('div');
      tone.className = 'spine-tone';
      var toneHtml = '';
      if (option.toneKeywords && option.toneKeywords.length > 0) {
        toneHtml +=
          '<div class="spine-field">' +
          '<span class="spine-label">Tone:</span> ' +
          '<span class="spine-tone-pills">';
        option.toneKeywords.forEach(function (kw) {
          toneHtml +=
            '<span class="spine-tone-pill spine-tone-pill-positive">' +
            escapeHtml(kw) +
            '</span>';
        });
        toneHtml += '</span></div>';
      }
      if (option.toneAntiKeywords && option.toneAntiKeywords.length > 0) {
        toneHtml +=
          '<div class="spine-field">' +
          '<span class="spine-label">Avoids:</span> ' +
          '<span class="spine-tone-pills">';
        option.toneAntiKeywords.forEach(function (kw) {
          toneHtml +=
            '<span class="spine-tone-pill spine-tone-pill-negative">' +
            escapeHtml(kw) +
            '</span>';
        });
        toneHtml += '</span></div>';
      }
      tone.innerHTML = toneHtml;

      card.appendChild(badges);
      card.appendChild(cdq);
      card.appendChild(needWant);
      card.appendChild(antag);
      card.appendChild(tone);

      card.addEventListener('click', function () {
        var allCards = container.querySelectorAll('.spine-card');
        allCards.forEach(function (c) {
          c.classList.remove('spine-card-selected');
        });
        card.classList.add('spine-card-selected');
        selectedSpine = option;
        if (typeof onSelect === 'function') {
          onSelect(option);
        }
      });

      container.appendChild(card);
    });
  }

  function clearSpineOptions(container) {
    container.innerHTML = '';
    selectedSpine = null;
  }

  function escapeHtml(text) {
    var div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
  }

  // ── Choice renderers ──────────────────────────────────────────────

  function renderChoiceButtons(choiceList) {
    return choiceList.map(function(choice, index) {
      var isExplored = Boolean(choice.nextPageId);
      var choiceText = typeof choice.text === 'string' ? choice.text : '';
      var choiceType = typeof choice.choiceType === 'string' ? choice.choiceType : '';
      var primaryDelta = typeof choice.primaryDelta === 'string' ? choice.primaryDelta : '';

      var typeIconPath = getIconPath(choiceType);
      var deltaIconPath = getIconPath(primaryDelta);
      var typeLabel = CHOICE_TYPE_LABEL_MAP[choiceType] || '';
      var deltaLabel = PRIMARY_DELTA_LABEL_MAP[primaryDelta] || '';

      var pillHtml = '';
      if (typeIconPath || deltaIconPath) {
        pillHtml = '<span class="choice-icon-pill" aria-hidden="true">';
        if (typeIconPath) {
          pillHtml += '<img class="choice-icon choice-icon--type"'
            + ' src="' + escapeHtml(typeIconPath) + '"'
            + ' alt="" title="' + escapeHtml(typeLabel) + '"'
            + ' width="32" height="32" loading="lazy"'
            + " onerror=\"this.style.display='none'\">";
        }
        if (deltaIconPath) {
          pillHtml += '<img class="choice-icon choice-icon--delta"'
            + ' src="' + escapeHtml(deltaIconPath) + '"'
            + ' alt="" title="' + escapeHtml(deltaLabel) + '"'
            + ' width="32" height="32" loading="lazy"'
            + " onerror=\"this.style.display='none'\">";
        }
        pillHtml += '</span>';
      }

      return '<div class="choice-row">'
        + pillHtml
        + '<button'
        + ' class="choice-btn"'
        + ' data-choice-index="' + index + '"'
        + ' data-choice-type="' + escapeHtml(choiceType) + '"'
        + ' data-primary-delta="' + escapeHtml(primaryDelta) + '"'
        + (isExplored ? ' data-explored="true"' : '')
        + '>'
        + '<span class="choice-text">' + escapeHtml(choiceText) + '</span>'
        + '</button>'
        + (isExplored ? '<span class="explored-marker" title="Previously explored">&#8617;</span>' : '')
        + '</div>';
    }).join('');
  }

  function renderSelectOptions(items) {
    return items.map(function(item) {
      return '<option value="' + escapeHtml(item.value) + '">' + escapeHtml(item.label) + '</option>';
    }).join('');
  }

  function renderProtagonistGuidanceAndCustomChoice(guidanceValues) {
    const safeEmotions = typeof guidanceValues.emotions === 'string'
      ? guidanceValues.emotions
      : '';
    const safeThoughts = typeof guidanceValues.thoughts === 'string'
      ? guidanceValues.thoughts
      : '';
    const safeSpeech = typeof guidanceValues.speech === 'string'
      ? guidanceValues.speech
      : '';

    return `
        <details class="protagonist-guidance">
          <summary class="protagonist-guidance__summary">Guide Your Protagonist</summary>
          <div class="protagonist-guidance__fields">
            <div class="protagonist-guidance__field">
              <label class="protagonist-guidance__label" for="guidance-emotions">Emotions</label>
              <textarea
                id="guidance-emotions"
                class="protagonist-guidance__textarea"
                name="suggestedEmotions"
                placeholder="e.g. Furious but hiding it behind a thin smile..."
                maxlength="500"
                rows="2"
              >${escapeHtml(safeEmotions)}</textarea>
            </div>
            <div class="protagonist-guidance__field">
              <label class="protagonist-guidance__label" for="guidance-thoughts">Thoughts</label>
              <textarea
                id="guidance-thoughts"
                class="protagonist-guidance__textarea"
                name="suggestedThoughts"
                placeholder="e.g. Wondering if the stranger recognized them..."
                maxlength="500"
                rows="2"
              >${escapeHtml(safeThoughts)}</textarea>
            </div>
            <div class="protagonist-guidance__field">
              <label class="protagonist-guidance__label" for="guidance-speech">Speech</label>
              <textarea
                id="guidance-speech"
                class="protagonist-guidance__textarea"
                name="suggestedSpeech"
                placeholder="e.g. 'Wake up, Alicia! We don't have much time.'"
                maxlength="500"
                rows="2"
              >${escapeHtml(safeSpeech)}</textarea>
            </div>
          </div>
        </details>
        <div class="custom-choice-container">
          <input type="text" class="custom-choice-input"
                 placeholder="Introduce your own custom choice..."
                 maxlength="500" />
          <button type="button" class="custom-choice-btn">Add</button>
        </div>
        <div class="custom-choice-enums">
          <select class="custom-choice-type">
            ${renderSelectOptions(CHOICE_TYPES)}
          </select>
          <select class="custom-choice-delta">
            ${renderSelectOptions(PRIMARY_DELTAS)}
          </select>
        </div>
        <div class="alert alert-error play-error" id="play-error" style="display: none;" role="alert" aria-live="polite"></div>
      `;
  }

  function rebuildChoicesSection(choiceList, guidanceValues, choicesEl, choicesSectionEl, bindFn) {
    choicesEl.innerHTML = renderChoiceButtons(choiceList);
    const existingGuidance = choicesSectionEl.querySelector('.protagonist-guidance');
    if (existingGuidance) {
      existingGuidance.remove();
    }
    const existingCustom = choicesSectionEl.querySelector('.custom-choice-container');
    if (existingCustom) {
      existingCustom.remove();
    }
    const existingEnums = choicesSectionEl.querySelector('.custom-choice-enums');
    if (existingEnums) {
      existingEnums.remove();
    }
    choicesEl.insertAdjacentHTML('afterend', renderProtagonistGuidanceAndCustomChoice(guidanceValues));
    bindFn();
  }

  // ── Affect renderer ──────────────────────────────────────────────

  var INTENSITY_DOT_COUNT = { mild: 1, moderate: 2, strong: 3, overwhelming: 4 };

  function renderAffectPanel(protagonistAffect, leftSidebarContainer) {
    var existingPanel = document.getElementById('affect-panel');

    if (!protagonistAffect || typeof protagonistAffect !== 'object') {
      if (existingPanel) {
        existingPanel.remove();
      }
      return;
    }

    var primaryEmotion = typeof protagonistAffect.primaryEmotion === 'string'
      ? protagonistAffect.primaryEmotion : '';
    var primaryIntensity = typeof protagonistAffect.primaryIntensity === 'string'
      ? protagonistAffect.primaryIntensity : 'mild';
    var primaryCause = typeof protagonistAffect.primaryCause === 'string'
      ? protagonistAffect.primaryCause : '';
    var secondaryEmotions = Array.isArray(protagonistAffect.secondaryEmotions)
      ? protagonistAffect.secondaryEmotions : [];
    var dominantMotivation = typeof protagonistAffect.dominantMotivation === 'string'
      ? protagonistAffect.dominantMotivation : '';

    if (!primaryEmotion) {
      if (existingPanel) {
        existingPanel.remove();
      }
      return;
    }

    var filledCount = INTENSITY_DOT_COUNT[primaryIntensity] || 1;
    var dotsHtml = '';
    for (var d = 0; d < 4; d++) {
      dotsHtml += '<span class="affect-dot' + (d < filledCount ? ' affect-dot--filled' : '') + '"></span>';
    }

    var primaryHtml = '<div class="affect-primary">'
      + '<span class="affect-emotion">' + escapeHtml(primaryEmotion) + '</span>'
      + '<div class="affect-dots" aria-label="Intensity: ' + escapeHtml(primaryIntensity) + '">'
      + dotsHtml
      + '<span class="affect-intensity-label">' + escapeHtml(primaryIntensity) + '</span>'
      + '</div>'
      + '<span class="affect-cause">' + escapeHtml(primaryCause) + '</span>'
      + '</div>';

    var secondariesHtml = '';
    if (secondaryEmotions.length > 0) {
      var pills = secondaryEmotions
        .filter(function(se) { return se && typeof se.emotion === 'string'; })
        .map(function(se) {
          var cause = typeof se.cause === 'string' ? se.cause : '';
          return '<span class="affect-pill" title="' + escapeHtml(cause) + '">'
            + escapeHtml(se.emotion) + '</span>';
        })
        .join('');
      if (pills) {
        secondariesHtml = '<div class="affect-secondaries">' + pills + '</div>';
      }
    }

    var motivationHtml = dominantMotivation
      ? '<div class="affect-motivation">' + escapeHtml(dominantMotivation) + '</div>'
      : '';

    var innerHtml = '<h3 class="affect-title" id="affect-title">Protagonist</h3>'
      + primaryHtml + secondariesHtml + motivationHtml;

    if (existingPanel) {
      existingPanel.setAttribute('data-intensity', primaryIntensity);
      existingPanel.innerHTML = innerHtml;
      return;
    }

    var panel = document.createElement('aside');
    panel.className = 'affect-panel';
    panel.id = 'affect-panel';
    panel.setAttribute('aria-labelledby', 'affect-title');
    panel.setAttribute('data-intensity', primaryIntensity);
    panel.innerHTML = innerHtml;

    // Insert at the top of left sidebar, before inventory/health
    leftSidebarContainer.insertBefore(panel, leftSidebarContainer.firstChild);
  }

// ── Analyst insights modal ───────────────────────────────────────

var OBJECTIVE_EVIDENCE_FILL = { NONE: 0, WEAK_IMPLICIT: 33, CLEAR_EXPLICIT: 100 };
var COMMITMENT_FILL = {
  NONE: 0,
  TENTATIVE: 25,
  EXPLICIT_REVERSIBLE: 60,
  EXPLICIT_IRREVERSIBLE: 100,
};
var ENTRY_READINESS_FILL = { NOT_READY: 0, PARTIAL: 50, READY: 100 };
var STRUCTURAL_POSITION_FILL = {
  WITHIN_ACTIVE_BEAT: 20,
  BRIDGING_TO_NEXT_BEAT: 60,
  CLEARLY_IN_NEXT_BEAT: 100,
};
var MOMENTUM_META = {
  STASIS: { css: 'momentum-badge--stasis', label: 'Stasis' },
  INCREMENTAL_PROGRESS: { css: 'momentum-badge--incremental', label: 'Incremental Progress' },
  MAJOR_PROGRESS: { css: 'momentum-badge--major', label: 'Major Progress' },
  REVERSAL_OR_SETBACK: { css: 'momentum-badge--reversal', label: 'Reversal' },
  SCOPE_SHIFT: { css: 'momentum-badge--scope-shift', label: 'Scope Shift' },
};
var COMPLETION_GATE_FILL = { PENDING: 0, SATISFIED: 100 };
var URGENCY_CLASS = { LOW: 'urgency-low', MEDIUM: 'urgency-medium', HIGH: 'urgency-high' };
var PAYOFF_CLASS = {
  RUSHED: 'payoff-rushed',
  ADEQUATE: 'payoff-adequate',
  WELL_EARNED: 'payoff-well-earned',
};

function parseAnalystDataFromDom() {
  var node = document.getElementById('analyst-data');
  if (!node || typeof node.textContent !== 'string') {
    return null;
  }

  try {
    var parsed = JSON.parse(node.textContent);
    return parsed && typeof parsed === 'object' ? parsed : null;
  } catch (_) {
    return null;
  }
}

function parseInsightsContextFromDom() {
  var node = document.getElementById('insights-context');
  if (!node || typeof node.textContent !== 'string') {
    return { actDisplayInfo: null, sceneSummary: null };
  }

  try {
    var parsed = JSON.parse(node.textContent);
    return parsed && typeof parsed === 'object'
      ? parsed
      : { actDisplayInfo: null, sceneSummary: null };
  } catch (_) {
    return { actDisplayInfo: null, sceneSummary: null };
  }
}

function formatAnalystEnum(value) {
  if (typeof value !== 'string' || value.length === 0) {
    return 'Unknown';
  }
  return value.toLowerCase().split('_').map(function(part) {
    return part.charAt(0).toUpperCase() + part.slice(1);
  }).join(' ');
}

function gaugeClass(fillPct) {
  if (fillPct <= 33) {
    return 'beat-gauge__fill--low';
  }
  if (fillPct <= 66) {
    return 'beat-gauge__fill--mid';
  }
  return 'beat-gauge__fill--high';
}

function renderGaugeRow(label, value, fillMap) {
  var fillPct = fillMap[value] || 0;
  return '<div class="beat-gauge__row">'
    + '<span class="beat-gauge__label">' + escapeHtml(label) + '</span>'
    + '<div class="beat-gauge__track">'
    + '<span class="beat-gauge__fill ' + gaugeClass(fillPct) + '" style="width:' + fillPct + '%"></span>'
    + '</div>'
    + '<span class="beat-gauge__level">' + escapeHtml(formatAnalystEnum(value)) + '</span>'
    + '</div>';
}

function renderPromisePayoffs(assessments, resolvedPromiseMeta) {
  if (!Array.isArray(assessments) || assessments.length === 0) {
    return '';
  }

  var metaMap = resolvedPromiseMeta && typeof resolvedPromiseMeta === 'object'
    ? resolvedPromiseMeta
    : {};

  var items = assessments.map(function(assessment) {
    var satisfaction = typeof assessment?.satisfactionLevel === 'string'
      ? assessment.satisfactionLevel
      : 'ADEQUATE';
    var payoffClass = PAYOFF_CLASS[satisfaction] || PAYOFF_CLASS.ADEQUATE;
    var description = typeof assessment?.description === 'string' ? assessment.description : '';
    var reasoning = typeof assessment?.reasoning === 'string' ? assessment.reasoning : '';
    var promiseId = typeof assessment?.promiseId === 'string' ? assessment.promiseId : '';

    var badgeHtml = '';
    var meta = promiseId ? metaMap[promiseId] : null;
    if (meta && typeof meta.promiseType === 'string') {
      badgeHtml = '<span class="promise-payoff-badge">'
        + '<span class="promise-type-text-badge">' + escapeHtml(formatAnalystEnum(meta.promiseType)) + '</span>'
        + '</span>';
    }

    return '<li class="promise-payoff-item">'
      + badgeHtml
      + '<p class="payoff-thread-label">Promise</p>'
      + '<p class="payoff-thread-text" title="' + escapeHtml(description) + '">' + escapeHtml(description) + '</p>'
      + '<span class="payoff-satisfaction-badge payoff-satisfaction-badge--centered ' + payoffClass + '">'
      + escapeHtml(satisfaction)
      + '</span>'
      + '<p class="insights-copy payoff-reasoning">' + escapeHtml(reasoning) + '</p>'
      + '</li>';
  }).join('');

  return '<details class="insights-section" open>'
    + '<summary><h4>Promise Payoffs</h4></summary>'
    + '<ul class="payoff-list">' + items + '</ul>'
    + '</details>';
}

function renderThreadPayoffs(assessments, resolvedThreadMeta) {
  if (!Array.isArray(assessments) || assessments.length === 0) {
    return '';
  }

  var metaMap = resolvedThreadMeta && typeof resolvedThreadMeta === 'object'
    ? resolvedThreadMeta
    : {};

  var items = assessments.map(function(assessment) {
    var satisfaction = typeof assessment?.satisfactionLevel === 'string'
      ? assessment.satisfactionLevel
      : 'ADEQUATE';
    var payoffClass = PAYOFF_CLASS[satisfaction] || PAYOFF_CLASS.ADEQUATE;
    var threadText = typeof assessment?.threadText === 'string' ? assessment.threadText : '';
    var reasoning = typeof assessment?.reasoning === 'string' ? assessment.reasoning : '';
    var threadId = typeof assessment?.threadId === 'string' ? assessment.threadId : '';

    var badgeHtml = '';
    var meta = threadId ? metaMap[threadId] : null;
    if (meta && typeof meta.threadType === 'string' && typeof meta.urgency === 'string') {
      badgeHtml = '<span class="payoff-thread-badge">'
        + renderThreadBadgePill(meta.threadType, meta.urgency)
        + '</span>';
    }

    return '<li class="payoff-item">'
      + badgeHtml
      + '<p class="payoff-thread-label">Thread</p>'
      + '<p class="payoff-thread-text" title="' + escapeHtml(threadText) + '">' + escapeHtml(threadText) + '</p>'
      + '<span class="payoff-satisfaction-badge payoff-satisfaction-badge--centered ' + payoffClass + '">'
      + escapeHtml(satisfaction)
      + '</span>'
      + '<p class="insights-copy payoff-reasoning">' + escapeHtml(reasoning) + '</p>'
      + '</li>';
  }).join('');

  return '<details class="insights-section" open>'
    + '<summary><h4>Thread Payoffs</h4></summary>'
    + '<ul class="payoff-list">' + items + '</ul>'
    + '</details>';
}

function renderInsightsBody(analystResult, context) {
  if (!analystResult || typeof analystResult !== 'object') {
    return '<p class="insights-copy">No analyst insights are available for this page yet.</p>';
  }

  var ctx = context && typeof context === 'object' ? context : {};
  var headerHtml = '';

  if (typeof ctx.actDisplayInfo === 'string' && ctx.actDisplayInfo.length > 0) {
    headerHtml += '<p class="insights-beat-subtitle">' + escapeHtml(ctx.actDisplayInfo) + '</p>';
  }

  if (typeof ctx.sceneSummary === 'string' && ctx.sceneSummary.length > 0) {
    headerHtml += '<p class="insights-scene-summary">' + escapeHtml(ctx.sceneSummary) + '</p>';
  }

  var momentum = MOMENTUM_META[analystResult.sceneMomentum] || MOMENTUM_META.STASIS;
  var completionGateSatisfied = analystResult.completionGateSatisfied === true;
  var completionGateReason = typeof analystResult.completionGateFailureReason === 'string'
    ? analystResult.completionGateFailureReason
    : '';
  var completionGateValue = completionGateSatisfied ? 'SATISFIED' : 'PENDING';

  var pacingHtml = '';
  if (analystResult.pacingIssueDetected === true) {
    pacingHtml = '<details class="pacing-alert" open role="status">'
      + '<summary><h4>Pacing Alert</h4></summary>'
      + '<p class="insights-copy">' + escapeHtml(analystResult.pacingIssueReason || '') + '</p>'
      + '<span class="insights-chip">Recommended: '
      + escapeHtml(formatAnalystEnum(analystResult.recommendedAction))
      + '</span>'
      + '</details>';
  }

  var toneHtml = '';
  if (analystResult.toneAdherent === false) {
    toneHtml = '<details class="tone-warning" open role="status">'
      + '<summary><h4>Tone Warning</h4></summary>'
      + '<p class="insights-copy">' + escapeHtml(analystResult.toneDriftDescription || '') + '</p>'
      + '</details>';
  }

  return headerHtml
    + '<details class="insights-section" open>'
    + '<summary><h4>Beat Progress</h4></summary>'
    + '<div class="beat-gauge">'
    + renderGaugeRow('Objective Evidence', analystResult.objectiveEvidenceStrength, OBJECTIVE_EVIDENCE_FILL)
    + renderGaugeRow('Commitment', analystResult.commitmentStrength, COMMITMENT_FILL)
    + renderGaugeRow('Entry Readiness', analystResult.entryConditionReadiness, ENTRY_READINESS_FILL)
    + renderGaugeRow('Structural Position', analystResult.structuralPositionSignal, STRUCTURAL_POSITION_FILL)
    + renderGaugeRow('Completion Gate', completionGateValue, COMPLETION_GATE_FILL)
    + '</div>'
    + (completionGateReason
      ? '<p class="completion-gate-reason">' + escapeHtml(completionGateReason) + '</p>'
      : '')
    + '</details>'
    + '<details class="insights-section" open>'
    + '<summary><h4>Momentum</h4></summary>'
    + '<span class="momentum-badge ' + momentum.css + '">' + escapeHtml(momentum.label) + '</span>'
    + '</details>'
    + pacingHtml
    + renderPromisePayoffs(analystResult.promisePayoffAssessments, ctx.resolvedPromiseMeta || {})
    + renderThreadPayoffs(analystResult.threadPayoffAssessments, ctx.resolvedThreadMeta || {})
    + toneHtml;
}

function createInsightsButton() {
  var button = document.createElement('button');
  button.type = 'button';
  button.className = 'insights-btn';
  button.id = 'insights-btn';
  button.setAttribute('aria-haspopup', 'dialog');
  button.setAttribute('aria-controls', 'insights-modal');
  button.innerHTML = '<span class="insights-btn__icon" aria-hidden="true">🔍</span>'
    + '<span class="insights-btn__label">Story Insights</span>';
  return button;
}

function createAnalystInsightsController(initialAnalystResult, initialContext) {
  var analystResult = initialAnalystResult && typeof initialAnalystResult === 'object'
    ? initialAnalystResult
    : null;
  var insightsContext = initialContext && typeof initialContext === 'object'
    ? initialContext
    : { actDisplayInfo: null, sceneSummary: null };
  var modal = document.getElementById('insights-modal');
  var modalBody = document.getElementById('insights-modal-body');
  var closeButton = document.getElementById('insights-close-btn');
  var headerActions = document.getElementById('story-header-actions');
  var button = document.getElementById('insights-btn');

  if (!modal || !modalBody || !closeButton || !headerActions) {
    return {
      update: function() {},
    };
  }

  if (!button) {
    button = createInsightsButton();
    headerActions.insertBefore(button, headerActions.firstChild);
  }

  function closeModal() {
    modal.style.display = 'none';
  }

  function openModal() {
    if (!analystResult) {
      return;
    }
    modal.style.display = 'flex';
  }

  function render() {
    modalBody.innerHTML = renderInsightsBody(analystResult, insightsContext);
    button.style.display = analystResult ? 'inline-flex' : 'none';
    if (!analystResult) {
      closeModal();
    }
  }

  button.addEventListener('click', openModal);
  closeButton.addEventListener('click', closeModal);
  modal.addEventListener('click', function(event) {
    if (event.target === modal) {
      closeModal();
    }
  });
  document.addEventListener('keydown', function(event) {
    if (event.key === 'Escape') {
      closeModal();
    }
  });

  render();

  return {
    update: function(nextAnalystResult, nextContext) {
      analystResult =
        nextAnalystResult && typeof nextAnalystResult === 'object' ? nextAnalystResult : null;
      if (nextContext && typeof nextContext === 'object') {
        insightsContext = nextContext;
      }
      render();
    },
  };
}

// ── Story lore modal ─────────────────────────────────────────────

function parseLoreDataFromDom() {
  var node = document.getElementById('lore-data');
  if (!node || typeof node.textContent !== 'string') {
    return { worldFacts: [], characterCanon: {} };
  }

  try {
    var parsed = JSON.parse(node.textContent);
    if (!parsed || typeof parsed !== 'object') {
      return { worldFacts: [], characterCanon: {} };
    }

    var worldFacts = Array.isArray(parsed.worldFacts)
      ? parsed.worldFacts.filter(function(fact) {
          return typeof fact === 'string' && fact.length > 0;
        })
      : [];
    var characterCanon = parsed.characterCanon && typeof parsed.characterCanon === 'object'
      ? parsed.characterCanon
      : {};

    return { worldFacts: worldFacts, characterCanon: characterCanon };
  } catch (_) {
    return { worldFacts: [], characterCanon: {} };
  }
}

function normalizeCharacterCanon(characterCanon) {
  if (!characterCanon || typeof characterCanon !== 'object') {
    return {};
  }

  var normalized = {};
  Object.keys(characterCanon).forEach(function(characterName) {
    var facts = characterCanon[characterName];
    if (!Array.isArray(facts)) {
      return;
    }

    var validFacts = facts.filter(function(fact) {
      return typeof fact === 'string' && fact.length > 0;
    });
    if (validFacts.length > 0) {
      normalized[characterName] = validFacts;
    }
  });

  return normalized;
}

function renderLoreWorldPanel(worldFacts) {
  if (!Array.isArray(worldFacts) || worldFacts.length === 0) {
    return '<p class="lore-empty">No world facts established yet.</p>';
  }

  var list = worldFacts
    .map(function(fact) {
      return '<li>' + escapeHtml(fact) + '</li>';
    })
    .join('');
  return '<ul class="lore-world-list">' + list + '</ul>';
}

function renderLoreCharactersPanel(characterCanon) {
  var characterNames = Object.keys(characterCanon);
  if (characterNames.length === 0) {
    return '<p class="lore-empty">No character facts established yet.</p>';
  }

  return characterNames
    .map(function(characterName) {
      var facts = characterCanon[characterName];
      var factList = facts
        .map(function(fact) {
          return '<li>' + escapeHtml(fact) + '</li>';
        })
        .join('');

      return '<div class="lore-character-card">'
        + '<button type="button" class="lore-character-name" aria-expanded="false">'
        + escapeHtml(characterName)
        + '</button>'
        + '<ul class="lore-character-facts" style="display: none;">'
        + factList
        + '</ul>'
        + '</div>';
    })
    .join('');
}

function createLoreModalController(initialData) {
  var modal = document.getElementById('lore-modal');
  var triggerButton = document.getElementById('lore-trigger-btn');
  var closeButton = document.getElementById('lore-close-btn');
  var worldPanel = document.getElementById('lore-panel-world');
  var charactersPanel = document.getElementById('lore-panel-characters');
  var worldTab = document.getElementById('lore-tab-world');
  var charactersTab = document.getElementById('lore-tab-characters');
  var countBadge = document.getElementById('lore-count-badge');
  var leftSidebar = document.getElementById('left-sidebar-widgets');

  if (
    !modal
    || !triggerButton
    || !closeButton
    || !worldPanel
    || !charactersPanel
    || !worldTab
    || !charactersTab
    || !countBadge
    || !leftSidebar
  ) {
    return {
      update: function() {},
    };
  }

  function keepTriggerAtBottom() {
    leftSidebar.appendChild(triggerButton);
  }

  function closeModal() {
    modal.style.display = 'none';
  }

  function openModal() {
    modal.style.display = 'flex';
  }

  function activateTab(tabName) {
    var isWorld = tabName === 'world';

    worldTab.classList.toggle('lore-tab--active', isWorld);
    worldTab.setAttribute('aria-selected', isWorld ? 'true' : 'false');
    worldPanel.style.display = isWorld ? '' : 'none';

    charactersTab.classList.toggle('lore-tab--active', !isWorld);
    charactersTab.setAttribute('aria-selected', isWorld ? 'false' : 'true');
    charactersPanel.style.display = isWorld ? 'none' : '';
  }

  function bindCharacterToggles() {
    var names = charactersPanel.querySelectorAll('.lore-character-name');
    names.forEach(function(nameButton) {
      nameButton.addEventListener('click', function() {
        var card = nameButton.closest('.lore-character-card');
        if (!card) {
          return;
        }

        var factsList = card.querySelector('.lore-character-facts');
        if (!factsList) {
          return;
        }

        var expanded = card.classList.toggle('lore-character-card--expanded');
        nameButton.setAttribute('aria-expanded', expanded ? 'true' : 'false');
        factsList.style.display = expanded ? 'block' : 'none';
      });
    });
  }

  function renderLore(worldFactsInput, characterCanonInput) {
    var worldFacts = Array.isArray(worldFactsInput)
      ? worldFactsInput.filter(function(fact) {
          return typeof fact === 'string' && fact.length > 0;
        })
      : [];
    var characterCanon = normalizeCharacterCanon(characterCanonInput);

    worldPanel.innerHTML = renderLoreWorldPanel(worldFacts);
    charactersPanel.innerHTML = renderLoreCharactersPanel(characterCanon);
    bindCharacterToggles();

    var characterFactCount = Object.values(characterCanon).reduce(function(total, facts) {
      return total + facts.length;
    }, 0);
    countBadge.textContent = '(' + (worldFacts.length + characterFactCount) + ')';
    keepTriggerAtBottom();
  }

  triggerButton.addEventListener('click', openModal);
  closeButton.addEventListener('click', closeModal);
  worldTab.addEventListener('click', function() {
    activateTab('world');
  });
  charactersTab.addEventListener('click', function() {
    activateTab('characters');
  });
  modal.addEventListener('click', function(event) {
    if (event.target === modal) {
      closeModal();
    }
  });
  document.addEventListener('keydown', function(event) {
    if (event.key === 'Escape') {
      closeModal();
    }
  });

  activateTab('world');
  renderLore(initialData.worldFacts, initialData.characterCanon);

  return {
    update: function(worldFacts, characterCanon) {
      renderLore(worldFacts, characterCanon);
    },
  };
}

// ── Story recap modal ────────────────────────────────────────────

function parseRecapDataFromDom() {
  var node = document.getElementById('recap-data');
  if (!node || typeof node.textContent !== 'string') {
    return [];
  }

  try {
    var parsed = JSON.parse(node.textContent);
    if (!Array.isArray(parsed)) {
      return [];
    }

    return parsed.filter(function(entry) {
      return entry
        && typeof entry === 'object'
        && typeof entry.pageId === 'number'
        && Number.isInteger(entry.pageId)
        && entry.pageId >= 1
        && typeof entry.summary === 'string';
    });
  } catch (_) {
    return [];
  }
}

function createRecapModalController(initialData) {
  var modal = document.getElementById('recap-modal');
  var triggerButton = document.getElementById('recap-btn');
  var closeButton = document.getElementById('recap-close-btn');
  var modalBody = document.getElementById('recap-modal-body');
  var entries = Array.isArray(initialData) ? initialData : [];

  if (!modal || !triggerButton || !closeButton || !modalBody) {
    return {
      update: function() {},
    };
  }

  function closeModal() {
    modal.style.display = 'none';
  }

  function openModal() {
    modal.style.display = 'flex';
  }

  function renderRecapBody() {
    if (!Array.isArray(entries) || entries.length === 0) {
      modalBody.innerHTML = '<p class="recap-empty">No scenes recorded yet.</p>';
      return;
    }

    modalBody.innerHTML = entries.map(function(entry, index) {
      var sceneLabel = 'Scene ' + String(index + 1);
      return '<article class="recap-entry">'
        + '<span class="recap-page-label">' + escapeHtml(sceneLabel) + '</span>'
        + '<p class="recap-summary">' + escapeHtml(entry.summary) + '</p>'
        + '</article>';
    }).join('');
  }

  triggerButton.addEventListener('click', openModal);
  closeButton.addEventListener('click', closeModal);
  modal.addEventListener('click', function(event) {
    if (event.target === modal) {
      closeModal();
    }
  });
  document.addEventListener('keydown', function(event) {
    if (event.key === 'Escape') {
      closeModal();
    }
  });

  renderRecapBody();

  return {
    update: function(nextEntries) {
      entries = Array.isArray(nextEntries) ? nextEntries : [];
      renderRecapBody();
    },
  };
}

  // ── NPC Relationship renderer ────────────────────────────────────

  function renderNpcRelationshipCard(rel) {
    if (!rel || typeof rel !== 'object') {
      return '';
    }

    var npcName = typeof rel.npcName === 'string' ? rel.npcName : '';
    var dynamic = typeof rel.dynamic === 'string' ? rel.dynamic : '';
    var valence = typeof rel.valence === 'number' ? rel.valence : 0;
    var history = typeof rel.history === 'string' ? rel.history : '';
    var currentTension = typeof rel.currentTension === 'string' ? rel.currentTension : '';
    var leverage = typeof rel.leverage === 'string' ? rel.leverage : '';

    if (!npcName) {
      return '';
    }

    var valencePercent = ((valence + 5) / 10) * 100;
    if (valencePercent < 0) valencePercent = 0;
    if (valencePercent > 100) valencePercent = 100;

    var html = '<div class="npc-rel-card" data-npc="' + escapeHtml(npcName) + '">';
    html += '<div class="npc-rel-header">';
    html += '<span class="npc-rel-name">' + escapeHtml(npcName) + '</span>';
    html += '<span class="npc-rel-dynamic-pill">' + escapeHtml(dynamic) + '</span>';
    html += '</div>';
    html += '<div class="npc-rel-gauge">';
    html += '<div class="npc-rel-gauge-bar">';
    html += '<span class="npc-rel-gauge-marker" style="left: ' + valencePercent + '%"></span>';
    html += '</div>';
    html += '</div>';
    html += '<div class="npc-rel-details" style="display: none;">';
    if (history) {
      html += '<p class="npc-rel-detail"><strong>History:</strong> ' + escapeHtml(history) + '</p>';
    }
    if (currentTension) {
      html += '<p class="npc-rel-detail"><strong>Tension:</strong> ' + escapeHtml(currentTension) + '</p>';
    }
    if (leverage) {
      html += '<p class="npc-rel-detail"><strong>Leverage:</strong> ' + escapeHtml(leverage) + '</p>';
    }
    html += '</div>';
    html += '</div>';
    return html;
  }

  function bindNpcRelationshipCardToggles(panel) {
    if (!panel) {
      return;
    }
    var cards = panel.querySelectorAll('.npc-rel-card');
    cards.forEach(function(card) {
      var header = card.querySelector('.npc-rel-header');
      var details = card.querySelector('.npc-rel-details');
      if (!header || !details) {
        return;
      }
      header.addEventListener('click', function() {
        var isHidden = details.style.display === 'none';
        details.style.display = isHidden ? 'block' : 'none';
      });
    });
  }

  function renderNpcRelationshipsPanel(relationships, leftSidebarContainer) {
    var existingPanel = document.getElementById('npc-relationships-panel');

    if (!Array.isArray(relationships) || relationships.length === 0) {
      if (existingPanel) {
        existingPanel.remove();
      }
      return;
    }

    var cardsHtml = relationships.map(function(rel) {
      return renderNpcRelationshipCard(rel);
    }).join('');

    if (!cardsHtml) {
      if (existingPanel) {
        existingPanel.remove();
      }
      return;
    }

    if (existingPanel) {
      var content = existingPanel.querySelector('#npc-relationships-content');
      if (content) {
        content.innerHTML = cardsHtml;
      }
      bindNpcRelationshipCardToggles(existingPanel);
      return;
    }

    var panel = document.createElement('aside');
    panel.className = 'npc-relationships-panel';
    panel.id = 'npc-relationships-panel';
    panel.setAttribute('aria-labelledby', 'npc-relationships-title');
    panel.innerHTML = '<h3 class="npc-relationships-title" id="npc-relationships-title">NPC Relationships</h3>'
      + '<div class="npc-relationships-content" id="npc-relationships-content">'
      + cardsHtml
      + '</div>';

    // Insert after affect panel, before inventory panel
    var affectPanel = leftSidebarContainer.querySelector('#affect-panel');
    var inventoryPanel = leftSidebarContainer.querySelector('#inventory-panel');
    if (affectPanel && affectPanel.nextSibling) {
      leftSidebarContainer.insertBefore(panel, affectPanel.nextSibling);
    } else if (inventoryPanel) {
      leftSidebarContainer.insertBefore(panel, inventoryPanel);
    } else {
      leftSidebarContainer.appendChild(panel);
    }

    bindNpcRelationshipCardToggles(panel);
  }

  // ── State renderers ───────────────────────────────────────────────

  function renderStateChanges(changes, narrativeElement) {
    let stateChangesElement = document.getElementById('state-changes');

    if (Array.isArray(changes) && changes.length > 0) {
      const items = changes.map((change) => `<li>${escapeHtml(change)}</li>`).join('');
      const stateHtml = `<h4>What happened:</h4><ul>${items}</ul>`;

      if (stateChangesElement) {
        stateChangesElement.innerHTML = stateHtml;
        stateChangesElement.style.display = 'block';
      } else {
        stateChangesElement = document.createElement('aside');
        stateChangesElement.className = 'state-changes';
        stateChangesElement.id = 'state-changes';
        stateChangesElement.innerHTML = stateHtml;
        narrativeElement.after(stateChangesElement);
      }
    } else if (stateChangesElement) {
      stateChangesElement.style.display = 'none';
      stateChangesElement.innerHTML = '';
    }
  }

  function renderDeviationBanner(deviationInfo, choicesSectionEl) {
    const existingBanner = document.getElementById('deviation-banner');
    if (existingBanner) {
      existingBanner.remove();
    }

    if (!deviationInfo || !deviationInfo.detected) {
      return;
    }

    const beatsText = deviationInfo.beatsInvalidated
      ? ` (${deviationInfo.beatsInvalidated} story beat${deviationInfo.beatsInvalidated > 1 ? 's' : ''} replanned)`
      : '';

    const banner = document.createElement('aside');
    banner.className = 'deviation-banner';
    banner.id = 'deviation-banner';
    banner.innerHTML = `
        <div class="deviation-icon">&#x1F504;</div>
        <div class="deviation-content">
          <h4>Story Path Shifted</h4>
          <p>${escapeHtml(deviationInfo.reason)}${beatsText}</p>
        </div>
      `;

    if (choicesSectionEl) {
      choicesSectionEl.parentNode.insertBefore(banner, choicesSectionEl);
    }
  }


  // ── Error display ─────────────────────────────────────────────────

  function showPlayError(message, choicesSectionEl) {
    var errorBlock = choicesSectionEl.querySelector('#play-error');
    if (!errorBlock) {
      errorBlock = document.createElement('div');
      errorBlock.className = 'alert alert-error play-error';
      errorBlock.id = 'play-error';
      errorBlock.setAttribute('role', 'alert');
      errorBlock.setAttribute('aria-live', 'polite');
      const customChoiceEnums = choicesSectionEl.querySelector('.custom-choice-enums');
      if (customChoiceEnums) {
        customChoiceEnums.insertAdjacentElement('afterend', errorBlock);
      } else {
        choicesSectionEl.appendChild(errorBlock);
      }
    }

    errorBlock.textContent = message;
    errorBlock.style.display = 'block';
  }

  function clearPlayError(choicesSectionEl) {
    var errorBlock = choicesSectionEl.querySelector('#play-error');
    if (!errorBlock) {
      return;
    }

    errorBlock.textContent = '';
    errorBlock.style.display = 'none';
  }

  function showFormError(message) {
    let errorDiv = document.querySelector('.alert-error');
    if (!errorDiv) {
      errorDiv = document.createElement('div');
      errorDiv.className = 'alert alert-error';
      const form = document.querySelector('.story-form');
      if (form && form.parentNode) {
        form.parentNode.insertBefore(errorDiv, form);
      }
    }
    errorDiv.textContent = message;
    errorDiv.style.display = 'block';
  }


  // ── NPC manager ───────────────────────────────────────────────────

  function collectNpcEntries() {
    var entries = document.querySelectorAll('#npc-entries .npc-entry');
    var npcs = [];
    entries.forEach(function(entry) {
      var name = entry.querySelector('.npc-entry-header strong');
      var desc = entry.querySelector('.npc-entry-description');
      if (name && desc) {
        npcs.push({ name: name.textContent, description: desc.textContent });
      }
    });
    return npcs;
  }

  function addNpcEntry(name, description) {
    var container = document.getElementById('npc-entries');
    if (!container) return;

    var entry = document.createElement('div');
    entry.className = 'npc-entry';

    var header = document.createElement('div');
    header.className = 'npc-entry-header';

    var strong = document.createElement('strong');
    strong.textContent = name;

    var removeBtn = document.createElement('button');
    removeBtn.type = 'button';
    removeBtn.className = 'btn btn-small btn-danger npc-remove-btn';
    removeBtn.textContent = '\u00D7';
    removeBtn.addEventListener('click', function() {
      entry.remove();
    });

    header.appendChild(strong);
    header.appendChild(removeBtn);

    var descP = document.createElement('p');
    descP.className = 'npc-entry-description';
    descP.textContent = description;

    entry.appendChild(header);
    entry.appendChild(descP);
    container.appendChild(entry);
  }

  function initNpcControls() {
    var addBtn = document.getElementById('npc-add-btn');
    var nameInput = document.getElementById('npc-name-input');
    var descInput = document.getElementById('npc-desc-input');

    if (!addBtn || !nameInput || !descInput) return;

    addBtn.addEventListener('click', function() {
      var name = nameInput.value.trim();
      var desc = descInput.value.trim();
      if (!name || !desc) return;

      addNpcEntry(name, desc);
      nameInput.value = '';
      descInput.value = '';
      nameInput.focus();
    });

    // Bind remove buttons for server-rendered entries (validation error re-render)
    document.querySelectorAll('.npc-remove-btn').forEach(function(btn) {
      btn.addEventListener('click', function() {
        var entry = btn.closest('.npc-entry');
        if (entry) entry.remove();
      });
    });
  }


  // ── Controllers ───────────────────────────────────────────────────

  function initPlayPage() {
    const container = document.querySelector('.play-container');
    if (!container) {
      return;
    }

    const storyId = container.dataset.storyId;
    let currentPageId = Number.parseInt(container.dataset.pageId || '1', 10);
    if (!Number.isFinite(currentPageId) || currentPageId < 1) {
      currentPageId = 1;
    }

    const choicesSection = document.getElementById('choices-section');
    const choices = document.getElementById('choices');
    const narrative = document.getElementById('narrative');
    const loading = document.getElementById('loading');
    const apiKeyModal = document.getElementById('api-key-modal');
    const initialInsightsContext = parseInsightsContextFromDom();
    const insightsController = createAnalystInsightsController(parseAnalystDataFromDom(), initialInsightsContext);
    const recapController = createRecapModalController(parseRecapDataFromDom());
    const loreController = createLoreModalController(parseLoreDataFromDom());

    if (!storyId || !narrative || !loading || !apiKeyModal) {
      return;
    }

    var initialRelPanel = document.getElementById('npc-relationships-panel');
    if (initialRelPanel) {
      bindNpcRelationshipCardToggles(initialRelPanel);
    }

    const hasChoicesUi = choicesSection instanceof HTMLElement && choices instanceof HTMLElement;
    const loadingProgress = createLoadingProgressController(loading);

    function ensureApiKey() {
      return new Promise((resolve, reject) => {
        const key = getApiKey();
        if (key) {
          resolve(key);
          return;
        }

        const form = document.getElementById('api-key-form');
        const input = document.getElementById('modal-api-key');

        if (!(form instanceof HTMLFormElement) || !input) {
          reject(new Error('API key prompt is unavailable.'));
          return;
        }

        apiKeyModal.style.display = 'flex';

        const handleSubmit = (event) => {
          event.preventDefault();
          const newKey = input.value.trim();
          if (newKey.length < 10) {
            alert('Please enter a valid API key');
            return;
          }

          form.removeEventListener('submit', handleSubmit);
          setApiKey(newKey);
          apiKeyModal.style.display = 'none';
          resolve(newKey);
        };

        form.addEventListener('submit', handleSubmit);
      });
    }

    function getProtagonistGuidanceValues() {
      if (!choicesSection) {
        return { emotions: '', thoughts: '', speech: '' };
      }

      const emotionsEl = choicesSection.querySelector('#guidance-emotions');
      const thoughtsEl = choicesSection.querySelector('#guidance-thoughts');
      const speechEl = choicesSection.querySelector('#guidance-speech');

      return {
        emotions: emotionsEl instanceof HTMLTextAreaElement ? emotionsEl.value : '',
        thoughts: thoughtsEl instanceof HTMLTextAreaElement ? thoughtsEl.value : '',
        speech: speechEl instanceof HTMLTextAreaElement ? speechEl.value : '',
      };
    }

    function setChoicesDisabled(disabled) {
      if (!choices) {
        return;
      }
      const allButtons = choices.querySelectorAll('.choice-btn');
      allButtons.forEach((button) => {
        button.disabled = disabled;
      });
    }

    function handleCustomChoiceSubmit() {
      if (!choicesSection || !choices) {
        return;
      }
      const input = choicesSection.querySelector('.custom-choice-input');
      if (!input) return;

      const text = input.value.trim();
      if (!text) return;
      clearPlayError(choicesSection);

      const addBtn = choicesSection.querySelector('.custom-choice-btn');
      if (addBtn) addBtn.disabled = true;
      input.disabled = true;

      const choiceTypeSelect = choicesSection.querySelector('.custom-choice-type');
      const primaryDeltaSelect = choicesSection.querySelector('.custom-choice-delta');
      const choiceType = choiceTypeSelect ? choiceTypeSelect.value : 'TACTICAL_APPROACH';
      const primaryDelta = primaryDeltaSelect ? primaryDeltaSelect.value : 'GOAL_SHIFT';

      fetch(`/play/${storyId}/custom-choice`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ pageId: currentPageId, choiceText: text, choiceType: choiceType, primaryDelta: primaryDelta }),
      })
        .then(function(response) {
          return response.json().then(function(data) {
            if (!response.ok) {
              throw new Error(data.error || 'Failed to add custom choice');
            }
            return data;
          });
        })
        .then(function(data) {
          rebuildChoicesSection(
            data.choices,
            getProtagonistGuidanceValues(),
            choices,
            choicesSection,
            bindCustomChoiceEvents
          );
        })
        .catch(function(error) {
          showPlayError(error instanceof Error ? error.message : 'Failed to add custom choice', choicesSection);
          if (addBtn) addBtn.disabled = false;
          if (input) input.disabled = false;
        });
    }

    function bindCustomChoiceEvents() {
      if (!choicesSection) {
        return;
      }
      const addBtn = choicesSection.querySelector('.custom-choice-btn');
      const input = choicesSection.querySelector('.custom-choice-input');

      if (addBtn) {
        addBtn.addEventListener('click', handleCustomChoiceSubmit);
      }
      if (input) {
        input.addEventListener('keydown', function(e) {
          if (e.key === 'Enter') {
            e.preventDefault();
            handleCustomChoiceSubmit();
          }
        });
      }
    }

    if (hasChoicesUi) {
      // Bind events for the initial custom choice input rendered by the server
      bindCustomChoiceEvents();
    }

    if (hasChoicesUi) {
      choices.addEventListener('click', async (event) => {
        const clickedElement = event.target;
        if (!(clickedElement instanceof HTMLElement)) {
          return;
        }

        const button = clickedElement.closest('.choice-btn');
        if (!button || button.disabled) {
          return;
        }

        const choiceIndex = Number.parseInt(button.dataset.choiceIndex || '', 10);
        if (!Number.isFinite(choiceIndex) || choiceIndex < 0) {
          return;
        }

        try {
          clearPlayError(choicesSection);
          const isExplored = button.dataset.explored === 'true';
          const apiKey = isExplored ? getApiKey() : await ensureApiKey();

        setChoicesDisabled(true);
        loading.style.display = 'flex';

        const body = {
          pageId: currentPageId,
          choiceIndex,
          progressId: createProgressId(),
        };
        const guidanceValues = getProtagonistGuidanceValues();
        const protagonistGuidance = {};
        if (guidanceValues.emotions.trim().length > 0) {
          protagonistGuidance.suggestedEmotions = guidanceValues.emotions.trim();
        }
        if (guidanceValues.thoughts.trim().length > 0) {
          protagonistGuidance.suggestedThoughts = guidanceValues.thoughts.trim();
        }
        if (guidanceValues.speech.trim().length > 0) {
          protagonistGuidance.suggestedSpeech = guidanceValues.speech.trim();
        }
        if (Object.keys(protagonistGuidance).length > 0) {
          body.protagonistGuidance = protagonistGuidance;
        }
        if (apiKey) {
          body.apiKey = apiKey;
        }
        loadingProgress.start(body.progressId);

        const response = await fetch(`/play/${storyId}/choice`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(body),
        });

        const data = await response.json();

        if (!response.ok) {
          // Log enhanced error details if available
          if (data.code) {
            console.error('Error code:', data.code, '| Retryable:', data.retryable);
          }
          if (data.debug) {
            console.error('Debug info:', data.debug);
          }
          throw new Error(data.error || 'Failed to process choice');
        }

        if (!data.page) {
          throw new Error('Invalid response from server');
        }
        insightsController.update(data.page.analystResult, {
          actDisplayInfo: data.actDisplayInfo ? data.actDisplayInfo.displayString : null,
          sceneSummary: data.page.sceneSummary || null,
          resolvedThreadMeta: data.page.resolvedThreadMeta || {},
          resolvedPromiseMeta: data.page.resolvedPromiseMeta || {},
        });
        recapController.update(data.recapSummaries || []);

        currentPageId = data.page.id;
        container.dataset.pageId = String(currentPageId);

        history.pushState({}, '', `/play/${storyId}?page=${currentPageId}`);

        narrative.innerHTML = `<div class="narrative-text">${escapeHtmlWithBreaks(data.page.narrativeText || '')}</div>`;
        var leftSidebarContainer = ensureLeftSidebarContainer();
        renderAffectPanel(data.page.protagonistAffect, leftSidebarContainer);
        renderNpcRelationshipsPanel(data.page.npcRelationships, leftSidebarContainer);
        renderInventoryPanel(data.page.inventory, data.page.inventoryOverflowSummary, leftSidebarContainer);
        renderHealthPanel(data.page.health, data.page.healthOverflowSummary, leftSidebarContainer);
        cleanupEmptyLeftSidebar();
        loreController.update(data.globalCanon || [], data.globalCharacterCanon || {});
        var sidebarContainer = ensureSidebarContainer();
        renderOpenThreadsPanel(data.page.openThreads, data.page.openThreadOverflowSummary, sidebarContainer);
        renderActiveThreatsPanel(data.page.activeThreats, data.page.threatsOverflowSummary, sidebarContainer);
        renderActiveConstraintsPanel(data.page.activeConstraints, data.page.constraintsOverflowSummary, sidebarContainer);
        renderTrackedPromisesPanel(data.page.trackedPromises, data.page.trackedPromisesOverflowSummary, sidebarContainer);
        cleanupEmptySidebar();
        renderStateChanges(data.page.stateChanges, narrative);
        renderDeviationBanner(data.deviationInfo, choicesSection);

        const pageIndicator = document.querySelector('.page-indicator');
        if (pageIndicator) {
          pageIndicator.textContent = `Page ${currentPageId}`;
        }

        // Update act indicator based on response
        const actIndicator = document.querySelector('.act-indicator');
        if (data.actDisplayInfo) {
          if (actIndicator) {
            actIndicator.textContent = data.actDisplayInfo.displayString;
          } else {
            // Create act indicator if it doesn't exist yet
            const storyTitleSection = document.querySelector('.story-title-section');
            if (storyTitleSection) {
              const newIndicator = document.createElement('span');
              newIndicator.className = 'act-indicator';
              newIndicator.textContent = data.actDisplayInfo.displayString;
              storyTitleSection.appendChild(newIndicator);
            }
          }
        } else if (actIndicator) {
          // Remove act indicator if no act info
          actIndicator.remove();
        }

        if (data.page.isEnding) {
          choicesSection.innerHTML = `
            <div class="ending-banner">
              <h3>THE END</h3>
              <div class="ending-actions">
                <a href="/play/${storyId}/restart" class="btn btn-primary">Play Again</a>
                <a href="/" class="btn btn-secondary">Back to Stories</a>
              </div>
            </div>
          `;
        } else {
          const guidanceForRebuild = data.wasGenerated === true
            ? { emotions: '', thoughts: '', speech: '' }
            : getProtagonistGuidanceValues();
          rebuildChoicesSection(
            data.page.choices,
            guidanceForRebuild,
            choices,
            choicesSection,
            bindCustomChoiceEvents
          );
        }

        var storyHeader = document.getElementById('story-header');
        if (storyHeader) {
          storyHeader.scrollIntoView({ behavior: 'smooth' });
        } else {
          narrative.scrollIntoView({ behavior: 'smooth' });
        }
        } catch (error) {
          console.error('Error:', error);
          // Log additional debug info if available
          if (error && typeof error === 'object' && 'debug' in error) {
            console.error('Debug info:', error.debug);
          }
          if (choicesSection) {
            showPlayError(
              error instanceof Error ? error.message : 'Something went wrong. Please try again.',
              choicesSection
            );
          }
          setChoicesDisabled(false);
        } finally {
          loadingProgress.stop();
          loading.style.display = 'none';
        }
      });
    }

    window.addEventListener('popstate', () => {
      location.reload();
    });
  }

  function initNewStoryPage() {
    const form = document.querySelector('.story-form');
    const loading = document.getElementById('loading');
    const generateSpineBtn = document.getElementById('generate-spine-btn');
    const regenerateSpineBtn = document.getElementById('regenerate-spines-btn');
    const spineContainer = document.getElementById('spine-options');
    const spineSection = document.getElementById('spine-section');
    const errorDiv = document.querySelector('.alert-error');

    if (!form || !loading || !generateSpineBtn) {
      return;
    }
    const loadingProgress = createLoadingProgressController(loading);

    initNpcControls();

    function collectFormData() {
      var formData = new FormData(form);
      var npcs = collectNpcEntries();
      return {
        title: formData.get('title'),
        characterConcept: formData.get('characterConcept'),
        worldbuilding: formData.get('worldbuilding'),
        tone: formData.get('tone'),
        npcs: npcs.length > 0 ? npcs : undefined,
        startingSituation: formData.get('startingSituation'),
        apiKey: formData.get('apiKey'),
      };
    }

    async function fetchSpineOptions() {
      if (errorDiv) {
        errorDiv.style.display = 'none';
      }

      generateSpineBtn.disabled = true;
      if (regenerateSpineBtn) regenerateSpineBtn.disabled = true;
      loading.style.display = 'flex';
      var progressId = createProgressId();
      loadingProgress.start(progressId);

      try {
        var formValues = collectFormData();
        var response = await fetch('/stories/generate-spines', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            characterConcept: formValues.characterConcept,
            worldbuilding: formValues.worldbuilding,
            tone: formValues.tone,
            npcs: formValues.npcs,
            startingSituation: formValues.startingSituation,
            apiKey: formValues.apiKey,
            progressId: progressId,
          }),
        });

        var data = await response.json();

        if (!response.ok || !data.success) {
          if (data.code) {
            console.error('Error code:', data.code, '| Retryable:', data.retryable);
          }
          throw new Error(data.error || 'Failed to generate spine options');
        }

        setApiKey(formValues.apiKey);

        if (spineContainer && spineSection) {
          renderSpineOptions(data.options, spineContainer, function (option) {
            createStoryWithSpine(option);
          });
          spineSection.style.display = 'block';
          if (regenerateSpineBtn) regenerateSpineBtn.style.display = 'inline-block';
          spineSection.scrollIntoView({ behavior: 'smooth' });
        }
      } catch (error) {
        console.error('Spine generation error:', error);
        showFormError(error instanceof Error ? error.message : 'Something went wrong. Please try again.');
      } finally {
        loadingProgress.stop();
        loading.style.display = 'none';
        generateSpineBtn.disabled = false;
        if (regenerateSpineBtn) regenerateSpineBtn.disabled = false;
      }
    }

    async function createStoryWithSpine(spine) {
      if (errorDiv) {
        errorDiv.style.display = 'none';
      }

      generateSpineBtn.disabled = true;
      if (regenerateSpineBtn) regenerateSpineBtn.disabled = true;
      loading.style.display = 'flex';
      var progressId = createProgressId();
      loadingProgress.start(progressId);

      try {
        var formValues = collectFormData();
        var response = await fetch('/stories/create-ajax', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            title: formValues.title,
            characterConcept: formValues.characterConcept,
            worldbuilding: formValues.worldbuilding,
            tone: formValues.tone,
            npcs: formValues.npcs,
            startingSituation: formValues.startingSituation,
            apiKey: formValues.apiKey,
            spine: spine,
            progressId: progressId,
          }),
        });

        var data = await response.json();

        if (!response.ok || !data.success) {
          if (data.code) {
            console.error('Error code:', data.code, '| Retryable:', data.retryable);
          }
          if (data.debug) {
            console.error('Debug info:', data.debug);
          }
          throw new Error(data.error || 'Failed to create story');
        }

        window.location.assign('/play/' + data.storyId + '/briefing');
      } catch (error) {
        console.error('Story creation error:', error);
        showFormError(error instanceof Error ? error.message : 'Something went wrong. Please try again.');
        generateSpineBtn.disabled = false;
        if (regenerateSpineBtn) regenerateSpineBtn.disabled = false;
      } finally {
        loadingProgress.stop();
        loading.style.display = 'none';
      }
    }

    // Phase A: Generate Spine on button click
    generateSpineBtn.addEventListener('click', function (event) {
      event.preventDefault();
      fetchSpineOptions();
    });

    // Regenerate button
    if (regenerateSpineBtn) {
      regenerateSpineBtn.addEventListener('click', function (event) {
        event.preventDefault();
        if (spineContainer) clearSpineOptions(spineContainer);
        clearSelectedSpine();
        fetchSpineOptions();
      });
    }

    // Prevent default form submit (no longer a submit button)
    form.addEventListener('submit', function (event) {
      event.preventDefault();
    });
  }

  document.addEventListener('DOMContentLoaded', () => {
    initPlayPage();
    initNewStoryPage();
    initBriefingPage();
  });

  // ── Briefing page controller ─────────────────────────────────────

  function initBriefingPage() {
    var beginBtn = document.getElementById('begin-adventure-btn');
    var loading = document.getElementById('loading');
    var apiKeyModal = document.getElementById('api-key-modal');
    var briefingContainer = document.querySelector('.briefing-container');
    var errorBlock = document.getElementById('briefing-error');

    if (!beginBtn || !loading || !apiKeyModal || !briefingContainer) {
      return;
    }

    var storyId = briefingContainer.getAttribute('data-story-id');
    if (!storyId) {
      return;
    }

    var loadingProgress = createLoadingProgressController(loading);

    function setError(message) {
      if (!errorBlock) {
        return;
      }

      errorBlock.textContent = message;
      errorBlock.style.display = 'block';
    }

    function clearError() {
      if (!errorBlock) {
        return;
      }

      errorBlock.textContent = '';
      errorBlock.style.display = 'none';
    }

    function ensureApiKey() {
      return new Promise(function(resolve, reject) {
        var key = getApiKey();
        if (key) {
          resolve(key);
          return;
        }

        var form = document.getElementById('api-key-form');
        var input = document.getElementById('modal-api-key');
        var cancelBtn = document.getElementById('cancel-api-key');

        if (!(form instanceof HTMLFormElement) || !(input instanceof HTMLInputElement)) {
          reject(new Error('API key prompt is unavailable.'));
          return;
        }

        apiKeyModal.style.display = 'flex';

        function cleanup() {
          form.removeEventListener('submit', handleSubmit);
          if (cancelBtn) {
            cancelBtn.removeEventListener('click', handleCancel);
          }
        }

        function handleCancel() {
          cleanup();
          apiKeyModal.style.display = 'none';
          reject(new Error('API key is required.'));
        }

        function handleSubmit(event) {
          event.preventDefault();
          var newKey = input.value.trim();
          if (newKey.length < 10) {
            setError('Please enter a valid API key.');
            return;
          }

          clearError();
          cleanup();
          setApiKey(newKey);
          apiKeyModal.style.display = 'none';
          resolve(newKey);
        }

        form.addEventListener('submit', handleSubmit);
        if (cancelBtn) {
          cancelBtn.addEventListener('click', handleCancel);
        }
      });
    }

    async function beginAdventure(apiKey) {
      beginBtn.disabled = true;
      clearError();
      loading.style.display = 'flex';
      var progressId = createProgressId();
      loadingProgress.start(progressId);

      try {
        var response = await fetch('/play/' + storyId + '/begin', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            apiKey: apiKey,
            progressId: progressId,
          }),
        });
        var data = await response.json();

        if (!response.ok || !data.success) {
          throw new Error(data.error || 'Failed to begin adventure');
        }

        window.location.assign('/play/' + storyId + '?page=1&newStory=true');
      } catch (error) {
        setError(error instanceof Error ? error.message : 'Failed to begin adventure');
        beginBtn.disabled = false;
      } finally {
        loadingProgress.stop();
        loading.style.display = 'none';
      }
    }

    beginBtn.addEventListener('click', async function() {
      try {
        var apiKey = await ensureApiKey();
        await beginAdventure(apiKey);
      } catch (error) {
        setError(error instanceof Error ? error.message : 'Failed to begin adventure');
      }
    });
  }
})();
