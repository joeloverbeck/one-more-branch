/**
 * One More Branch - Client-side JavaScript
 * Generated by scripts/concat-client-js.js — do not edit directly.
 */

(function() {
  'use strict';

  // ── Configuration ──────────────────────────────────────────────────

  const API_KEY_STORAGE_KEY = 'omb_api_key';
  const PROGRESS_POLL_INTERVAL_MS = 1200;
  const PHRASE_ROTATION_MIN_MS = 3500;
  const PHRASE_ROTATION_MAX_MS = 4500;
  const OPEN_THREADS_PANEL_LIMIT = 6;
  const KEYED_ENTRY_PANEL_LIMIT = 6;
  const LEFT_PANEL_LIMIT = 10;

  const STAGE_PHRASE_POOLS = {
    PLANNING_PAGE: [
      'Consulting the crystal flowchart...',
      'Drawing arrows between dramatic possibilities...',
      'Balancing destiny on a clipboard...',
      'Whispering to the page planner gremlins...',
      'Calling a meeting of the tiny committee in the wall...',
      'Spinning the wheel of plausible chaos...',
      'Asking the couch cushions for strategic advice...',
      'Filing a permit for emotional turbulence...',
      'Color-coding fate with suspicious confidence...',
      'Unfolding the emergency roadmap of maybes...',
      'Negotiating with the timeline using snacks...',
      'Pinning red string to absolutely everything...',
      'Rolling percentile dice for narrative nonsense...',
      'Drafting plans in invisible ink and optimism...',
      'Testing three plans and a backup plan for the backup...',
      'Summoning a brainstorming thundercloud...',
      'Aligning plot magnets to true north drama...',
      'Cross-referencing vibes with hard evidence...',
      'Sharpening pencils to a tactical point...',
      'Budgeting exactly seven units of suspense...',
      'Interviewing three raccoons about long-term strategy...',
      'Mapping alternate futures on a napkin atlas...',
      'Counting plot beats with abacus-level confidence...',
      'Assembling a task force of overqualified pigeons...',
      'Translating chaos into bullet points and coffee rings...',
      'Scheduling destiny in 15-minute calendar blocks...',
      'Running a tabletop exercise for worst-case melodrama...',
      'Tuning the risk radar to "politely catastrophic"...',
      'Checking if the backup prophecy has a backup...',
      'Building a tiny model of the plot out of cereal...',
      'Holding auditions for the next big complication...',
      'Labeling each possibility with a caution sticker...',
      'Comparing timelines for structural squeaks...',
      'Drafting contingency plans on the back of moonlight...',
      'Assigning cliffhangers to their proper jurisdictions...',
      'Sending reconnaissance balloons into chapter two...',
      'Running cost estimates on emotional collateral...',
      'Verifying assumptions with a dramatic checklist...',
      'Plotting escape routes from predictable outcomes...',
      'Stress-testing Plan A against the laws of irony...',
      'Calculating odds with a haunted spreadsheet...',
      'Summoning a consultant possum for tactical input...',
      'Folding contingency plans into paper airplanes...',
      'Checking whether destiny signed the waiver...',
      'Setting up cones around high-risk plot zones...',
      'Feeding strategy grapes to the idea committee...',
      'Using divining rods to locate hidden opportunities...',
      'Building a decision tree out of toothpicks...',
      'Forecasting drama with a barometer and vibes...',
      'Asking the office fern to rank our options...',
      'Air-dropping priorities into a sandbox of chaos...',
      'Measuring uncertainty in teaspoons and sighs...',
      'Consulting the emergency binder labeled "yikes"...',
      'Running a war game with tiny cardboard villains...',
      'Assigning probability hats to every wild guess...',
      'Negotiating timeline treaties at the snack table...',
      'Drafting scenario maps with glitter pens only...',
      'Shuffling strategic options like tarot cards...',
      'Placing caution tape around suspiciously easy plans...',
      'Checking if fate left comments on the whiteboard...',
    ],
    CURATING_CONTEXT: [
      'Consulting the ancient tomes...',
      'Cross-referencing character grudges...',
      'Alphabetizing plot threads by urgency...',
      'Dusting off the relevant lore scrolls...',
      'Cataloging who knows what and why...',
      'Filing canon facts by scene relevance...',
      'Sifting through backstory for gold...',
      'Indexing every grudge, oath, and rumor...',
      'Sorting character baggage by weight...',
      'Highlighting the bits that actually matter...',
      'Trimming the lore hedge into shape...',
      'Cross-checking alibis with established canon...',
      'Retrieving the right dossiers from the vault...',
      'Marking worldbuilding passages for inclusion...',
      'Shelving irrelevant details with a polite nod...',
      'Assembling the scene-specific cheat sheet...',
      'Pulling character files from the archive...',
      'Condensing three volumes into one sticky note...',
      'Verifying which NPCs are in the room...',
      'Building a relationship map out of red string...',
      'Checking speech patterns against dialogue records...',
      'Curating only the juiciest canon facts...',
      'Reviewing who said what to whom and when...',
      'Extracting verbal tics from prior conversations...',
      'Filtering worldbuilding through the scene lens...',
      'Packaging emotional baggage for scene delivery...',
      'Compiling a dossier of relevant tensions...',
      'Tagging characters by scene importance...',
      'Archiving the stuff nobody needs right now...',
      'Preparing the scene-focused briefing packet...',
      'Auditing character relationships for freshness...',
      'Sorting history into chronological cause-and-effect...',
      'Stamping canon facts with relevance ratings...',
      'Rolling up lore into a portable scroll...',
      'Pruning the context garden of decorative weeds...',
      'Assembling the cast list for this scene...',
      'Verifying continuity seals are unbroken...',
      'Checking which promises are due this chapter...',
      'Building the scene bible with archival precision...',
      'Extracting only the load-bearing lore...',
      'Selecting the right emotional ammunition...',
      'Summarizing three acts of history in two paragraphs...',
      'Folding context into an origami cheat sheet...',
      'Organizing character dynamics by voltage level...',
      'Labeling each fact by expiration scene...',
      'Pulling relevant memories from the narrative vault...',
      'Scanning the timeline for causality chains...',
      'Compressing epic backstory into scene-sized packets...',
      'Cross-referencing motives with opportunity...',
      'Sorting the important from the merely interesting...',
      'Weighing each detail on the relevance scale...',
      'Assembling a greatest-hits of narrative context...',
      'Checking which character arcs are load-bearing...',
      'Preparing a briefcase of curated consequences...',
      'Filing emotional receipts by character name...',
      'Distilling worldbuilding into scene-grade concentrate...',
      'Reviewing the interpersonal tension inventory...',
      'Selecting speech samples for voice consistency...',
      'Packaging the past into a useful present...',
    ],
    WRITING_OPENING_PAGE: [
      'Rolling out the opening scene carpet...',
      'Polishing first impressions with glitter...',
      'Cueing the cinematic entrance music...',
      'Placing the camera at maximum drama angle...',
      'Turning on the fog machine for ambience...',
      'Teaching the narrator to make eye contact...',
      'Warming up the dialogue with tongue twisters...',
      'Deploying tasteful thunder in the distance...',
      'Adjusting the spotlight to "mysterious but friendly"...',
      'Setting out fresh metaphors in a neat row...',
      'Tuning the opening line to perfect pitch...',
      'Adding one dramatic pause for seasoning...',
      'Sweeping confetti off the exposition runway...',
      'Calibrating the first sentence launch sequence...',
      'Installing mood lighting in paragraph one...',
      'Bribing the hook to land cleanly...',
      'Giving the protagonist a very determined eyebrow...',
      'Pressing record on the cinematic narrator voice...',
      'Rehearsing the first reveal with jazz hands...',
      'Opening the curtain on controlled narrative chaos...',
      'Unboxing the very first sentence with white gloves...',
      'Loading the intro cannon with premium intrigue...',
      'Hanging a neon sign that says "pay attention"...',
      'Deploying a carefully trained opening gasp...',
      'Teaching paragraph one how to strut confidently...',
      'Spritzing the scene with fresh-pressed atmosphere...',
      'Dialing the narrative camera to impossible close-up...',
      'Placing a breadcrumb trail of irresistible questions...',
      'Testing the hook on a focus group of daydreamers...',
      'Repainting the sky in chapter-one colors...',
      'Priming the conflict engine for immediate ignition...',
      'Adding velvet ropes around the first big reveal...',
      'Handing the narrator a megaphone and a secret...',
      'Sculpting the opening beat with dramatic chisels...',
      'Letting the first line do one theatrical bow...',
      'Tightening the intro knots with narrative pliers...',
      'Positioning the stakes where everyone can trip on them...',
      'Charging the prologue batteries to 100 percent...',
      'Inviting curiosity to kick down the front door...',
      'Setting the tone dial to "you are now invested"...',
      'Sending the opening shot through a glamour filter...',
      'Preheating the first page to cinematic temperature...',
      'Waxing the runway for a dramatic character entrance...',
      'Packing the intro with legally approved goosebumps...',
      'Cueing a choir of suspiciously relevant violins...',
      'Teaching the first paragraph to wink at the reader...',
      'Unleashing a tiny stampede of immediate questions...',
      'Giving the hook a cape and excellent timing...',
      'Rolling out red carpet for the inciting incident...',
      'Polishing the premise until it catches moonlight...',
      'Adjusting atmosphere levels to "electric storm"...',
      'Planting one breadcrumb and seven complications...',
      'Sneaking tension into the room through the vents...',
      'Ironing the opening beats until they snap...',
      'Installing fireworks behind the first reveal...',
      'Teaching chapter one to kick the door in politely...',
      'Loading the scene with premium-grade anticipation...',
      'Strapping a rocket booster to the first conflict...',
      'Rehearsing the cold open with dramatic fanfare...',
      'Spiking the intro punch bowl with intrigue...',
    ],
    WRITING_CONTINUING_PAGE: [
      'Stitching consequences into the timeline...',
      'Keeping the plot train barely on the rails...',
      'Handing the scene to the next narrator...',
      'Adding one more suspiciously perfect twist...',
      'Refueling the momentum engine with cliffhangers...',
      'Untangling side quests from the chandelier...',
      'Passing notes between cause and effect...',
      'Patching continuity leaks with narrative gum...',
      'Setting the stakes to "gently terrifying"...',
      'Rotating the mystery box for better suspense...',
      'Escorting loose ends toward responsible adulthood...',
      'Threading foreshadowing through a tiny needle...',
      'Bolting the midpoint together with dramatic screws...',
      'Checking the subplot humidity levels...',
      'Giving consequences room to breathe ominously...',
      'Synchronizing character arcs with the moon phase...',
      'Reheating tension until pleasantly unstable...',
      'Guiding the pacing with a traffic baton...',
      'Sliding the dominoes into place with tweezers...',
      'Issuing plot passports for cross-scene travel...',
      'Escorting momentum past the valley of distractions...',
      'Tightening cause-and-effect with a torque wrench...',
      'Stacking fresh dilemmas like unstable pancakes...',
      'Refilling the tension reservoir one drop at a time...',
      'Sending character decisions through quality control...',
      'Keeping the subplot orchestra in the same tempo...',
      'Shoveling narrative coal into the third-act furnace...',
      'Documenting every consequence for legal reasons...',
      'Steering this chapter through emotional weather...',
      'Balancing revelations on a very narrow shelf...',
      'Adding controlled sparks to the conflict wiring...',
      'Rotating viewpoints to prevent dramatic traffic jams...',
      'Escalating stakes with OSHA-compliant urgency...',
      'Fastening the next beat with industrial foreshadowing...',
      'Checking dialogue pressure before the next release...',
      'Threading payoffs through active construction zones...',
      'Keeping the emotional RPMs in the red...',
      'Redirecting loose chaos into productive chaos...',
      'Feeding the suspense creature on a strict schedule...',
      'Escorting every choice toward glorious consequences...',
      'Passing the scene baton without dropping any secrets...',
      'Inflating the conflict balloon to optimal squeak...',
      'Splicing fresh momentum into the narrative bloodstream...',
      'Escorting revelations through a crowded hallway...',
      'Tightening suspense screws until they hum...',
      'Giving the stakes a double shot of espresso...',
      'Laying banana peels in front of bad decisions...',
      'Sweeping emotional shrapnel into future chapters...',
      'Keeping the tension kite aloft in crosswinds...',
      'Threading character growth through laser grids...',
      'Adding speed bumps before every easy answer...',
      'Scheduling consequences for prime-time impact...',
      'Greasing the plot gears with dramatic irony...',
      'Rolling the next complication down a marble track...',
      'Letting the subtext simmer on low chaos...',
      'Installing handrails on this slippery escalation...',
      'Routing every shortcut straight into trouble...',
      'Pressurizing the next beat for maximum pop...',
      'Funneling uncertainty into a very loud maybe...',
      'Keeping this chapter one decision away from disaster...',
    ],
    ANALYZING_SCENE: [
      'Checking the scene for narrative wobble...',
      'Comparing outcomes with the prophecy chart...',
      'Scanning for hidden cause-and-effect crumbs...',
      'Measuring tension levels with a tiny ruler...',
      'Dusting the clues for emotional fingerprints...',
      'Listening for suspiciously meaningful silence...',
      'Highlighting motifs in five shades of concern...',
      'Interrogating the subtext under bright lights...',
      'Charting who knows what on a corkboard...',
      'Running diagnostics on dramatic timing...',
      'Counting unresolved questions on both hands...',
      'Testing each beat for maximum narrative bounce...',
      'Inspecting dialogue for secret trapdoors...',
      'Triangulating intent, action, and fallout...',
      'Separating facts from very confident guesses...',
      'Scanning the room for Chekhov objects...',
      'Stress-testing the logic with a rubber hammer...',
      'Weighing emotional impact on calibrated scales...',
      'Decoding facial expressions into strategic data...',
      'Marking potential plot potholes with neon flags...',
      'Running forensic tests on suspicious adverbs...',
      'Cross-examining every beat for motive and means...',
      'Measuring subtext depth with sonar equipment...',
      'Cataloging narrative anomalies by timestamp...',
      'Comparing stated goals to actual chaos produced...',
      'Tracing dramatic footprints across the scene floor...',
      'Stress-auditing every reaction for plausibility...',
      'Triaging unresolved tension by urgency level...',
      'Putting each line under a microscope of intent...',
      'Building an evidence board out of eyebrow raises...',
      'Searching for quiet details doing loud work...',
      'Tagging emotional pivots with forensic tape...',
      'Verifying that every reveal earns its oxygen...',
      'Checking continuity seams for daylight leaks...',
      'Profiling conflict patterns for repeat offenders...',
      'Testing interpretation theories in a wind tunnel...',
      'Flagging dialogue that knows too much too soon...',
      'Auditing who changed, why, and at what cost...',
      'Reconstructing the scene from consequence fragments...',
      'Checking whether the silence says more than the speech...',
      'Running motive prints through the clue database...',
      'Timing each pause with a suspense stopwatch...',
      'Sampling the vibe for trace amounts of foreshadowing...',
      'Inspecting reactions for counterfeit confidence...',
      'Charting emotional weather by line and gesture...',
      'Testing every alibi under a hot desk lamp...',
      'Mapping power shifts with tiny magnetic arrows...',
      'Verifying who blinked first and why...',
      'Sifting dialogue sediment for hidden gold...',
      'Comparing what was said to what was swallowed...',
      'X-raying the scene for concealed turning points...',
      'Measuring dramatic friction with calibrated gloves...',
      'Isolating the exact moment the room changed shape...',
      'Tagging suspicious coincidences for lab review...',
      'Checking whether each choice leaves a footprint...',
      'Triangulating tension from tone, timing, and eye contact...',
      'Profiling every beat for intent-to-impact ratio...',
      'Stress-testing assumptions against inconvenient facts...',
      'Pinning red yarn between questions and consequences...',
      'Auditing the unspoken stuff for maximum significance...',
    ],
    RESTRUCTURING_STORY: [
      'Rearranging story beams without waking dragons...',
      'Tightening bolts on the adventure skeleton...',
      'Re-threading plot cables behind the walls...',
      'Deploying emergency structure duct tape...',
      'Moving chapter furniture with narrative dollies...',
      'Replacing squeaky scenes with reinforced tension...',
      'Installing support arcs under weak spots...',
      'Rerouting character traffic to reduce pileups...',
      'Welding the midpoint to the ending frame...',
      'Stacking stakes where they can do the most damage...',
      'Refitting transitions with smoother gears...',
      'Laying fresh track for the final act train...',
      'Demolishing one wobbly beat at a safe distance...',
      'Reinforcing the foundation with consequence cement...',
      'Hoisting the payoff into load-bearing position...',
      'Rebalancing the structure for emotional wind...',
      'Rewiring callbacks to the main power grid...',
      'Swapping in a sturdier sequence of events...',
      'Labeling every moving part "fragile but important"...',
      'Running final inspections with a hard hat...',
      'Relocating major twists to safer load-bearing chapters...',
      'Installing seismic braces for surprise reveals...',
      'Regrading the slope so tension flows downhill...',
      'Replacing narrative scaffolding with permanent supports...',
      'Cutting new doorways between disconnected scenes...',
      'Rebalancing act breaks to avoid dramatic sinkholes...',
      'Retrofitting the climax with reinforced cause-and-effect...',
      'Demoting decorative detours to optional side streets...',
      'Rerouting exposition through cleaner pipelines...',
      'Re-centering the core conflict on solid bedrock...',
      'Lifting sagging subplots with hydraulic jacks...',
      'Refitting the opening so the ending actually fits...',
      'Realigning chapter joints for smoother movement...',
      'Bolstering weak transitions with structural callbacks...',
      'Converting dead-end beats into through-lines...',
      'Consolidating duplicate conflicts into one heavy hitter...',
      'Replacing narrative bloat with precision-engineered stakes...',
      'Moving the emotional keystone back into place...',
      'Repainting the whole arc with clearer contrast...',
      'Running a full structural scan before reopening...',
      'Installing shock absorbers on every major twist...',
      'Redistributing weight away from the saggy middle...',
      'Replacing decorative scenes with load-bearing drama...',
      'Threading steel cables through the act breaks...',
      'Reinforcing weak joints with callback brackets...',
      'Rebuilding the climax staircase to code...',
      'Moving exposition crates off emergency exits...',
      'Swapping brittle beats for tempered story glass...',
      'Pouring fresh concrete under the central conflict...',
      'Converting narrative dead space into useful corridors...',
      'Retensioning the arc so it does not wobble...',
      'Installing pressure valves for high-stakes moments...',
      'Aligning every subplot gear with the master crank...',
      'Reframing chapter walls to fit bigger payoffs...',
      'Replacing mystery drywall with transparent intent...',
      'Upgrading transitions from rope bridge to highway...',
      'Hoisting delayed consequences into plain view...',
      'Routing emotional load through stronger pillars...',
      'Removing decorative scaffolds still pretending to be scenes...',
      'Checking the whole structure for sequel-proof stability...',
    ],
    RESOLVING_AGENDAS: [
      'Eavesdropping on NPCs whispering behind closed doors...',
      'Reviewing everyone\'s secret diary entries...',
      'Tracking who stabbed whom in the back today...',
      'Calculating grudge interest rates...',
      'Checking which NPCs are plotting revenge...',
      'Updating the grudge board with fresh pins...',
      'Listening at keyholes for nefarious scheming...',
      'Tallying up who owes favors to whom...',
      'Unfolding a corkboard of overlapping schemes...',
      'Cataloging side-eye incidents for future reference...',
      'Intercepting coded notes between shady allies...',
      'Checking whether anyone upgraded their backstabbing gear...',
      'Reviewing minutes from the secret villains\' brunch...',
      'Counting how many NPCs muttered "soon" this chapter...',
      'Auditing off-screen mischief reports...',
      'Filing incident reports for unsanctioned scheming...',
      'Measuring the ambient levels of treachery...',
      'Polling NPCs on their current treachery satisfaction...',
      'Cross-referencing alibis with suspicious absences...',
      'Recalculating everyone\'s loyalty scores...',
      'Monitoring the rumor mill for fresh gossip...',
      'Updating the conspiracy flowchart...',
      'Checking which NPCs have been pacing suspiciously...',
      'Reviewing blackmail material inventories...',
      'Verifying whether anyone sent ravens this turn...',
      'Scanning for dramatic monologue rehearsals...',
      'Adjusting NPC ambition sliders...',
      'Cataloging nervous glances exchanged this chapter...',
      'Running background checks on everyone\'s motives...',
      'Noting which NPCs smiled at the wrong moment...',
      'Tabulating petty feuds and ancient grudges...',
      'Sorting agendas by desperation level...',
      'Checking who\'s been sharpening metaphorical knives...',
      'Decoding passive-aggressive gift exchanges...',
      'Reviewing who has been suspiciously helpful lately...',
      'Evaluating the off-screen power shuffle...',
      'Tracking alliance formation and betrayal timelines...',
      'Checking which NPCs have contingency plans...',
      'Measuring fear levels against leverage ratios...',
      'Updating the "Who Wants What" spreadsheet...',
      'Intercepting a messenger pigeon with interesting news...',
      'Analyzing NPC body language from last scene...',
      'Checking if any NPCs have developed new anxieties...',
      'Reviewing the NPC suggestion box...',
      'Detecting a shift in the balance of scheming...',
      'Comparing stated intentions with actual behavior...',
      'Auditing the NPC snack cabinet for stress eating...',
      'Marking territories on the political influence map...',
      'Checking if anyone moved their chess pieces overnight...',
      'Reviewing suspicious purchases from the last chapter...',
      'Verifying that no one switched sides during the break...',
      'Running a threat assessment on recent compliments...',
      'Cataloging unfinished sentences and loaded pauses...',
      'Checking for unsigned letters slid under doors...',
      'Recalculating the probability of betrayal per NPC...',
      'Reviewing who has been making too many promises...',
      'Tracking which NPCs avoided eye contact this scene...',
      'Flagging characters with implausibly clean hands...',
      'Noting who laughed a little too long at dinner...',
      'Updating the off-screen activity ledger...',
    ],
  };
  const STAGE_DISPLAY_NAMES = {
    PLANNING_PAGE: 'PLANNING',
    CURATING_CONTEXT: 'LOREKEEPING',
    WRITING_OPENING_PAGE: 'WRITING',
    WRITING_CONTINUING_PAGE: 'WRITING',
    ANALYZING_SCENE: 'ANALYZING',
    RESTRUCTURING_STORY: 'RESTRUCTURING',
    RESOLVING_AGENDAS: 'SCHEMING',
  };

  // ── Choice / Delta enums and label maps ──────────────────────────

  var CHOICE_TYPES = [
    { value: 'TACTICAL_APPROACH', label: 'Method/Tactic' },
    { value: 'MORAL_DILEMMA', label: 'Moral Choice' },
    { value: 'IDENTITY_EXPRESSION', label: 'Define Yourself' },
    { value: 'RELATIONSHIP_SHIFT', label: 'Relationship' },
    { value: 'RESOURCE_COMMITMENT', label: 'Spend/Risk' },
    { value: 'INVESTIGATION', label: 'Investigate' },
    { value: 'PATH_DIVERGENCE', label: 'Change Direction' },
    { value: 'CONFRONTATION', label: 'Confront/Fight' },
    { value: 'AVOIDANCE_RETREAT', label: 'Avoid/Flee' },
  ];

  var PRIMARY_DELTAS = [
    { value: 'LOCATION_CHANGE', label: 'Location' },
    { value: 'GOAL_SHIFT', label: 'Goal' },
    { value: 'RELATIONSHIP_CHANGE', label: 'Relationship' },
    { value: 'URGENCY_CHANGE', label: 'Time Pressure' },
    { value: 'ITEM_CONTROL', label: 'Item' },
    { value: 'EXPOSURE_CHANGE', label: 'Attention' },
    { value: 'CONDITION_CHANGE', label: 'Condition' },
    { value: 'INFORMATION_REVEALED', label: 'Information' },
    { value: 'THREAT_SHIFT', label: 'Danger' },
    { value: 'CONSTRAINT_CHANGE', label: 'Limitation' },
  ];

  var CHOICE_TYPE_LABEL_MAP = {};
  CHOICE_TYPES.forEach(function(ct) { CHOICE_TYPE_LABEL_MAP[ct.value] = ct.label; });

  var PRIMARY_DELTA_LABEL_MAP = {};
  PRIMARY_DELTAS.forEach(function(pd) { PRIMARY_DELTA_LABEL_MAP[pd.value] = pd.label; });


  // ── Utility functions ──────────────────────────────────────────────

  function getApiKey() {
    return sessionStorage.getItem(API_KEY_STORAGE_KEY);
  }

  function setApiKey(key) {
    sessionStorage.setItem(API_KEY_STORAGE_KEY, key);
  }

  function createProgressId() {
    if (window.crypto && typeof window.crypto.randomUUID === 'function') {
      return window.crypto.randomUUID();
    }

    return 'progress-' + Date.now() + '-' + Math.random().toString(16).slice(2);
  }

  function getRandomInt(minInclusive, maxInclusive) {
    return Math.floor(Math.random() * (maxInclusive - minInclusive + 1)) + minInclusive;
  }

  function pickRandomPhrase(phrases, previousPhrase) {
    if (!Array.isArray(phrases) || phrases.length === 0) {
      return '';
    }

    if (phrases.length === 1) {
      return phrases[0];
    }

    var selected = phrases[getRandomInt(0, phrases.length - 1)];
    while (selected === previousPhrase) {
      selected = phrases[getRandomInt(0, phrases.length - 1)];
    }
    return selected;
  }

  function escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = String(text ?? '');
    return div.innerHTML;
  }

  function escapeHtmlWithBreaks(text) {
    return escapeHtml(text).replace(/\n/g, '<br>');
  }

  function enumToIconName(enumValue) {
    if (typeof enumValue !== 'string' || enumValue.length === 0) {
      return '';
    }
    return enumValue.toLowerCase().replace(/_/g, '-');
  }

  function getIconPath(enumValue) {
    var name = enumToIconName(enumValue);
    return name ? '/images/icons/' + name + '.png' : '';
  }


  // ── Loading progress controller ────────────────────────────────────

  function createLoadingProgressController(loadingElement) {
    var stageTextElement = loadingElement ? loadingElement.querySelector('.loading-stage') : null;
    var statusTextElement = loadingElement
      ? loadingElement.querySelector('.loading-status') || loadingElement.querySelector('p')
      : null;
    var fallbackText = statusTextElement && statusTextElement.textContent
      ? statusTextElement.textContent
      : 'Loading...';
    var stopped = true;
    var progressId = '';
    var currentStage = null;
    var currentPhrase = '';
    var pollTimeout = null;
    var phraseTimeout = null;

    function setStatusText(text) {
      if (statusTextElement) {
        statusTextElement.textContent = text;
      }
    }

    function setStageText(stageName) {
      if (stageTextElement) {
        stageTextElement.textContent = stageName || '';
      }
    }

    function clearTimers() {
      if (pollTimeout !== null) {
        clearTimeout(pollTimeout);
        pollTimeout = null;
      }
      if (phraseTimeout !== null) {
        clearTimeout(phraseTimeout);
        phraseTimeout = null;
      }
    }

    function setFallbackText() {
      currentStage = null;
      currentPhrase = '';
      if (phraseTimeout !== null) {
        clearTimeout(phraseTimeout);
        phraseTimeout = null;
      }
      setStageText('');
      setStatusText(fallbackText);
    }

    function schedulePhraseRotation() {
      if (phraseTimeout !== null) {
        clearTimeout(phraseTimeout);
        phraseTimeout = null;
      }

      if (stopped || !currentStage) {
        return;
      }

      var phrases = STAGE_PHRASE_POOLS[currentStage];
      if (!Array.isArray(phrases) || phrases.length === 0) {
        return;
      }

      var delay = getRandomInt(PHRASE_ROTATION_MIN_MS, PHRASE_ROTATION_MAX_MS);
      phraseTimeout = window.setTimeout(function() {
        if (stopped || !currentStage) {
          return;
        }
        currentPhrase = pickRandomPhrase(phrases, currentPhrase);
        setStatusText(currentPhrase);
        schedulePhraseRotation();
      }, delay);
    }

    function applyStage(stage) {
      var phrases = STAGE_PHRASE_POOLS[stage];
      if (!Array.isArray(phrases) || phrases.length === 0) {
        setFallbackText();
        return;
      }

      if (currentStage !== stage) {
        currentStage = stage;
        setStageText(STAGE_DISPLAY_NAMES[stage] || '');
        currentPhrase = '';
        currentPhrase = pickRandomPhrase(phrases, currentPhrase);
        setStatusText(currentPhrase);
        schedulePhraseRotation();
        return;
      }

      if (phraseTimeout === null) {
        schedulePhraseRotation();
      }
    }

    async function pollProgress() {
      if (stopped || !progressId) {
        return;
      }

      try {
        var response = await fetch('/generation-progress/' + encodeURIComponent(progressId), {
          cache: 'no-store',
        });

        if (!response.ok) {
          throw new Error('Progress polling failed');
        }

        var snapshot = await response.json();
        if (snapshot.status === 'running') {
          if (typeof snapshot.activeStage === 'string') {
            applyStage(snapshot.activeStage);
          } else {
            setFallbackText();
          }
        } else if (snapshot.status === 'unknown') {
          setFallbackText();
        } else if (snapshot.status === 'completed' || snapshot.status === 'failed') {
          stop();
          return;
        } else {
          setFallbackText();
        }
      } catch (_error) {
        setFallbackText();
      }

      if (!stopped) {
        pollTimeout = window.setTimeout(pollProgress, PROGRESS_POLL_INTERVAL_MS);
      }
    }

    function start(newProgressId) {
      stop();
      progressId = newProgressId;
      stopped = false;
      setFallbackText();
      void pollProgress();
    }

    function stop() {
      stopped = true;
      progressId = '';
      currentStage = null;
      currentPhrase = '';
      clearTimers();
      setStatusText(fallbackText);
    }

    return {
      start: start,
      stop: stop,
    };
  }


  // ── Thread renderers ──────────────────────────────────────────────

  function renderThreadBadgePill(threadType, urgency) {
    var threadTypeIconPath = getIconPath('thread_type_' + threadType);
    var urgencyIconPath = getIconPath('thread_urgency_' + urgency);
    var html = '<span class="thread-icon-pill" aria-hidden="true">';

    html += '<span class="thread-icon-badge thread-icon-badge--type">';
    if (threadTypeIconPath) {
      html += '<img class="thread-icon thread-icon--type"'
        + ' src="' + escapeHtml(threadTypeIconPath) + '"'
        + ' alt="" title="' + escapeHtml(threadType) + '"'
        + ' loading="lazy"'
        + " onerror=\"this.style.display='none'\">";
    }
    html += '</span>';

    html += '<span class="thread-icon-badge thread-icon-badge--urgency">';
    if (urgencyIconPath) {
      html += '<img class="thread-icon thread-icon--urgency"'
        + ' src="' + escapeHtml(urgencyIconPath) + '"'
        + ' alt="" title="' + escapeHtml(urgency) + '"'
        + ' loading="lazy"'
        + " onerror=\"this.style.display='none'\">";
    }
    html += '</span>';

    html += '</span>';
    return html;
  }

  function getOpenThreadUrgencyClass(urgency) {
    if (urgency === 'HIGH') {
      return 'open-threads-text--high';
    }
    if (urgency === 'MEDIUM') {
      return 'open-threads-text--medium';
    }
    if (urgency === 'LOW') {
      return 'open-threads-text--low';
    }
    return 'open-threads-text--low';
  }

  function getUrgencyPriority(urgency) {
    if (urgency === 'HIGH') {
      return 0;
    }
    if (urgency === 'MEDIUM') {
      return 1;
    }
    if (urgency === 'LOW') {
      return 2;
    }
    return 3;
  }

  function buildOpenThreadOverflowSummary(hiddenThreads) {
    if (!Array.isArray(hiddenThreads) || hiddenThreads.length === 0) {
      return null;
    }

    var highCount = 0;
    var mediumCount = 0;
    var lowCount = 0;

    hiddenThreads.forEach(function(thread) {
      if (thread.urgency === 'HIGH') {
        highCount += 1;
        return;
      }
      if (thread.urgency === 'MEDIUM') {
        mediumCount += 1;
        return;
      }
      if (thread.urgency === 'LOW') {
        lowCount += 1;
      }
    });

    var parts = [];
    if (highCount > 0) {
      parts.push(highCount + ' (high)');
    }
    if (mediumCount > 0) {
      parts.push(mediumCount + ' (medium)');
    }
    if (lowCount > 0) {
      parts.push(lowCount + ' (low)');
    }

    if (parts.length === 0) {
      return null;
    }

    return 'Not shown: ' + parts.join(', ');
  }

  function ensureSidebarContainer() {
    return document.getElementById('sidebar-widgets');
  }

  function cleanupEmptySidebar() {
    // Container is a grid cell; never remove it
  }

  function renderOpenThreadsPanel(openThreads, openThreadOverflowSummary, sidebarContainer) {
    const existingPanel = document.getElementById('open-threads-panel');

    if (!Array.isArray(openThreads) || openThreads.length === 0) {
      if (existingPanel) {
        existingPanel.remove();
      }
      return;
    }

    const normalizedThreads = openThreads
      .map(function(thread, index) {
        if (!thread || typeof thread !== 'object') {
          return null;
        }

        var id = typeof thread.id === 'string' ? thread.id : '';
        var text = typeof thread.text === 'string' ? thread.text : '';
        var threadType = typeof thread.threadType === 'string' ? thread.threadType : '';
        var urgency = typeof thread.urgency === 'string' ? thread.urgency : '';

        if (!id || !text || !threadType || !urgency) {
          return null;
        }

        return { id: id, text: text, threadType: threadType, urgency: urgency, index: index };
      })
      .filter(function(thread) {
        return thread !== null;
      })
      .sort(function(left, right) {
        var urgencyDelta = getUrgencyPriority(left.urgency) - getUrgencyPriority(right.urgency);
        if (urgencyDelta !== 0) {
          return urgencyDelta;
        }
        return left.index - right.index;
      });

    if (normalizedThreads.length === 0) {
      if (existingPanel) {
        existingPanel.remove();
      }
      return;
    }

    const visibleThreads = normalizedThreads.slice(0, OPEN_THREADS_PANEL_LIMIT);
    const hiddenThreads = normalizedThreads.slice(OPEN_THREADS_PANEL_LIMIT);
    const normalizedOverflowSummary =
      typeof openThreadOverflowSummary === 'string' && openThreadOverflowSummary.trim().length > 0
        ? openThreadOverflowSummary.trim()
        : buildOpenThreadOverflowSummary(hiddenThreads);

    const listHtml = visibleThreads.map(function(thread) {
      var urgencyClass = getOpenThreadUrgencyClass(thread.urgency);
      return '<li class="open-threads-item">'
        + renderThreadBadgePill(thread.threadType, thread.urgency)
        + '<span class="open-threads-text ' + urgencyClass + '">' + escapeHtml(thread.text) + '</span>'
        + '</li>';
    }).join('');

    if (existingPanel) {
      const list = existingPanel.querySelector('#open-threads-list');
      if (list) {
        list.innerHTML = listHtml;
      }
      const existingSummary = existingPanel.querySelector('#open-threads-overflow-summary');
      if (normalizedOverflowSummary) {
        if (existingSummary) {
          existingSummary.textContent = normalizedOverflowSummary;
        } else {
          const summary = document.createElement('div');
          summary.className = 'open-threads-overflow-summary';
          summary.id = 'open-threads-overflow-summary';
          summary.textContent = normalizedOverflowSummary;
          existingPanel.appendChild(summary);
        }
      } else if (existingSummary) {
        existingSummary.remove();
      }
      return;
    }

    const summaryHtml = normalizedOverflowSummary
      ? '<div class="open-threads-overflow-summary" id="open-threads-overflow-summary">'
          + escapeHtml(normalizedOverflowSummary)
          + '</div>'
      : '';
    const panel = document.createElement('aside');
    panel.className = 'open-threads-panel';
    panel.id = 'open-threads-panel';
    panel.setAttribute('aria-labelledby', 'open-threads-title');
    panel.innerHTML = '<h3 class="open-threads-title" id="open-threads-title">Active Threads</h3>'
      + '<ul class="open-threads-list" id="open-threads-list">'
      + listHtml
      + '</ul>'
      + summaryHtml;

    sidebarContainer.appendChild(panel);
  }

  function renderKeyedEntryPanel(config) {
    var existingPanel = document.getElementById(config.panelId);

    if (!Array.isArray(config.entries) || config.entries.length === 0) {
      if (existingPanel) {
        existingPanel.remove();
      }
      return;
    }

    var normalized = config.entries
      .filter(function(entry) {
        return entry && typeof entry === 'object'
          && typeof entry.id === 'string' && entry.id.length > 0
          && typeof entry.text === 'string' && entry.text.length > 0;
      });

    if (normalized.length === 0) {
      if (existingPanel) {
        existingPanel.remove();
      }
      return;
    }

    var limit = typeof config.limit === 'number' ? config.limit : KEYED_ENTRY_PANEL_LIMIT;
    var visible = normalized.slice(0, limit);
    var hiddenCount = normalized.length - limit;
    var overflowText = typeof config.overflowSummary === 'string' && config.overflowSummary.trim().length > 0
      ? config.overflowSummary.trim()
      : (hiddenCount > 0 ? '+' + hiddenCount + ' more not shown' : null);

    var listHtml = visible.map(function(entry) {
      return '<li class="' + config.itemClass + '">' + escapeHtml(entry.text) + '</li>';
    }).join('');

    if (existingPanel) {
      var list = existingPanel.querySelector('#' + config.listId);
      if (list) {
        list.innerHTML = listHtml;
      }
      var existingSummary = existingPanel.querySelector('#' + config.overflowId);
      if (overflowText) {
        if (existingSummary) {
          existingSummary.textContent = overflowText;
        } else {
          var summary = document.createElement('div');
          summary.className = 'keyed-entry-overflow-summary';
          summary.id = config.overflowId;
          summary.textContent = overflowText;
          existingPanel.appendChild(summary);
        }
      } else if (existingSummary) {
        existingSummary.remove();
      }
      return;
    }

    var summaryHtml = overflowText
      ? '<div class="keyed-entry-overflow-summary" id="' + config.overflowId + '">'
          + escapeHtml(overflowText)
          + '</div>'
      : '';
    var panel = document.createElement('aside');
    panel.className = config.panelClass;
    panel.id = config.panelId;
    panel.setAttribute('aria-labelledby', config.titleId);
    panel.innerHTML = '<h3 class="' + config.titleClass + '" id="' + config.titleId + '">'
      + escapeHtml(config.title) + '</h3>'
      + '<ul class="' + config.listClass + '" id="' + config.listId + '">'
      + listHtml
      + '</ul>'
      + summaryHtml;

    config.container.appendChild(panel);
  }

  function renderActiveThreatsPanel(threats, threatsOverflowSummary, sidebarContainer) {
    renderKeyedEntryPanel({
      panelId: 'active-threats-panel',
      titleId: 'active-threats-title',
      listId: 'active-threats-list',
      overflowId: 'active-threats-overflow',
      panelClass: 'active-threats-panel',
      titleClass: 'active-threats-title',
      listClass: 'active-threats-list',
      itemClass: 'active-threats-item',
      title: 'Active Threats',
      entries: threats,
      overflowSummary: threatsOverflowSummary,
      container: sidebarContainer,
    });
  }

  function renderActiveConstraintsPanel(constraints, constraintsOverflowSummary, sidebarContainer) {
    renderKeyedEntryPanel({
      panelId: 'active-constraints-panel',
      titleId: 'active-constraints-title',
      listId: 'active-constraints-list',
      overflowId: 'active-constraints-overflow',
      panelClass: 'active-constraints-panel',
      titleClass: 'active-constraints-title',
      listClass: 'active-constraints-list',
      itemClass: 'active-constraints-item',
      title: 'Active Constraints',
      entries: constraints,
      overflowSummary: constraintsOverflowSummary,
      container: sidebarContainer,
    });
  }

  function ensureLeftSidebarContainer() {
    return document.getElementById('left-sidebar-widgets');
  }

  function cleanupEmptyLeftSidebar() {
    // Container is a grid cell; never remove it
  }

  function renderInventoryPanel(inventory, inventoryOverflowSummary, leftSidebarContainer) {
    renderKeyedEntryPanel({
      panelId: 'inventory-panel',
      titleId: 'inventory-title',
      listId: 'inventory-list',
      overflowId: 'inventory-overflow',
      panelClass: 'inventory-panel',
      titleClass: 'inventory-title',
      listClass: 'inventory-list',
      itemClass: 'inventory-item',
      title: 'Inventory',
      entries: inventory,
      overflowSummary: inventoryOverflowSummary,
      container: leftSidebarContainer,
      limit: LEFT_PANEL_LIMIT,
    });
  }

  function renderHealthPanel(health, healthOverflowSummary, leftSidebarContainer) {
    renderKeyedEntryPanel({
      panelId: 'health-panel',
      titleId: 'health-title',
      listId: 'health-list',
      overflowId: 'health-overflow',
      panelClass: 'health-panel',
      titleClass: 'health-title',
      listClass: 'health-list',
      itemClass: 'health-item',
      title: 'Health',
      entries: health,
      overflowSummary: healthOverflowSummary,
      container: leftSidebarContainer,
      limit: LEFT_PANEL_LIMIT,
    });
  }


  // ── Choice renderers ──────────────────────────────────────────────

  function renderChoiceButtons(choiceList) {
    return choiceList.map(function(choice, index) {
      var isExplored = Boolean(choice.nextPageId);
      var choiceText = typeof choice.text === 'string' ? choice.text : '';
      var choiceType = typeof choice.choiceType === 'string' ? choice.choiceType : '';
      var primaryDelta = typeof choice.primaryDelta === 'string' ? choice.primaryDelta : '';

      var typeIconPath = getIconPath(choiceType);
      var deltaIconPath = getIconPath(primaryDelta);
      var typeLabel = CHOICE_TYPE_LABEL_MAP[choiceType] || '';
      var deltaLabel = PRIMARY_DELTA_LABEL_MAP[primaryDelta] || '';

      var pillHtml = '';
      if (typeIconPath || deltaIconPath) {
        pillHtml = '<span class="choice-icon-pill" aria-hidden="true">';
        if (typeIconPath) {
          pillHtml += '<img class="choice-icon choice-icon--type"'
            + ' src="' + escapeHtml(typeIconPath) + '"'
            + ' alt="" title="' + escapeHtml(typeLabel) + '"'
            + ' width="32" height="32" loading="lazy"'
            + " onerror=\"this.style.display='none'\">";
        }
        if (deltaIconPath) {
          pillHtml += '<img class="choice-icon choice-icon--delta"'
            + ' src="' + escapeHtml(deltaIconPath) + '"'
            + ' alt="" title="' + escapeHtml(deltaLabel) + '"'
            + ' width="32" height="32" loading="lazy"'
            + " onerror=\"this.style.display='none'\">";
        }
        pillHtml += '</span>';
      }

      return '<div class="choice-row">'
        + pillHtml
        + '<button'
        + ' class="choice-btn"'
        + ' data-choice-index="' + index + '"'
        + ' data-choice-type="' + escapeHtml(choiceType) + '"'
        + ' data-primary-delta="' + escapeHtml(primaryDelta) + '"'
        + (isExplored ? ' data-explored="true"' : '')
        + '>'
        + '<span class="choice-text">' + escapeHtml(choiceText) + '</span>'
        + '</button>'
        + (isExplored ? '<span class="explored-marker" title="Previously explored">&#8617;</span>' : '')
        + '</div>';
    }).join('');
  }

  function renderSelectOptions(items) {
    return items.map(function(item) {
      return '<option value="' + escapeHtml(item.value) + '">' + escapeHtml(item.label) + '</option>';
    }).join('');
  }

  function renderCustomChoiceInput(suggestedSpeechValue) {
    const safeSuggestedSpeechValue = typeof suggestedSpeechValue === 'string'
      ? suggestedSpeechValue
      : '';

    return `
        <div class="suggested-protagonist-speech-container">
          <input
            type="text"
            id="suggested-protagonist-speech-input"
            class="suggested-protagonist-speech-input"
            placeholder="Suggest something your protagonist might say..."
            maxlength="500"
            value="${escapeHtml(safeSuggestedSpeechValue)}"
          />
        </div>
        <div class="custom-choice-container">
          <input type="text" class="custom-choice-input"
                 placeholder="Introduce your own custom choice..."
                 maxlength="500" />
          <button type="button" class="custom-choice-btn">Add</button>
        </div>
        <div class="custom-choice-enums">
          <select class="custom-choice-type">
            ${renderSelectOptions(CHOICE_TYPES)}
          </select>
          <select class="custom-choice-delta">
            ${renderSelectOptions(PRIMARY_DELTAS)}
          </select>
        </div>
        <div class="alert alert-error play-error" id="play-error" style="display: none;" role="alert" aria-live="polite"></div>
      `;
  }

  function rebuildChoicesSection(choiceList, suggestedSpeechValue, choicesEl, choicesSectionEl, bindFn) {
    choicesEl.innerHTML = renderChoiceButtons(choiceList);
    const existingSuggestedSpeech = choicesSectionEl.querySelector('.suggested-protagonist-speech-container');
    if (existingSuggestedSpeech) {
      existingSuggestedSpeech.remove();
    }
    const existingCustom = choicesSectionEl.querySelector('.custom-choice-container');
    if (existingCustom) {
      existingCustom.remove();
    }
    const existingEnums = choicesSectionEl.querySelector('.custom-choice-enums');
    if (existingEnums) {
      existingEnums.remove();
    }
    choicesEl.insertAdjacentHTML('afterend', renderCustomChoiceInput(suggestedSpeechValue));
    bindFn();
  }


  // ── State renderers ───────────────────────────────────────────────

  function renderStateChanges(changes, narrativeElement) {
    let stateChangesElement = document.getElementById('state-changes');

    if (Array.isArray(changes) && changes.length > 0) {
      const items = changes.map((change) => `<li>${escapeHtml(change)}</li>`).join('');
      const stateHtml = `<h4>What happened:</h4><ul>${items}</ul>`;

      if (stateChangesElement) {
        stateChangesElement.innerHTML = stateHtml;
        stateChangesElement.style.display = 'block';
      } else {
        stateChangesElement = document.createElement('aside');
        stateChangesElement.className = 'state-changes';
        stateChangesElement.id = 'state-changes';
        stateChangesElement.innerHTML = stateHtml;
        narrativeElement.after(stateChangesElement);
      }
    } else if (stateChangesElement) {
      stateChangesElement.style.display = 'none';
      stateChangesElement.innerHTML = '';
    }
  }

  function renderDeviationBanner(deviationInfo, choicesSectionEl) {
    const existingBanner = document.getElementById('deviation-banner');
    if (existingBanner) {
      existingBanner.remove();
    }

    if (!deviationInfo || !deviationInfo.detected) {
      return;
    }

    const beatsText = deviationInfo.beatsInvalidated
      ? ` (${deviationInfo.beatsInvalidated} story beat${deviationInfo.beatsInvalidated > 1 ? 's' : ''} replanned)`
      : '';

    const banner = document.createElement('aside');
    banner.className = 'deviation-banner';
    banner.id = 'deviation-banner';
    banner.innerHTML = `
        <div class="deviation-icon">&#x1F504;</div>
        <div class="deviation-content">
          <h4>Story Path Shifted</h4>
          <p>${escapeHtml(deviationInfo.reason)}${beatsText}</p>
        </div>
      `;

    if (choicesSectionEl) {
      choicesSectionEl.parentNode.insertBefore(banner, choicesSectionEl);
    }
  }


  // ── Error display ─────────────────────────────────────────────────

  function showPlayError(message, choicesSectionEl) {
    var errorBlock = choicesSectionEl.querySelector('#play-error');
    if (!errorBlock) {
      errorBlock = document.createElement('div');
      errorBlock.className = 'alert alert-error play-error';
      errorBlock.id = 'play-error';
      errorBlock.setAttribute('role', 'alert');
      errorBlock.setAttribute('aria-live', 'polite');
      const customChoiceEnums = choicesSectionEl.querySelector('.custom-choice-enums');
      if (customChoiceEnums) {
        customChoiceEnums.insertAdjacentElement('afterend', errorBlock);
      } else {
        choicesSectionEl.appendChild(errorBlock);
      }
    }

    errorBlock.textContent = message;
    errorBlock.style.display = 'block';
  }

  function clearPlayError(choicesSectionEl) {
    var errorBlock = choicesSectionEl.querySelector('#play-error');
    if (!errorBlock) {
      return;
    }

    errorBlock.textContent = '';
    errorBlock.style.display = 'none';
  }

  function showFormError(message) {
    let errorDiv = document.querySelector('.alert-error');
    if (!errorDiv) {
      errorDiv = document.createElement('div');
      errorDiv.className = 'alert alert-error';
      const form = document.querySelector('.story-form');
      if (form && form.parentNode) {
        form.parentNode.insertBefore(errorDiv, form);
      }
    }
    errorDiv.textContent = message;
    errorDiv.style.display = 'block';
  }


  // ── NPC manager ───────────────────────────────────────────────────

  function collectNpcEntries() {
    var entries = document.querySelectorAll('#npc-entries .npc-entry');
    var npcs = [];
    entries.forEach(function(entry) {
      var name = entry.querySelector('.npc-entry-header strong');
      var desc = entry.querySelector('.npc-entry-description');
      if (name && desc) {
        npcs.push({ name: name.textContent, description: desc.textContent });
      }
    });
    return npcs;
  }

  function addNpcEntry(name, description) {
    var container = document.getElementById('npc-entries');
    if (!container) return;

    var entry = document.createElement('div');
    entry.className = 'npc-entry';

    var header = document.createElement('div');
    header.className = 'npc-entry-header';

    var strong = document.createElement('strong');
    strong.textContent = name;

    var removeBtn = document.createElement('button');
    removeBtn.type = 'button';
    removeBtn.className = 'btn btn-small btn-danger npc-remove-btn';
    removeBtn.textContent = '\u00D7';
    removeBtn.addEventListener('click', function() {
      entry.remove();
    });

    header.appendChild(strong);
    header.appendChild(removeBtn);

    var descP = document.createElement('p');
    descP.className = 'npc-entry-description';
    descP.textContent = description;

    entry.appendChild(header);
    entry.appendChild(descP);
    container.appendChild(entry);
  }

  function initNpcControls() {
    var addBtn = document.getElementById('npc-add-btn');
    var nameInput = document.getElementById('npc-name-input');
    var descInput = document.getElementById('npc-desc-input');

    if (!addBtn || !nameInput || !descInput) return;

    addBtn.addEventListener('click', function() {
      var name = nameInput.value.trim();
      var desc = descInput.value.trim();
      if (!name || !desc) return;

      addNpcEntry(name, desc);
      nameInput.value = '';
      descInput.value = '';
      nameInput.focus();
    });

    // Bind remove buttons for server-rendered entries (validation error re-render)
    document.querySelectorAll('.npc-remove-btn').forEach(function(btn) {
      btn.addEventListener('click', function() {
        var entry = btn.closest('.npc-entry');
        if (entry) entry.remove();
      });
    });
  }


  // ── Controllers ───────────────────────────────────────────────────

  function initPlayPage() {
    const container = document.querySelector('.play-container');
    if (!container) {
      return;
    }

    const storyId = container.dataset.storyId;
    let currentPageId = Number.parseInt(container.dataset.pageId || '1', 10);
    if (!Number.isFinite(currentPageId) || currentPageId < 1) {
      currentPageId = 1;
    }

    const choicesSection = document.getElementById('choices-section');
    const choices = document.getElementById('choices');
    const narrative = document.getElementById('narrative');
    const loading = document.getElementById('loading');
    const apiKeyModal = document.getElementById('api-key-modal');

    if (!storyId || !choicesSection || !choices || !narrative || !loading || !apiKeyModal) {
      return;
    }
    const loadingProgress = createLoadingProgressController(loading);

    function ensureApiKey() {
      return new Promise((resolve, reject) => {
        const key = getApiKey();
        if (key) {
          resolve(key);
          return;
        }

        const form = document.getElementById('api-key-form');
        const input = document.getElementById('modal-api-key');

        if (!(form instanceof HTMLFormElement) || !input) {
          reject(new Error('API key prompt is unavailable.'));
          return;
        }

        apiKeyModal.style.display = 'flex';

        const handleSubmit = (event) => {
          event.preventDefault();
          const newKey = input.value.trim();
          if (newKey.length < 10) {
            alert('Please enter a valid API key');
            return;
          }

          form.removeEventListener('submit', handleSubmit);
          setApiKey(newKey);
          apiKeyModal.style.display = 'none';
          resolve(newKey);
        };

        form.addEventListener('submit', handleSubmit);
      });
    }

    function getSuggestedProtagonistSpeechInputValue() {
      const suggestedSpeechInput = choicesSection.querySelector('.suggested-protagonist-speech-input');
      if (!(suggestedSpeechInput instanceof HTMLInputElement)) {
        return '';
      }

      return suggestedSpeechInput.value;
    }

    function setChoicesDisabled(disabled) {
      const allButtons = choices.querySelectorAll('.choice-btn');
      allButtons.forEach((button) => {
        button.disabled = disabled;
      });
    }

    function handleCustomChoiceSubmit() {
      const input = choicesSection.querySelector('.custom-choice-input');
      if (!input) return;

      const text = input.value.trim();
      if (!text) return;
      clearPlayError(choicesSection);

      const addBtn = choicesSection.querySelector('.custom-choice-btn');
      if (addBtn) addBtn.disabled = true;
      input.disabled = true;

      const choiceTypeSelect = choicesSection.querySelector('.custom-choice-type');
      const primaryDeltaSelect = choicesSection.querySelector('.custom-choice-delta');
      const choiceType = choiceTypeSelect ? choiceTypeSelect.value : 'TACTICAL_APPROACH';
      const primaryDelta = primaryDeltaSelect ? primaryDeltaSelect.value : 'GOAL_SHIFT';

      fetch(`/play/${storyId}/custom-choice`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ pageId: currentPageId, choiceText: text, choiceType: choiceType, primaryDelta: primaryDelta }),
      })
        .then(function(response) {
          return response.json().then(function(data) {
            if (!response.ok) {
              throw new Error(data.error || 'Failed to add custom choice');
            }
            return data;
          });
        })
        .then(function(data) {
          rebuildChoicesSection(data.choices, getSuggestedProtagonistSpeechInputValue(), choices, choicesSection, bindCustomChoiceEvents);
        })
        .catch(function(error) {
          showPlayError(error instanceof Error ? error.message : 'Failed to add custom choice', choicesSection);
          if (addBtn) addBtn.disabled = false;
          if (input) input.disabled = false;
        });
    }

    function bindCustomChoiceEvents() {
      const addBtn = choicesSection.querySelector('.custom-choice-btn');
      const input = choicesSection.querySelector('.custom-choice-input');

      if (addBtn) {
        addBtn.addEventListener('click', handleCustomChoiceSubmit);
      }
      if (input) {
        input.addEventListener('keydown', function(e) {
          if (e.key === 'Enter') {
            e.preventDefault();
            handleCustomChoiceSubmit();
          }
        });
      }
    }

    // Bind events for the initial custom choice input rendered by the server
    bindCustomChoiceEvents();

    choices.addEventListener('click', async (event) => {
      const clickedElement = event.target;
      if (!(clickedElement instanceof HTMLElement)) {
        return;
      }

      const button = clickedElement.closest('.choice-btn');
      if (!button || button.disabled) {
        return;
      }

      const choiceIndex = Number.parseInt(button.dataset.choiceIndex || '', 10);
      if (!Number.isFinite(choiceIndex) || choiceIndex < 0) {
        return;
      }

      try {
        clearPlayError(choicesSection);
        const isExplored = button.dataset.explored === 'true';
        const apiKey = isExplored ? getApiKey() : await ensureApiKey();

        setChoicesDisabled(true);
        loading.style.display = 'flex';

        const body = {
          pageId: currentPageId,
          choiceIndex,
          progressId: createProgressId(),
        };
        const suggestedProtagonistSpeech = getSuggestedProtagonistSpeechInputValue().trim();
        if (suggestedProtagonistSpeech.length > 0) {
          body.suggestedProtagonistSpeech = suggestedProtagonistSpeech;
        }
        if (apiKey) {
          body.apiKey = apiKey;
        }
        loadingProgress.start(body.progressId);

        const response = await fetch(`/play/${storyId}/choice`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(body),
        });

        const data = await response.json();

        if (!response.ok) {
          // Log enhanced error details if available
          if (data.code) {
            console.error('Error code:', data.code, '| Retryable:', data.retryable);
          }
          if (data.debug) {
            console.error('Debug info:', data.debug);
          }
          throw new Error(data.error || 'Failed to process choice');
        }

        if (!data.page) {
          throw new Error('Invalid response from server');
        }

        currentPageId = data.page.id;
        container.dataset.pageId = String(currentPageId);

        history.pushState({}, '', `/play/${storyId}?page=${currentPageId}`);

        narrative.innerHTML = `<div class="narrative-text">${escapeHtmlWithBreaks(data.page.narrativeText || '')}</div>`;
        var leftSidebarContainer = ensureLeftSidebarContainer();
        renderInventoryPanel(data.page.inventory, data.page.inventoryOverflowSummary, leftSidebarContainer);
        renderHealthPanel(data.page.health, data.page.healthOverflowSummary, leftSidebarContainer);
        cleanupEmptyLeftSidebar();
        var sidebarContainer = ensureSidebarContainer();
        renderOpenThreadsPanel(data.page.openThreads, data.page.openThreadOverflowSummary, sidebarContainer);
        renderActiveThreatsPanel(data.page.activeThreats, data.page.threatsOverflowSummary, sidebarContainer);
        renderActiveConstraintsPanel(data.page.activeConstraints, data.page.constraintsOverflowSummary, sidebarContainer);
        cleanupEmptySidebar();
        renderStateChanges(data.page.stateChanges, narrative);
        renderDeviationBanner(data.deviationInfo, choicesSection);

        const pageIndicator = document.querySelector('.page-indicator');
        if (pageIndicator) {
          pageIndicator.textContent = `Page ${currentPageId}`;
        }

        // Update act indicator based on response
        const actIndicator = document.querySelector('.act-indicator');
        if (data.actDisplayInfo) {
          if (actIndicator) {
            actIndicator.textContent = data.actDisplayInfo.displayString;
          } else {
            // Create act indicator if it doesn't exist yet
            const storyTitleSection = document.querySelector('.story-title-section');
            if (storyTitleSection) {
              const newIndicator = document.createElement('span');
              newIndicator.className = 'act-indicator';
              newIndicator.textContent = data.actDisplayInfo.displayString;
              storyTitleSection.appendChild(newIndicator);
            }
          }
        } else if (actIndicator) {
          // Remove act indicator if no act info
          actIndicator.remove();
        }

        if (data.page.isEnding) {
          choicesSection.innerHTML = `
            <div class="ending-banner">
              <h3>THE END</h3>
              <div class="ending-actions">
                <a href="/play/${storyId}/restart" class="btn btn-primary">Play Again</a>
                <a href="/" class="btn btn-secondary">Back to Stories</a>
              </div>
            </div>
          `;
        } else {
          const suggestedSpeechValue = data.wasGenerated === true
            ? ''
            : getSuggestedProtagonistSpeechInputValue();
          rebuildChoicesSection(data.page.choices, suggestedSpeechValue, choices, choicesSection, bindCustomChoiceEvents);
        }

        narrative.scrollIntoView({ behavior: 'smooth' });
      } catch (error) {
        console.error('Error:', error);
        // Log additional debug info if available
        if (error && typeof error === 'object' && 'debug' in error) {
          console.error('Debug info:', error.debug);
        }
        showPlayError(error instanceof Error ? error.message : 'Something went wrong. Please try again.', choicesSection);
        setChoicesDisabled(false);
      } finally {
        loadingProgress.stop();
        loading.style.display = 'none';
      }
    });

    window.addEventListener('popstate', () => {
      location.reload();
    });
  }

  function initNewStoryPage() {
    const form = document.querySelector('.story-form');
    const loading = document.getElementById('loading');
    const submitBtn = form ? form.querySelector('button[type="submit"]') : null;
    const errorDiv = document.querySelector('.alert-error');

    if (!form || !loading || !submitBtn) {
      return;
    }
    const loadingProgress = createLoadingProgressController(loading);

    initNpcControls();

    form.addEventListener('submit', async (event) => {
      event.preventDefault();

      if (errorDiv) {
        errorDiv.style.display = 'none';
      }

      submitBtn.disabled = true;
      loading.style.display = 'flex';
      const progressId = createProgressId();
      loadingProgress.start(progressId);
      var shouldReenable = false;

      try {
        const formData = new FormData(form);
        const npcs = collectNpcEntries();
        const response = await fetch('/stories/create-ajax', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            title: formData.get('title'),
            characterConcept: formData.get('characterConcept'),
            worldbuilding: formData.get('worldbuilding'),
            tone: formData.get('tone'),
            npcs: npcs.length > 0 ? npcs : undefined,
            startingSituation: formData.get('startingSituation'),
            apiKey: formData.get('apiKey'),
            progressId: progressId,
          }),
        });

        const data = await response.json();

        if (!response.ok || !data.success) {
          // Log enhanced error details if available
          if (data.code) {
            console.error('Error code:', data.code, '| Retryable:', data.retryable);
          }
          if (data.debug) {
            console.error('Debug info:', data.debug);
          }
          throw new Error(data.error || 'Failed to create story');
        }

        setApiKey(formData.get('apiKey'));

        window.location.href = '/play/' + data.storyId + '?page=1&newStory=true';
      } catch (error) {
        console.error('Story creation error:', error);
        showFormError(error instanceof Error ? error.message : 'Something went wrong. Please try again.');
        shouldReenable = true;
      } finally {
        loadingProgress.stop();
        loading.style.display = 'none';
        if (shouldReenable) {
          submitBtn.disabled = false;
        }
      }
    });
  }

  document.addEventListener('DOMContentLoaded', () => {
    initPlayPage();
    initNewStoryPage();
  });
})();
